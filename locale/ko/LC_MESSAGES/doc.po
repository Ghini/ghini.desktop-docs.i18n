# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2004-2017 bauble.classic & 2015-2017 ghini.desktop
# contributors
# This file is distributed under the same license as the Ghini package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
msgid ""
msgstr ""
"Project-Id-Version: Ghini 1.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-01-21 14:08-0500\n"
"PO-Revision-Date: 2021-05-03 09:32+0000\n"
"Last-Translator: 김주열 <quick3377@gmail.com>\n"
"Language-Team: Korean <https://hosted.weblate.org/projects/ghini/"
"documentation-10/ko/>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.7-dev\n"
"Generated-By: Babel 2.9.0\n"

#: ../../administration.rst:2
msgid "Database Administration"
msgstr "데이터베이스 관리"

#: ../../administration.rst:4
msgid ""
"If you are using a real DBMS to hold your botanic data, then you need do "
"something about database administration. While database administration is"
" far beyond the scope of this document, we make our users aware of it."
msgstr ""
"실제 DBMS를 사용하여 플랜트 데이터를 저장하는 경우 데이터베이스 관리를 수행해야합니다. 데이터베이스 관리는이 문서의 범위를 훨씬 벗어납니다. 사용자가 추가 작업을 알고 있어야하기 때문에 여기서 언급합니다."

#: ../../administration.rst:11
msgid ""
"SQLite is not what one would consider a real DBMS: each SQLite database "
"is just in one file. Make safety copies and you will be fine. If you "
"don't know where to look for your database files, consider that, per "
"default, bauble puts its data in the ``~/.bauble/`` directory."
msgstr ""
"SQLite는 DBMS로 간주 할 수있는 것이 아닙니다. 각 SQLite 데이터베이스는 파일 일뿐입니다. 백업 복사본을 만들면 모든 것이 정상입니다. 데이터베이스 파일을 찾을 위치를 모르는 경우 기본적으로 Ghini가 데이터를 ``~/.bauble/``-디렉토리에 저장한다는 점을 고려하십시오."

#: ../../administration.rst:16
msgid ""
"In Windows it is somewhere in your ``AppData`` directory, most likely in "
"``AppData\\Roaming\\Bauble``. Do keep in mind that Windows does its best "
"to hide the ``AppData`` directory structure to normal users."
msgstr ""
"Windows에서는 ``AppData`` 디렉토리, 아마도 ``AppData\Roaming\Bauble``-에 있습니다. Windows는 일반 사용자를 위해 ``AppData`` 디렉터리 구조를 숨기기 위해 최선을 다하고 있습니다."

#: ../../administration.rst:20
msgid ""
"The fastest way to open it is with the file explorer: type ``%APPDATA%`` "
"and hit enter."
msgstr "파일을 여는 가장 빠른 방법은 파일 관리자를 사용하는 것입니다 :``%APPDATA%``-를 입력하고 엔터를 누르세요."

#: ../../administration.rst:26
msgid ""
"Please refer to the `official documentation <https://mariadb.com/kb/en"
"/the-mariadb-library/documentation/>`_."
msgstr ""
"마이그레이션이 필요하면 `페이지를 <https://mariadb.com/kb/en/the-mariadb-library/"
"documentation/>`_ 참조하세요."

#: ../../administration.rst:28
msgid ""
"Backing up and restoring databases is described in breadth and depth "
"starting at `this page <https://mariadb.com/kb/en/the-mariadb-library"
"/backing-up-and-restoring-databases/>`_."
msgstr ""
"데이터베이스의 백업과 복원은 `다음페이지에 <https://mariadb.com/kb/en/the-mariadb-library/"
"backing-up-and-restoring-databases/>`_ 자세히 설명되어 있으니 활용하세요."

#: ../../administration.rst:35
msgid ""
"Please refer to the official documentation. A very thorough discussion of"
" your backup options starts at `chapter 24 "
"<http://www.postgresql.org/docs/9.1/static/backup.html>`_."
msgstr ""
"백업 옵션에 대한 `설명은24 장 으로 <http://www.postgresql.org/docs/9.1/static/backup.html>`"
"_ 넘어갑니다."

#: ../../administration.rst:39
msgid "Ghini Configuration"
msgstr "Ghini의 구성"

#: ../../administration.rst:41
msgid ""
"Ghini uses a configuration file to store values across invocations. This "
"file is associated to a user account and every user will have their own "
"configuration file."
msgstr ""
"Ghini는 구성 파일을 사용하여 호출간에 값을 저장합니다. 이 파일은 사용자 계정에 연결되며 모든 사용자는 고유 한 구성 파일을 "
"갖게됩니다."

#: ../../administration.rst:45
msgid ""
"To review the content of the Ghini configuration file, type ``:prefs`` in"
" the text entry area where you normally type your searches, then hit "
"enter."
msgstr ""
"Ghini 구성 파일의 내용을 검토하려면 일반적으로 검색을 입력하는 텍스트 항목 영역에 ``:prefs``-를 입력한 다음 enter를 "
"누르십시오."

#: ../../administration.rst:48
msgid ""
"You normally do not need tweaking the configuration file, but you can do "
"so with a normal text editor program. Ghini configuration file is at the "
"default location for SQLite databases."
msgstr ""
"일반적으로 구성 파일을 조정할 필요가 없지만 일반 텍스트 편집기 프로그램을 사용하여 조정할 수 있습니다. Ghini 구성 파일은 "
"SQLite 데이터베이스의 기본 위치에 있습니다."

#: ../../administration.rst:53
msgid "Reporting Errors"
msgstr "오류보고"

#: ../../administration.rst:55
msgid ""
"Should you notice anything unexpected in Ghini's behaviour, please "
"consider filing an issue on the Ghini development site."
msgstr "Ghini를 활용하면서 발생하는 예상치 못한 오류는 Ghini개발자에게 문제를 보내주세요."

#: ../../administration.rst:58
msgid "Ghini development site can be accessed via the Help menu."
msgstr "Ghini는 도움말 메뉴를 통해 액세스 할 수 있습니다."

#: ../../building.rst:2
msgid "Developer's Manual"
msgstr "개발자 매뉴얼"

#: ../../building.rst:4
msgid ""
"If you ran the ``devinstall`` installation instructions, you have "
"downloaded the sources, connected to the github repository.  You are in "
"the ideal situation to start looking into the software, understand how it"
" works, contribute to ghini.desktop's development."
msgstr ""
"``devinstall ''설치 지침을 실행했다면 github 저장소에 연결된 소스를 다운로드 한 것입니다. 소프트웨어 조사를 시작하고 "
"작동 방식을 이해하고 ghini.desktop의 개발에 기여할 수있는 이상적인 상황입니다."

#: ../../building.rst:10
msgid "Helping Ghini development"
msgstr "Ghini 개발 지원"

#: ../../building.rst:12
msgid ""
"If you want to contribute to Ghini, you can do so in quite a few "
"different ways:"
msgstr "Ghini에 기여하고 싶다면 다음과 같은 여러 가지 방법으로 기여할 수 있습니다:"

#: ../../building.rst:14
msgid ""
"Use the software, note the things you don't like, `open an issue "
"<http://github.com/Ghini/ghini.desktop/issues/new>`_ for each of them. A "
"developer will react sooner than you can imagine."
msgstr ""
"소프트웨어를 사용하고 마음에 들지 않는 부분을 확인하고 각각에 대해`<http://github.com/Ghini/ghini.desktop/"
"issues/new>`_ 문제를 엽니 다. 개발자는 상상할 수 있는 것보다 빨리 반응 할 것입니다."

#: ../../building.rst:17
msgid ""
"If you have an idea of what you miss in the software but can't quite "
"formalize it into separate issues, you could consider hiring a "
"professional. This is the best way to make sure that something happens "
"quickly on Ghini. Do make sure the developer opens issues and publishes "
"their contribution on github."
msgstr ""
"소프트웨어에서 놓친 부분에 대한 아이디어가 있지만 이를 별도의 문제로 공식화 할 수 없는 경우 전문가를 고용하는 것이 좋습니다. 이것은 "
"Ghini에서 어떤 일이 빠르게 발생하도록 하는 가장 좋은 방법입니다. 개발자가 이슈를 열고 github에 기여를 게시하는지 확인하십시오."

#: ../../building.rst:22
msgid ""
"Translate! Any help with translations will be welcome, so please do! you "
"can do this without installing anything on your computer, just using the "
"on-line translation service offered by http://hosted.weblate.org/"
msgstr ""
"번역하다! 번역에 대한 모든 도움을 환영합니다. http://hosted.weblate.org/에서 제공하는 온라인 번역 서비스를 "
"사용하면 컴퓨터에 아무것도 설치하지 않고도 이 작업을 수행 할 수 있습니다"

#: ../../building.rst:25
msgid ""
"fork the respository, choose an issue, solve it, open a pull request. See"
" the `bug solving workflow`_ below."
msgstr "리포지토리를 포크하고, 문제를 선택하고, 해결하고, 풀 요청을 엽니다. 아래의`버그 해결 워크플로우`_를 참조하십시오."

#: ../../building.rst:28
msgid ""
"If you haven't yet installed Ghini, and want to have a look at its code "
"history, you can open our `github project page "
"<http://github.com/Ghini/ghini.desktop>`_ and see all that has been going"
" on around Ghini since its inception as Bauble, back in the year 2004."
msgstr ""
"아직 Ghini를 설치하지 않았고 코드 기록을 보고 싶다면`github 프로젝트 페이지 <http://github.com/Ghini/"
"ghini.desktop>`_를 열고 2004 년에 Bauble로 시작된 이래 Ghini를 둘러 보았습니다."

#: ../../building.rst:33
msgid ""
"If you install the software according to the ``devinstall`` instructions,"
" you have the whole history in your local git clone."
msgstr "``devinstall ''지침에 따라 소프트웨어를 설치하면 로컬 git 클론에 전체 기록이 있습니다."

#: ../../building.rst:37
msgid "Software source, versions, branches"
msgstr "소프트웨어 소스, 버전, 분기"

#: ../../building.rst:39
msgid ""
"If you want a particular version of Ghini, we release and maintain "
"versions as branches. You should ``git checkout`` the branch "
"corresponding to the version of your choice."
msgstr ""
"특정 버전의 Ghini를 원하면 버전을 브랜치로 출시하고 유지합니다. 선택한 버전에 해당하는 브랜치를``git checkout ''해야 "
"합니다."

#: ../../building.rst:44
msgid "production line"
msgstr "생산 라인"

#: ../../building.rst:46
msgid ""
"Branch names for Ghini stable (production) versions are of the form "
"``ghini-x.y`` (eg: ghini-1.0); branch names where Ghini testing versions "
"are published are of the form ``ghini-x.y-dev`` (eg: ghini-1.0-dev)."
msgstr ""
"Ghini 안정 (프로덕션) 버전의 브랜치 이름은``ghini-x.y ''형식입니다 (예 : ghini-1.0). Ghini 테스트 "
"버전이 게시 된 브랜치 이름은``ghini-x.y-dev ''형식입니다 (예 : ghini-1.0-dev)."

#: ../../building.rst:51
msgid "Development Workflow"
msgstr "개발 워크 플로"

#: ../../building.rst:53
msgid ""
"Our workflow is to continuously commit to the testing branch, to often "
"push them to github, to let travis-ci and coveralls.io check the quality "
"of the pushed testing branches, finally, from time to time, to merge the "
"testing branch into the corresponding release."
msgstr ""
"우리의 워크플로우는 테스트 브랜치에 지속적으로 커밋하고, 종종 github로 푸시하고, travis-ci 및 coveralls.io가 "
"푸시 된 테스트 브랜치의 품질을 확인하고, 마지막으로 테스트 브랜치를 수시로 병합하도록 하는 것입니다. 해당 릴리스."

#: ../../building.rst:58
msgid ""
"When working at larger issues, which seem to take longer than a couple of"
" days, I might open a branch associated to the issue. I don't do this "
"very often."
msgstr ""
"며칠 이상 걸리는 것처럼 보이는 더 큰 문제에 대해 작업 할 때 문제와 관련된 분기를 열 수 있습니다. 나는 이것을 자주 하지 않는다."

#: ../../building.rst:63
msgid "larger issues"
msgstr "더 큰 문제"

#: ../../building.rst:65
msgid ""
"When facing a single larger issue, create a branch tag at the tip of a "
"main development line (e.g.: ``ghini-1.0-dev``), and follow the workflow "
"described at"
msgstr ""
"하나의 더 큰 문제가 발생하면 기본 개발 라인의 끝에 브랜치 태그 (예 :``ghini-1.0-dev '')를 만들고에 설명 된 워크 "
"플로를 따릅니다"

#: ../../building.rst:71
msgid "in short::"
msgstr "요컨대 ::"

#: ../../building.rst:77
msgid ""
"Work on the new temporary branch. When ready, go to github, merge the "
"branch with the main development line from which you branched, solve "
"conflicts where necessary, delete the temporary branch."
msgstr ""
"새 임시 브랜치에서 작업하십시오. 준비가 되면 github로 이동하여 분기 한 기본 개발 라인과 분기를 병합하고 필요한 경우 충돌을 "
"해결하고 임시 분기를 삭제하십시오."

#: ../../building.rst:81
msgid ""
"When ready for publication, merge the development line into the "
"corresponding production line."
msgstr "게시 할 준비가 되면 개발 라인을 해당 생산 라인에 병합합니다."

#: ../../building.rst:85
msgid "Updating the set of translatable strings"
msgstr "번역 가능한 문자열 집합 업데이트"

#: ../../building.rst:87
msgid ""
"From time to time, during the process of updating the software, you will "
"be adding or modifying strings in the python sources, in the "
"documentation, in the glade sources. Most of our strings are "
"translatable, and are offered to weblate for people to contribute, in the"
" form of several ``.po`` files."
msgstr ""
"때때로 소프트웨어를 업데이트하는 과정에서 파이썬 소스, 문서, glade 소스의 문자열을 추가하거나 수정합니다. 대부분의 문자열은 번역이 "
"가능하며 여러``.po ''파일 형식으로 사람들이 기여할 수 있도록 웨블레이트에 제공됩니다."

#: ../../building.rst:92
msgid ""
"A ``po`` is mostly composed of pairs of text portions, original and "
"translation, and is specific to a target language. When a translator adds"
" a translation on weblate, this reaches our repository on github. When a "
"programmer adds a string to the software, this reaches weblate as \"to be"
" translated\"."
msgstr ""
"``po ''는 대부분 원본과 번역의 텍스트 부분 쌍으로 구성되며 대상 언어에 따라 다릅니다. 번역가가 weblate에 번역을 추가하면 "
"github의 저장소에 도달합니다. 프로그래머가 소프트웨어에 문자열을 추가하면 \"to be translation\"으로 weblate에 "
"도달합니다."

#: ../../building.rst:98
msgid ""
"Weblate hosts the `Ghini <https://hosted.weblate.org/projects/ghini/>`_ "
"project. Within this project we have components, each of which "
"corresponds to a branch of a repository on github. Each component accepts"
" translations in several languages."
msgstr ""
"Weblate는`Ghini <https://hosted.weblate.org/projects/ghini/>`_ 프로젝트를 호스팅합니다. "
"이 프로젝트에는 github의 저장소 브랜치에 해당하는 구성 요소가 있습니다. 각 구성 요소는 여러 언어로 번역을 허용합니다."

#: ../../building.rst:104
msgid "component"
msgstr "구성 요소"

#: ../../building.rst:104
msgid "repository"
msgstr "저장소"

#: ../../building.rst:104
msgid "branch"
msgstr "분기"

#: ../../building.rst:107
msgid "Desktop 3.1"
msgstr "Desktop 3.1"

#: ../../building.rst:107 ../../building.rst:109
msgid "ghini-3.1-dev"
msgstr "ghini-3.1-dev"

#: ../../building.rst:109
msgid "Documentation 3.1"
msgstr "Documentation 3.1"

#: ../../building.rst:111
msgid "Pocket"
msgstr "포켓"

#: ../../building.rst:111 ../../ghini-family.rst:15
msgid "ghini.pocket"
msgstr "ghini.pocket"

#: ../../building.rst:112
msgid "Tour"
msgstr "Tour"

#: ../../building.rst:112 ../../ghini-family.rst:98
msgid "ghini.tour"
msgstr "ghini.tour"

#: ../../building.rst:115
msgid ""
"To update the ``po`` files relative to the *software*, you set the "
"working directory to the root of your checkout of *ghini.desktop*, and "
"you run the script::"
msgstr ""
"* software *와 관련된``po ''파일을 업데이트하려면 작업 디렉토리를 * ghini.desktop * 체크 아웃 루트로 "
"설정하고 스크립트를 실행합니다::"

#: ../../building.rst:121
msgid ""
"To update the ``po`` files relative to the *documentation*, you set the "
"working directory to the root of your checkout of *ghini.desktop-"
"docs.i18n*, and you run the script::"
msgstr ""
"* documentation *과 관련된``po ''파일을 업데이트하려면 작업 디렉토리를 * ghini.desktop-docs.i18n *"
" 체크 아웃 루트로 설정하고 다음 스크립트를 실행합니다::"

#: ../../building.rst:127
msgid ""
"When you run either of the above mentioned scripts, chances are you need "
"to commit *all* ``po`` files in the project. You may want to review the "
"changes before committing them to the respository. This is most important"
" when you perform a marginal correction to a string, like removing a "
"typo."
msgstr ""
"위에서 언급 한 스크립트 중 하나를 실행할 때 프로젝트에서 * 모든 *``po ''파일을 커밋해야 할 가능성이 있습니다. 저장소에 "
"커밋하기 전에 변경 사항을 검토 할 수 있습니다. 이것은 오타 제거와 같이 문자열에 대한 한계 수정을 수행 할 때 가장 중요합니다."

#: ../../building.rst:132
msgid ""
"Something that happens: running into a conflict. Solving conflicts is not"
" difficult once you know how to do that. First of all, add weblate as "
"remote::"
msgstr "일어나는 일 : 갈등에 빠진다. 갈등을 해결하는 방법을 알면 어렵지 않습니다. 먼저 weblate를 원격으로 추가하십시오::"

#: ../../building.rst:137
msgid ""
"Then make sure we are in the correct repository, on the correct branch, "
"update the remote, merge with it::"
msgstr "일어나는 일 : 갈등에 빠진다. 갈등을 해결하는 방법을 알면 어렵지 않습니다. 먼저 weblate를 원격으로 추가하십시오::"

#: ../../building.rst:144
msgid ""
"`Our documentation <https://readthedocs.org/projects/ghini/>`_ on "
"readthedocs has an original English version, and several translations. We"
" just follow the `description of localisation "
"<http://docs.readthedocs.io/en/latest/localization.html>`_, there's "
"nothing that we invented ourselves here."
msgstr ""
"`readthedocs의 문서 <https://readthedocs.org/projects/ghini/>`_에는 원본 영어 버전과 여러 "
"번역이 있습니다. 우리는`현지화 설명 <http://docs.readthedocs.io/en/latest/localization."
"html>`_을 따를뿐입니다. 여기서 우리가 스스로 발명 한 것은 없습니다."

#: ../../building.rst:150
msgid ""
"Readthedocs checks the project's *Language* setting, and invokes "
"``sphinx-intl`` to produce the formatted documentation in the target "
"language. With the default configuration —which we did not alter— "
"``sphinx-intl`` expects one ``po`` file per source document, named as the"
" source document, and that they all reside in the directory "
"``local/$(LANG)/LC_MESSAGES/``."
msgstr ""
"Readthedocs는 프로젝트의 * Language * 설정을 확인하고``sphinx-intl``을 호출하여 대상 언어로 형식화 된 "
"문서를 생성합니다. 우리가 변경하지 않은 기본 구성을 사용하면``sphinx-intl``은 소스 문서 당 하나의``po ''파일을 "
"예상하며 소스 문서로 명명되며 모두``local / $ ( LANG) / LC_MESSAGES /``."

#: ../../building.rst:157
msgid ""
"On the other hand, Weblate (and ourselves) prefers a single ``po`` file "
"per language, and keeps them all in the same ``/po`` directory, just as "
"we do for the software project: ``/po/$(LANG).po``."
msgstr ""
"반면에 웨블 레이트 (그리고 우리 자신)는 언어 당 하나의``po ''파일을 선호하며, 소프트웨어 프로젝트에서와 마찬가지로 모두 "
"동일한``/ po ''디렉토리에 보관합니다 :``/ po /$(LANG).po ''."

#: ../../building.rst:161
msgid ""
"In order not to repeat information, and to let both systems work their "
"natural way, we have two sets of symbolic links (git honors them)."
msgstr "정보를 반복하지 않고 두 시스템이 자연스럽게 작동하도록하기 위해 두 세트의 심볼릭 링크가 있습니다 (git이이를 존중합니다)."

#: ../../building.rst:164
msgid ""
"To summarise: when a file in the documentation is updated, the "
"``runme.sh`` script will:"
msgstr "요약하자면, 문서의 파일이 업데이트되면``runme.sh ''스크립트는 다음을 수행합니다.:"

#: ../../building.rst:167
msgid "copy the ``rst`` files from the software to the documentation;"
msgstr "소프트웨어에서 문서로``rst ''파일을 복사합니다;"

#: ../../building.rst:168
msgid "create a new ``pot`` file for each of the documentation files;"
msgstr "각 문서 파일에 대해 새``pot ''파일을 만듭니다;"

#: ../../building.rst:169
msgid "merge all ``pot`` files into one ``doc.pot``;"
msgstr "모든``pot ''파일을 하나의``doc.pot ''으로 병합합니다;"

#: ../../building.rst:170
msgid ""
"use the updated ``doc.pot`` to update all ``doc.po`` files (one per "
"language);"
msgstr "업데이트 된``doc.pot``을 사용하여 모든``doc.po ''파일을 업데이트합니다 (언어 당 하나씩);"

#: ../../building.rst:171
msgid "create all symbolic links:"
msgstr "모든 심볼릭 링크를 만듭니다:"

#: ../../building.rst:173
msgid "those expected by ``sphinx-intl`` in ``/local/$(LANG)/LC_MESSAGES/``"
msgstr "``/ local / $ (LANG) / LC_MESSAGES /``의``sphinx-intl``에 의해 예상되는 것"

#: ../../building.rst:174
msgid "those used by weblate in ``/po/$(LANG).po``"
msgstr "weblate에서 사용하는``/ po / $ (LANG) .po``"

#: ../../building.rst:176
msgid ""
"We could definitely write the above in a Makefile, or even better include"
" it in ``/doc/Makefile``. Who knows, maybe we will do that."
msgstr ""
"위의 내용을 Makefile에 작성하거나``/ doc / Makefile``에 포함하는 것이 더 좋습니다. 누가 알겠습니까, 아마도 "
"우리가 그렇게 할 것입니다."

#: ../../building.rst:180
msgid "Producing the docs locally"
msgstr "로컬에서 문서 생성"

#: ../../building.rst:182
msgid ""
"The above description is about how we help external sites produce our "
"documentation so that it is online for all to see.  But what if you want "
"to have the documentation locally, for example if you want to edit and "
"review before pushing your commits to the cloud?"
msgstr ""
"위의 설명은 모든 사람이 볼 수 있도록 외부 사이트에서 문서를 생성하는 데 도움이 되는 방법에 대한 것입니다. 그러나 예를 들어 커밋을 "
"클라우드로 푸시하기 전에 편집하고 검토하려는 경우와 같이 문서를 로컬로 갖고 싶다면 어떻게 해야 할까요?"

#: ../../building.rst:187
msgid ""
"In order to run sphinx locally, you need to install it **within** the "
"same virtual environment as ghini, and to install it there, you need to "
"have a sphinx version whose dependencies don not conflict with "
"ghini.desktop's dependecies."
msgstr ""
"sphinx를 로컬에서 실행하려면 ghini와 동일한 가상 환경 ** 내 **에 설치해야 하며, 여기에 설치하려면 종속성이 "
"ghini.desktop의 종속성과 충돌하지 않는 sphinx 버전이 있어야 합니다."

#: ../../building.rst:192
msgid "What we do to keep this in order?"
msgstr "이것을 순서대로 유지하려면 어떻게해야합니까?"

#: ../../building.rst:194
msgid ""
"We state this extra dependency in the ``setup.py`` file, as an "
"``extras_require`` entry.  Create and activate the virtual environment, "
"then run ``easy_install ghini.desktop[docs]``.  This gets you the sphinx "
"version as declared in the ``setup.py`` file."
msgstr ""
"이 추가 종속성은``setup.py ''파일에``extras_require ''항목으로 명시합니다. 가상 환경을 생성하고 활성화 한 "
"다음``easy_install ghini.desktop [docs]``를 실행합니다. 이렇게 하면``setup.py ''파일에 선언 된 "
"스핑크스 버전이 표시됩니다."

#: ../../building.rst:199
msgid ""
"If all you want is the html documentation built locally, run ``./setup.py"
" install docs``.  For more options, enter the ``doc`` directory and run "
"``make``."
msgstr ""
"로컬에서 빌드 된 html 문서 만 원하는 경우``./setup.py install docs``를 실행하십시오. 더 많은 옵션을 보려면``"
"doc ''디렉토리를 입력하고``make ''를 실행하십시오."

#: ../../building.rst:204
msgid "Which way do the translated strings reach our users?"
msgstr "번역 된 문자열은 어떤 방식으로 사용자에게 전달됩니까?"

#: ../../building.rst:206
msgid ""
"A new translator asked the question, adding: »Is this an automated "
"process from Weblate --> GIT --> Ghini Desktop installed on users "
"computers, or does this require manual steps?"
msgstr ""
"새로운 번역가가 다음과 같이 질문했습니다.»Weblate-> GIT-> 사용자 컴퓨터에 설치된 Ghini Desktop의 자동화 된 "
"프로세스입니까, 아니면 수동 단계가 필요합니까?"

#: ../../building.rst:210
msgid ""
"The aswer is that the whole interaction is quite complex, and it depends "
"on the component."
msgstr "문제는 전체 상호 작용이 매우 복잡하고 구성 요소에 따라 다르다는 것입니다."

#: ../../building.rst:213
msgid ""
"When you install ``ghini.desktop`` or one of the Android apps, the "
"installation doesn't assume a specific run-time language: a user can "
"change their language configuration any time.  So what we do is to "
"install the software in English together with a translation table from "
"English to whatever else."
msgstr ""
"``ghini.desktop ''또는 Android 앱 중 하나를 설치할 때 설치는 특정 런타임 언어를 가정하지 않습니다. 사용자는 "
"언제든지 언어 구성을 변경할 수 있습니다. 그래서 우리가하는 일은 영어로 된 번역 표와 함께 영어로 된 소프트웨어를 설치하는 것입니다."

#: ../../building.rst:219
msgid ""
"At run-time the GUI libraries (Android or GTK) know where to look for the"
" translation strings.  These translation tables are generated during the "
"installation or upgrade process, based on the strings you see on Weblate."
msgstr ""
"런타임에 GUI 라이브러리 (Android 또는 GTK)는 번역 문자열을 찾을 위치를 알고 있습니다. 이러한 번역 테이블은 "
"Weblate에 표시되는 문자열을 기반으로 설치 또는 업그레이드 프로세스 중에 생성됩니다."

#: ../../building.rst:223
msgid ""
"The path followed by translations is: You edit strings on Weblate, "
"Weblate keeps accumulating them until you are done, or you don't interact"
" with Weblate for a longer while; Weblate pushes the strings to github, "
"directly into the development line ``ghini-1.0-dev``; I see them and I "
"might blindly trust or prefer to review them, maybe I look them up in "
"wikipedia or get them translated back to Italian, Spanish or English by "
"some automatic translation service; sometimes I need to solve conflicts "
"arising because of changed context, not too often fortunately.  As said, "
"this lands in the development line ``ghini-1.0-dev``, which I regularly "
"publish to the production line ``ghini-1.0``, and this is the moment when"
" the new translations finally make it to the distributed software."
msgstr ""
"번역이 뒤 따르는 경로는 다음과 같습니다. Weblate에서 문자열을 편집하거나, Weblate가 완료 될 때까지 문자열을 계속 "
"축적하거나, Weblate와 오랫동안 상호 작용하지 않습니다. Weblate는 문자열을 github에 직접 푸시하여 개발 "
"라인``ghini-1.0-dev ''로 보냅니다. 나는 그들을 보고 맹목적으로 신뢰하거나 검토하는 것을 선호 할 수 있습니다. "
"위키피디아에서 찾아 보거나 자동 번역 서비스를 통해 이탈리아어, 스페인어 또는 영어로 다시 번역 할 수도 있습니다. 때로는 상황이 "
"변경되어 발생하는 갈등을 해결해야 합니다. 말했듯이 이것은 개발 라인``ghini-1.0-dev ''에 도착하며, 저는 정기적으로 생산 "
"라인``ghini-1.0 ''에 게시하고 있으며, 이것은 새로운 번역이 마침내 배포 된 소프트웨어."

#: ../../building.rst:235
msgid ""
"Users will notice a *new version available* warning and can decide to "
"ignore it, or to update."
msgstr "사용자는 * 사용 가능한 새 버전 * 경고를보고 무시하거나 업데이트 할 수 있습니다."

#: ../../building.rst:238
msgid ""
"For ``ghini.pocket``, it is similar, but the notification is handled by "
"the Android system.  We publish on the Play Store, and depending on your "
"settings, your phone will update the software automatically, or only "
"notify you, or do nothing.  It depends on how you configured automatic "
"updates."
msgstr ""
"``ghini.pocket``의 경우 비슷하지만 Android 시스템에서 알림을 처리합니다. Google은 Play 스토어에 게시하며 "
"설정에 따라 휴대 전화가 소프트웨어를 자동으로 업데이트하거나 알림 만 보내거나 아무것도 하지 않습니다. 자동 업데이트를 구성한 방법에 "
"따라 다릅니다."

#: ../../building.rst:243
msgid "For ``ghini.web``, we haven't yet defined how to distribute it."
msgstr "``ghini.web``의 경우 배포 방법을 아직 정의하지 않았습니다."

#: ../../building.rst:245
msgid ""
"For ghini's documentation, it's completely automatic, and all is handled "
"by readthedocs.org."
msgstr "ghini 문서의 경우 완전히 자동이며 모두 readthedocs.org에서 처리합니다."

#: ../../building.rst:250
msgid "Adding missing unit tests"
msgstr "누락 된 단위 테스트 추가"

#: ../../building.rst:252
msgid ""
"If you are interested contributing to development of Ghini, a good way to"
" do so would be by helping us finding and writing the missing unit tests."
msgstr "Ghini 개발에 관심이 있으시다면, 누락 된 단위 테스트를 찾고 작성하도록 도와 주시면 좋은 방법이 될 것입니다."

#: ../../building.rst:255
msgid ""
"A well tested function is one whose behaviour you cannot change without "
"breaking at least one unit test."
msgstr "잘 테스트 된 함수는 적어도 하나의 단위 테스트를 위반하지 않고는 동작을 변경할 수 없는 함수입니다."

#: ../../building.rst:258
msgid ""
"We all agree that in theory theory and practice match perfectly and that "
"one first writes the tests, then implements the function. In practice, "
"however, practice does not match theory and we have been writing tests "
"after writing and even publishing the functions."
msgstr ""
"우리 모두는 이론과 실습에서 완벽하게 일치하고 먼저 테스트를 작성한 다음 기능을 구현한다는 데 동의합니다. 그러나 실제로 실습은 이론과 "
"일치하지 않으며 함수를 작성하고 게시 한 후 테스트를 작성했습니다."

#: ../../building.rst:263
msgid ""
"This section describes the process of adding unit tests for "
"``bauble.plugins.plants.family.remove_callback``."
msgstr ""
"이 섹션에서는``bauble.plugins.plants.family.remove_callback``에 대한 단위 테스트를 추가하는 "
"프로세스를 설명합니다."

#: ../../building.rst:267
msgid "What to test"
msgstr "테스트 할 내용"

#: ../../building.rst:269
msgid ""
"First of all, open the coverage report index, and choose a file with low "
"coverage."
msgstr "먼저 커버리지 보고서 색인을 열고 커버리지가 낮은 파일을 선택합니다."

#: ../../building.rst:272
msgid ""
"For this example, run in October 2015, we landed on "
"``bauble.plugins.plants.family``, at 33%."
msgstr ""
"2015 년 10 월에 실행 된 이 예제의 경우 33 %로``bauble.plugins.plants.family``에 도달했습니다."

#: ../../building.rst:277
msgid ""
"The first two functions which need tests, ``edit_callback`` and "
"``add_genera_callback``, include creation and activation of an object "
"relying on a custom dialog box. We should really first write unit tests "
"for that class, then come back here."
msgstr ""
"테스트가 필요한 처음 두 함수 인``edit_callback ''및``add_genera_callback ''에는 사용자 지정 대화 "
"상자에 의존하는 개체의 생성 및 활성화가 포함됩니다. 먼저 해당 클래스에 대한 단위 테스트를 작성한 다음 여기로 돌아와야합니다."

#: ../../building.rst:282
msgid ""
"The next function, ``remove_callback``, also activates a couple of dialog"
" and message boxes, but in the form of invoking a function requesting "
"user input via yes-no-ok boxes. These functions we can easily replace "
"with a function mocking the behaviour."
msgstr ""
"다음 기능인``remove_callback ''은 대화 상자와 메시지 상자 두 개를 활성화하지만 예-아니오 상자를 통해 사용자 입력을 "
"요청하는 기능을 호출하는 형태입니다. 이러한 함수는 동작을 조롱하는 함수로 쉽게 대체 할 수 있습니다."

#: ../../building.rst:288
msgid "how to test"
msgstr "테스트 방법"

#: ../../building.rst:290
msgid ""
"So, having decided what to describe in unit test, we look at the code and"
" we see it needs discriminate a couple of cases:"
msgstr "따라서 단위 테스트에서 무엇을 설명할지 결정한 후 코드를 살펴보면 몇 가지 경우를 구별해야합니다:"

#: ../../building.rst:296
msgid "**parameter correctness**"
msgstr "** 매개 변수 정확성 **"

#: ../../building.rst:294
msgid "the list of families has no elements."
msgstr "과 목록에는 요소가 없습니다."

#: ../../building.rst:295
msgid "the list of families has more than one element."
msgstr "과 목록에는 요소가 없습니다."

#: ../../building.rst:296
msgid "the list of families has exactly one element."
msgstr "과 목록에는 정확히 하나의 요소가 있습니다."

#: ../../building.rst:300
msgid "**cascade**"
msgstr "**종속**"

#: ../../building.rst:299
msgid "the family has no genera"
msgstr "과는 속이 없다"

#: ../../building.rst:300
msgid "the family has one or more genera"
msgstr "과에 하나 이상의 속이 있습니다"

#: ../../building.rst:304
msgid "**confirm**"
msgstr "** 확인 **"

#: ../../building.rst:303
msgid "the user confirms deletion"
msgstr "사용자가 삭제를 확인"

#: ../../building.rst:304
msgid "the user does not confirm deletion"
msgstr "사용자가 삭제를 확인하지 않음"

#: ../../building.rst:308
msgid "**deleting**"
msgstr "** 삭제 **"

#: ../../building.rst:307
msgid "all goes well when deleting the family"
msgstr "속을 삭제할 때 모든 것이 잘됩니다"

#: ../../building.rst:308
msgid "there is some error while deleting the family"
msgstr "과를 삭제하는 동안 약간의 오류가 있습니다"

#: ../../building.rst:310
msgid ""
"I decide I will only focus on the **cascade** and the **confirm** "
"aspects. Two binary questions: 4 cases."
msgstr "** 캐스케이드 ** 및 ** 확인 ** 측면에만 집중하기로 결정했습니다. 2 개의 이진 질문 : 4 개의 경우."

#: ../../building.rst:314
msgid "where to put the tests"
msgstr "테스트를 둘 위치"

#: ../../building.rst:316
msgid ""
"Locate the test script and choose the class where to put the extra unit "
"tests."
msgstr "테스트 스크립트를 찾고 추가 단위 테스트를 넣을 클래스를 선택합니다."

#: ../../building.rst:320
msgid "what about skipped tests"
msgstr "건너 뛴 테스트는 어떻습니까"

#: ../../building.rst:323
msgid ""
"The ``FamilyTests`` class contains a skipped test, implementing it will "
"be quite a bit of work because we need rewrite the FamilyEditorPresenter,"
" separate it from the FamilyEditorView and reconsider what to do with the"
" FamilyEditor class, which I think should be removed and replaced with a "
"single function."
msgstr ""
"``Family Tests ''클래스에는 건너 뛴 테스트가 포함되어 있습니다. Family Editor Presenter를 다시 "
"작성하고이를 Family Editor View에서 분리하고 제거해야 한다고 생각하는 Family Editor 클래스로 수행 할 작업을 "
"다시 고려해야 하기 때문에 구현하는 작업이 상당히 많을 것입니다. 단일 기능으로 대체되었습니다."

#: ../../building.rst:330
msgid "writing the tests"
msgstr "테스트 작성"

#: ../../building.rst:332
msgid ""
"After the last test in the FamilyTests class, I add the four cases I want"
" to describe, and I make sure they fail, and since I'm lazy, I write the "
"most compact code I know for generating an error::"
msgstr ""
"FamilyTests 클래스의 마지막 테스트 후에 설명하고 싶은 네 가지 사례를 추가하고 실패하는지 확인하고 게으르기 때문에 오류 생성에 "
"대해 알고 있는 가장 간단한 코드를 작성합니다::"

#: ../../building.rst:349
msgid "One test, step by step"
msgstr "단계별 테스트"

#: ../../building.rst:351
msgid "Let's start with the first test case."
msgstr "첫 번째 테스트 케이스부터 시작하겠습니다."

#: ../../building.rst:353
msgid "When writing tests, I generally follow the pattern:"
msgstr "테스트를 작성할 때 일반적으로 다음 패턴을 따릅니다:"

#: ../../building.rst:355
msgid "T₀ (initial condition),"
msgstr "T₀ (초기 조건),"

#: ../../building.rst:356
msgid "action,"
msgstr "동작,"

#: ../../building.rst:357
msgid "T₁ (testing the result of the action given the initial conditions)"
msgstr "T₁ (초기 조건이 주어진 경우 작업 결과 테스트)"

#: ../../building.rst:359
msgid "what's in a name — unit tests"
msgstr "이름에있는 것 — 단위 테스트"

#: ../../building.rst:362
msgid ""
"There's a reason why unit tests are called unit tests. Please never test "
"two actions in one test."
msgstr "단위 테스트를 단위 테스트라고 부르는 데에는 이유가 있습니다. 한 번의 테스트에서 두 가지 작업을 테스트하지 마십시오."

#: ../../building.rst:365
msgid ""
"So let's describe T₀ for the first test, a database holding a family "
"without genera::"
msgstr "그럼 첫 번째 테스트의 T₀에 대해 설명해 봅시다. 속이없는 가족을 포함하는 데이터베이스 :"

#: ../../building.rst:373
msgid ""
"We do not want the function being tested to invoke the interactive "
"``utils.yes_no_dialog`` function, we want ``remove_callback`` to invoke a"
" non-interactive replacement function. We achieve this simply by making "
"``utils.yes_no_dialog`` point to a ``lambda`` expression which, like the "
"original interactive function, accepts one parameter and returns a "
"boolean. In this case: ``False``::"
msgstr ""
"테스트중인 함수가 대화 형``utils.yes_no_dialog ''함수를 호출하는 것을 원하지 않고,``remove_callback``"
"이 비대화 형 대체 함수를 호출하도록합니다. ``utils.yes_no_dialog``가 원래의 대화 형 함수와 마찬가지로 하나의 매개 "
"변수를 받아들이고 부울을 반환하는``람다 ''표현식을 가리 키도록 만들기 만하면됩니다. 이 경우 :``False ''::"

#: ../../building.rst:391
msgid "Next we test the result."
msgstr "다음으로 결과를 테스트합니다."

#: ../../building.rst:393
msgid ""
"Well, we don't just want to test whether or not the object Arecaceae was "
"deleted, we also should test the value returned by ``remove_callback``, "
"and whether ``yes_no_dialog`` and ``message_details_dialog`` were invoked"
" or not."
msgstr ""
"음, 우리는 Arecaceae 개체가 삭제되었는지 여부를 테스트하는 것이 아니라``remove_callback ''에서 반환 된 값과``"
"yes_no_dialog ''및``message_details_dialog ''가 호출되었는지 여부도 테스트해야합니다. ."

#: ../../building.rst:398
msgid ""
"A ``lambda`` expression is not enough for this. We do something "
"apparently more complex, which will make life a lot easier."
msgstr "``람다 ''표현만으로는 충분하지 않습니다. 우리는 분명히 더 복잡한 일을하여 삶을 훨씬 더 쉽게 만듭니다."

#: ../../building.rst:401
msgid "Let's first define a rather generic function::"
msgstr "먼저 다소 일반적인 함수를 정의 해 보겠습니다::"

#: ../../building.rst:407
msgid ""
"and we grab ``partial`` from the ``functools`` standard module, to "
"partially apply the above ``mockfunc``, leaving only ``msg`` unspecified,"
" and use this partial application, which is a function accepting one "
"parameter and returning a value, to replace the two functions in "
"``utils``. The test function now looks like this::"
msgstr ""
"그리고 우리는``functools ''표준 모듈에서``partial ''을 가져 와서 위의``mockfunc ''를 부분적으로 적용하고``"
"msg ''만 지정하지 않고이 부분 응용 프로그램을 사용합니다. 매개 변수와 값을 반환하여``utils ''의 두 함수를 대체합니다. "
"이제 테스트 기능은 다음과 같습니다::"

#: ../../building.rst:429
msgid ""
"The test section checks that ``message_details_dialog`` was not invoked, "
"that ``yes_no_dialog`` was invoked, with the correct message parameter, "
"that Arecaceae is still there::"
msgstr ""
"테스트 섹션은``message_details_dialog``가 호출되지 않았는지,``yes_no_dialog``가 올바른 메시지 매개 "
"변수와 함께 호출되었는지, Arecaceae가 아직 거기에 있는지 확인합니다::"

#: ../../building.rst:445
msgid "And so on"
msgstr "등등"

#: ../../building.rst:447
msgid ""
"`there are two kinds of people, those who complete what they start, and "
"so on`"
msgstr "`시작한 것을 완수하는 두 종류의 사람들이있다`"

#: ../../building.rst:450
msgid ""
"Next test is almost the same, with the difference that the "
"``utils.yes_no_dialog`` should return ``True`` (this we achieve by "
"specifying ``result=True`` in the partial application of the generic "
"``mockfunc``)."
msgstr ""
"다음 테스트는``utils.yes_no_dialog``가``True ''를 반환해야한다는 차이점을 제외하면 거의 동일합니다 (일반``"
"mockfunc ''의 부분 응용 프로그램에서``result = True``를 지정하여 달성합니다. `)."

#: ../../building.rst:455
msgid ""
"With this action, the value returned by ``remove_callback`` should be "
"``True``, and there should be no Arecaceae Family in the database any "
"more::"
msgstr ""
"이 작업을 통해``remove_callback``에서 반환 된 값은``True ''여야하며 데이터베이스에 Arecaceae Family가 "
"더 이상 없어야합니다::"

#: ../../building.rst:485
msgid ""
"have a look at commit 734f5bb9feffc2f4bd22578fcee1802c8682ca83 for the "
"other two test functions."
msgstr "다른 두 테스트 기능에 대한 커밋 734f5bb9feffc2f4bd22578fcee1802c8682ca83을 살펴보십시오."

#: ../../building.rst:489
msgid "Testing logging"
msgstr "로깅 테스트"

#: ../../building.rst:491
msgid ""
"Our ``bauble.test.BaubleTestCase`` objects use handlers of the class "
"``bauble.test.MockLoggingHandler``.  Every time an individual unit test "
"is started, the ``setUp`` method will create a new ``handler`` and "
"associate it to the root logger.  The ``tearDown`` method takes care of "
"removing it."
msgstr ""
"우리의``bauble.test.BaubleTestCase ''객체는``bauble.test.MockLoggingHandler`` 클래스의 "
"핸들러를 사용합니다. 개별 단위 테스트가 시작될 때마다``setUp ''메소드는 새로운``핸들러 ''를 생성하고이를 루트 로거에 "
"연결합니다. ``tearDown ''메소드가이를 제거합니다."

#: ../../building.rst:496
#, python-format
msgid ""
"You can check for presence of specific logging messages in "
"``self.handler.messages``. ``messages`` is a dictionary, initially empty,"
" with two levels of indexation. First the name of the logger issuing the "
"logging record, then the name of the level of the logging record. Keys "
"are created when needed. Values hold lists of messages, formatted "
"according to whatever formatter you associate to the handler, defaulting "
"to ``logging.Formatter(\"%(message)s\")``."
msgstr ""
"``self.handler.messages``에서 특정 로깅 메시지의 존재 여부를 확인할 수 있습니다. ``messages``는 두 가지 "
"수준의 인덱싱이있는 사전이며 처음에는 비어 있습니다. 먼저 로깅 레코드를 발행하는 로거의 이름, 그 다음 로깅 레코드의 레벨 이름입니다. "
"필요한 경우 키가 생성됩니다. 값은 핸들러에 연결하는 포맷터에 따라 형식이 지정된 메시지 목록을 보유하며 기본값은``"
"logging.Formatter ( \"% (message) s\")``입니다."

#: ../../building.rst:504
msgid ""
"You can explicitly empty the collected messages by invoking "
"``self.handler.clear()``."
msgstr "``self.handler.clear ()``를 호출하여 수집 된 메시지를 명시 적으로 비울 수 있습니다."

#: ../../building.rst:509
msgid "Putting all together"
msgstr "모두 합치기"

#: ../../building.rst:511
msgid "From time to time you want to activate the test class you're working at::"
msgstr "때때로 작업중인 테스트 클래스를 활성화하고 싶습니다::"

#: ../../building.rst:515
msgid "And at the end of the process you want to update the statistics::"
msgstr "프로세스가 끝나면 통계를 업데이트 할 수 있습니다::"

#: ../../building.rst:521
msgid "Structure of user interface"
msgstr "사용자 인터페이스 구조"

#: ../../building.rst:523
msgid ""
"The user interface is built according to the **Model** — **View** — "
"**Presenter** architectural pattern.  For much of the interface, "
"**Model** is a SQLAlchemy database object, but we also have interface "
"elements where there is no corresponding database model.  In general:"
msgstr ""
"사용자 인터페이스는 ** 모델 ** — **보기 ** — ** 발표자 ** 아키텍처 패턴에 따라 구축됩니다. 대부분의 인터페이스에서 ** "
"Model **은 SQLAlchemy 데이터베이스 개체이지만 해당 데이터베이스 모델이없는 인터페이스 요소도 있습니다. 일반적으로 :"

#: ../../building.rst:528
msgid ""
"The **View** is described as part of a **glade** file. This should "
"include the signal-callback and ListStore-TreeView associations. Just "
"reuse the base class ``GenericEditorView`` defined in ``bauble.editor``. "
"When you create your instance of this generic class, pass it the "
"**glade** file name and the root widget name, then hand this instance "
"over to the **presenter** constructor."
msgstr ""
"**보기 **는 ** glade ** 파일의 일부로 설명됩니다. 여기에는 신호 콜백 및 ListStore-TreeView 연결이 "
"포함되어야합니다. ``bauble.editor``에 정의 된 기본 클래스``GenericEditorView ''를 재사용하면됩니다. 이 "
"일반 클래스의 인스턴스를 만들 때 ** glade ** 파일 이름과 루트 위젯 이름을 전달한 다음이 인스턴스를 ** presenter **"
" 생성자에게 넘깁니다."

#: ../../building.rst:535
msgid ""
"In the glade file, in the ``action-widgets`` section closing your "
"GtkDialog object description, make sure every ``action-widget`` element "
"has a valid ``response`` value.  Use `valid GtkResponseType values "
"<http://gtk.php.net/manual/en/html/gtk/gtk.enum.responsetype.html>`_, for"
" example:"
msgstr ""
"glade 파일의``action-widgets ''섹션에서 GtkDialog 객체 설명을 닫고 모든``action-widget ''요소에 "
"유효한``response ''값이 있는지 확인합니다. `유효한 GtkResponseType 값 <http://gtk.php.net/"
"manual/en/html/gtk/gtk.enum.responsetype.html>`_을 사용합니다. 예를 들면 다음과 같습니다:"

#: ../../building.rst:546
msgid ""
"There is no easy way to unit test a subclassed view, so please don't "
"subclass views, there's really no need to."
msgstr "하위 클래스 뷰를 단위 테스트하는 쉬운 방법이 없으므로 뷰를 하위 클래스로 만들지 마십시오. 실제로 그럴 필요가 없습니다."

#: ../../building.rst:549
msgid ""
"In the glade file, every input widget should define which handler is "
"activated on which signal.  The generic Presenter class offers generic "
"callbacks which cover the most common cases."
msgstr ""
"glade 파일에서 모든 입력 위젯은 어떤 신호에서 어떤 핸들러가 활성화되는지 정의해야합니다. 일반 Presenter 클래스는 가장 "
"일반적인 경우를 다루는 일반 콜백을 제공합니다."

#: ../../building.rst:553
msgid ""
"GtkEntry (one-line text entry) will handle the ``changed`` signal, with "
"either ``on_text_entry_changed`` or ``on_unique_text_entry_changed``."
msgstr ""
"GtkEntry (한 줄 텍스트 항목)는``on_text_entry_changed "
"''또는``on_unique_text_entry_changed``와 함께``changed ''신호를 처리합니다."

#: ../../building.rst:555
msgid ""
"GtkTextView: associate it to a GtkTextBuffer. To handle the ``changed`` "
"signal on the GtkTextBuffer, we have to define a handler which invokes "
"the generic ``on_textbuffer_changed``, the only role for this function is"
" to pass our generic handler the name of the model attribute that "
"receives the change. This is a workaroud for an `unresolved bug in GTK "
"<http://stackoverflow.com/questions/32106765/>`_."
msgstr ""
"GtkTextView : GtkTextBuffer에 연결합니다. GtkTextBuffer에서``changed ''신호를 처리하려면 "
"일반``on_textbuffer_changed``를 호출하는 핸들러를 정의해야합니다.이 함수의 유일한 역할은 일반 핸들러에 수신되는 모델 "
"속성의 이름을 전달하는 것입니다. 변화. 이것은 GTK <http://stackoverflow.com/questions/32106765/"
">`_의 해결되지 않은 버그에 대한 해결 방법입니다."

#: ../../building.rst:561
msgid ""
"GtkComboBox with translated texts can't be easily handled from the glade "
"file, so we don't even try.  Use the ``init_translatable_combo`` method "
"of the generic ``GenericEditorView`` class, but please invoke it from the"
" **presenter**."
msgstr ""
"번역 된 텍스트가있는 GtkComboBox는 glade 파일에서 쉽게 처리 할 수 없으므로 시도조차하지 않습니다. 일반``"
"GenericEditorView ''클래스의``init_translatable_combo ''메소드를 사용하되 ** presenter **"
"에서 호출하십시오."

#: ../../building.rst:566
msgid ""
"The **Model** is just an object with known attributes. In this "
"interaction, the **model** is just a passive data container, it does "
"nothing more than to let the **presenter** modify it."
msgstr ""
"** 모델 **은 알려진 속성을 가진 개체입니다. 이 상호 작용에서 ** 모델 **은 단지 수동적 인 데이터 컨테이너 일 뿐이며 ** "
"발표자 **가 수정하도록하는 것 이상을 수행하지 않습니다."

#: ../../building.rst:570
msgid "The subclassed **Presenter** defines and implements:"
msgstr "서브 클래 싱 된 ** Presenter **는 다음을 정의하고 구현합니다:"

#: ../../building.rst:572
msgid ""
"``widget_to_field_map``, a dictionary associating widget names to name of"
" model attributes,"
msgstr "``widget_to_field_map '', 위젯 이름을 모델 속성 이름에 연결하는 사전,"

#: ../../building.rst:574
msgid ""
"``view_accept_buttons``, the list of widget names which, if activated by "
"the user, mean that the view should be closed,"
msgstr "``view_accept_buttons``, 사용자가 활성화하면 뷰를 닫아야 함을 의미하는 위젯 이름 목록,"

#: ../../building.rst:576
msgid "all needed callbacks,"
msgstr "필요한 모든 콜백,"

#: ../../building.rst:577
msgid "optionally, it plays the **model** role, too."
msgstr "선택적으로 ** 모델 ** 역할도 수행합니다."

#: ../../building.rst:579
msgid ""
"The **presenter** continuously updates the **model** according to changes"
" in the **view**. If the **model** corresponds to a database object, the "
"**presenter** commits all **model** updates to the database when the "
"**view** is closed successfully, or rolls them back if the **view** is "
"canceled. (this behaviour is influenced by the parameter ``do_commit``)"
msgstr ""
"** 발표자 **는 **보기 **의 변경 사항에 따라 ** 모델 **을 지속적으로 업데이트합니다. ** 모델 **이 데이터베이스 개체에 "
"해당하는 경우 ** 발표자 **는 **보기 **가 성공적으로 닫힐 때 모든 ** 모델 ** 업데이트를 데이터베이스에 커밋하거나 **보기 "
"**가 ** 취소됩니다. (이 동작은``do_commit ''매개 변수의 영향을받습니다)"

#: ../../building.rst:585
msgid ""
"If the **model** is something else, then the **presenter** will do "
"something else."
msgstr "** 모델 **이 다른 경우 ** 발표자 **가 다른 작업을 수행합니다."

#: ../../building.rst:590
msgid ""
"A well behaved **presenter** uses the **view** api to query the values "
"inserted by the user or to forcibly set widget statuses. Please do not "
"learn from the practice of our misbehaving presenters, some of which "
"directly handle fields of ``view.widgets``. By doing so, these presenters"
" prevents us from writing unit tests."
msgstr ""
"잘 작동하는 ** 발표자 **는 ** view ** API를 사용하여 사용자가 삽입 한 값을 쿼리하거나 위젯 상태를 강제로 설정합니다. "
"일부는``view.widgets`` 필드를 직접 처리하는 오작동하는 발표자의 관행에서 배우지 마십시오. 그렇게함으로써 이러한 발표자는 "
"우리가 단위 테스트를 작성하지 못하게합니다."

#: ../../building.rst:596
msgid ""
"The base class for the presenter, ``GenericEditorPresenter`` defined in "
"``bauble.editor``, implements many useful generic callbacks.  There is a "
"``MockView`` class, that you can use when writing tests for your "
"presenters."
msgstr ""
"발표자의 기본 클래스 인``bauble.editor``에 정의 된``Generic Editor Presenter``는 많은 유용한 일반 "
"콜백을 구현합니다. 발표자를위한 테스트를 작성할 때 사용할 수 있는``MockView ''클래스가 있습니다."

#: ../../building.rst:601
msgid "Examples"
msgstr "예"

#: ../../building.rst:603
msgid ""
"``Contact`` and ``ContactPresenter`` are implemented following the above "
"lines.  The view is defined in the ``contact.glade`` file."
msgstr ""
"``Contact ''및``ContactPresenter``는 위의 줄에 따라 구현됩니다. 보기는``contact.glade`` 파일에 "
"정의되어 있습니다."

#: ../../building.rst:606
msgid ""
"A good example of Presenter/View pattern (no model) is given by the "
"connection manager."
msgstr "발표자 /보기 패턴 (모델 없음)의 좋은 예는 연결 관리자에 의해 제공됩니다."

#: ../../building.rst:609
msgid ""
"We use the same architectural pattern for non-database interaction, by "
"setting the presenter also as model. We do this, for example, for the "
"JSON export dialog box. The following command will give you a list of "
"``GenericEditorView`` instantiations::"
msgstr ""
"발표자를 모델로 설정하여 데이터베이스가 아닌 상호 작용에 동일한 아키텍처 패턴을 사용합니다. 예를 들어 JSON 내보내기 대화 상자에 "
"대해이 작업을 수행합니다. 다음 명령은``GenericEditorView ''인스턴스화 목록을 제공합니다::"

#: ../../building.rst:617
msgid "Extending Ghini with Plugins"
msgstr "플러그인으로 Ghini 확장"

#: ../../building.rst:619
msgid ""
"Nearly everything about Ghini is extensible through plugins. Plugins can "
"create tables, define custom searchs, add menu items, create custom "
"commands and more."
msgstr ""
"Ghini에 관한 거의 모든 것은 플러그인을 통해 확장 할 수 있습니다. 플러그인은 테이블 생성, 사용자 지정 검색 정의, 메뉴 항목 "
"추가, 사용자 지정 명령 생성 등을 수행 할 수 있습니다."

#: ../../building.rst:623
msgid ""
"To create a new plugin you must extend the ``bauble.pluginmgr.Plugin`` "
"class."
msgstr "새 플러그인을 생성하려면``bauble.pluginmgr.Plugin ''클래스를 확장해야합니다."

#: ../../building.rst:626
msgid ""
"The ``Tag`` plugin is a good minimal example, even if the ``TagItemGUI`` "
"falls outside the Model-View-Presenter architectural pattern."
msgstr ""
"``Tag ''플러그인은``TagItemGUI``가 Model-View-Presenter 아키텍처 패턴을 벗어나더라도 좋은 최소한의 "
"예입니다."

#: ../../building.rst:630
msgid "Plugins structure"
msgstr "플러그인 구조"

#: ../../building.rst:632
msgid ""
"Ghini is a framework for handling collections, and is distributed along "
"with a set of plugins making Ghini a botanical collection manager. But "
"Ghini stays a framework and you could in theory remove all plugins we "
"distribute and write your own, or write your own plugins that extend or "
"complete the current Ghini behaviour."
msgstr ""
"Ghini는 컬렉션을 처리하기위한 프레임 워크이며 Ghini를 식물 컬렉션 관리자로 만드는 플러그인 세트와 함께 배포됩니다. 그러나 "
"Ghini는 프레임 워크로 남아 있으며 이론적으로 우리가 배포하는 모든 플러그인을 제거하고 직접 작성하거나 현재 Ghini 동작을 "
"확장하거나 완료하는 자체 플러그인을 작성할 수 있습니다."

#: ../../building.rst:638
msgid ""
"Once you have selected and opened a database connection, you land in the "
"Search window. The Search window is an interaction between two objects: "
"SearchPresenter (SP) and SearchView (SV)."
msgstr ""
"데이터베이스 연결을 선택하고 열면 검색 창으로 이동합니다. 검색 창은 SearchPresenter (SP)와 SearchView (SV)"
"라는 두 개체 간의 상호 작용입니다."

#: ../../building.rst:642
msgid ""
"SV is what you see, SP holds the program status and handles the requests "
"you express through SV. Handling these requests affect the content of SV "
"and the program status in SP."
msgstr ""
"SV는 당신이 보는 것, SP는 프로그램 상태를 보유하고 SV를 통해 표현한 요청을 처리합니다. 이러한 요청을 처리하면 SV의 내용과 "
"SP의 프로그램 상태에 영향을줍니다."

#: ../../building.rst:646
msgid ""
"The search results shown in the largest part of SV are rows, objects that"
" are instances of classes registered in a plugin."
msgstr "SV의 가장 큰 부분에 표시되는 검색 결과는 플러그인에 등록 된 클래스의 인스턴스 인 행, 객체입니다."

#: ../../building.rst:649
msgid ""
"Each of these classes must implement an amount of functions in order to "
"properly behave within the Ghini framework. The Ghini framework reserves "
"space to pluggable classes."
msgstr ""
"이러한 각 클래스는 Ghini 프레임 워크 내에서 제대로 작동하기 위해 많은 기능을 구현해야합니다. Ghini 프레임 워크는 플러그 "
"가능한 클래스를위한 공간을 예약합니다."

#: ../../building.rst:653
msgid ""
"SP knows of all registered (plugged in) classes, they are stored in a "
"dictionary, associating a class to its plugin implementation.  SV has a "
"slot (a gtk.Box) where you can add elements. At any time, at most only "
"one element in the slot is visible."
msgstr ""
"SP는 등록 된 (플러그인 된) 모든 클래스를 알고 있으며 사전에 저장되어 클래스를 플러그인 구현에 연결합니다. SV에는 요소를 추가 할 "
"수있는 슬롯 (gtk.Box)이 있습니다. 언제든지 슬롯에서 최대 하나의 요소 만 표시됩니다."

#: ../../building.rst:658
msgid ""
"A plugin defines one or more plugin classes. A plugin class plays the "
"role of a partial presenter (pP - plugin presenter) as it implement the "
"callbacks needed by the associated partial view fitting in the slot (pV -"
" plugin view), and the MVP pattern is completed by the parent presenter "
"(SP), again acting as model. To summarize and complete:"
msgstr ""
"플러그인은 하나 이상의 플러그인 클래스를 정의합니다. 플러그인 클래스는 슬롯 (pV-플러그인보기)에 맞는 관련 부분보기에 필요한 콜백을 "
"구현하므로 부분 발표자 (pP-플러그인 발표자)의 역할을하며 MVP 패턴은 상위 발표자 (SP ), 다시 모델 역할을합니다. 요약하고 "
"완료하려면 :"

#: ../../building.rst:664
msgid "SP acts as model,"
msgstr "SP는 모델 역할을하며"

#: ../../building.rst:665
msgid "the pV partial view is defined in a glade file."
msgstr "pV 부분보기는 glade 파일에 정의되어 있습니다."

#: ../../building.rst:666
msgid "the callbacks implemented by pP are referenced by the glade file."
msgstr "pP에 의해 구현 된 콜백은 glade 파일에 의해 참조됩니다."

#: ../../building.rst:667
msgid "a context menu for the SP row,"
msgstr "SP 행에 대한 컨텍스트 메뉴"

#: ../../building.rst:668
msgid "a children property."
msgstr "어린이 재산."

#: ../../building.rst:670
msgid "when you register a plugin class, the SP:"
msgstr "플러그인 클래스를 등록하면 SP :"

#: ../../building.rst:672
msgid "adds the pV in the slot and makes it non-visible."
msgstr "슬롯에 pV를 추가하고 보이지 않게 만듭니다."

#: ../../building.rst:673
msgid "adds an instance of pP in the registered plugin classes."
msgstr "등록 된 플러그인 클래스에 pP 인스턴스를 추가합니다."

#: ../../building.rst:674
msgid "tells the pP that the SP is the model."
msgstr "SP가 모델임을 pP에 알립니다."

#: ../../building.rst:675
msgid "connects all callbacks from pV to pP."
msgstr "pV에서 pP로 모든 콜백을 연결합니다."

#: ../../building.rst:677
msgid ""
"when an element in pV triggers an action in pP, the pP can forward the "
"action to SP and can request SP that it updates the model and refreshes "
"the view."
msgstr ""
"pV의 요소가 pP에서 작업을 트리거하면 pP는 작업을 SP로 전달할 수 있으며 SP에 모델을 업데이트하고보기를 새로 고치도록 요청할 수 "
"있습니다."

#: ../../building.rst:681
msgid ""
"When the user selects a row in SP, SP hides everything in the pluggable "
"slot and shows only the single pV relative to the type of the selected "
"row, and asks the pP to refresh the pV with whatever is relative to the "
"selected row."
msgstr ""
"사용자가 SP에서 행을 선택하면 SP는 플러그 형 슬롯의 모든 항목을 숨기고 선택한 행의 유형과 관련된 단일 pV 만 표시하고 선택한 "
"행과 관련된 항목으로 pV를 새로 고치도록 pP에 요청합니다."

#: ../../building.rst:685
msgid ""
"Apart from setting the visibility of the various pV, nothing needs be "
"disabled nor removed: an invisible pV cannot trigger events!"
msgstr ""
"다양한 pV의 가시성을 설정하는 것 외에는 비활성화하거나 제거 할 필요가 없습니다. 보이지 않는 pV는 이벤트를 트리거 할 수 없습니다!"

#: ../../building.rst:689
msgid "bug solving workflow"
msgstr "버그 해결 워크 플로우"

#: ../../building.rst:692
msgid "normal development workflow"
msgstr "정상적인 개발 워크 플로우"

#: ../../building.rst:694
msgid ""
"while using the software, you notice a problem, or you get an idea of "
"something that could be better, you think about it good enough in order "
"to have a very clear idea of what it really is, that you noticed. you "
"open an issue and describe the problem. someone might react with hints."
msgstr ""
"소프트웨어를 사용하는 동안 문제를 발견하거나 더 나을 수있는 것에 대한 아이디어를 얻었을 때, 당신이 발견 한 것이 실제로 무엇인지에 "
"대한 매우 명확한 아이디어를 얻기 위해 충분히 좋은 생각을합니다. 문제를 열고 문제를 설명합니다. 누군가 힌트로 반응 할 수 있습니다."

#: ../../building.rst:698
msgid "you open the issues site and choose one you want to tackle."
msgstr "문제 사이트를 열고 해결하려는 사이트를 선택합니다."

#: ../../building.rst:699
msgid ""
"assign the issue to yourself, this way you are informing the world that "
"you have the intention to work at it. someone might react with hints."
msgstr "문제를 자신에게 할당하면 문제를 해결할 의사가 있음을 세상에 알릴 수 있습니다. 누군가 힌트로 반응 할 수 있습니다."

#: ../../building.rst:701
msgid ""
"optionally fork the repository in your account and preferably create a "
"branch, clearly associated to the issue."
msgstr "선택적으로 계정에서 저장소를 포크하고 문제와 명확하게 관련된 브랜치를 만드는 것이 좋습니다."

#: ../../building.rst:703
msgid ""
"write unit tests and commit them to your branch (please do not push "
"failing unit tests to github, run ``nosetests`` locally first)."
msgstr ""
"단위 테스트를 작성하고 브랜치에 커밋하십시오 (실패한 단위 테스트를 github에 푸시하지 말고 로컬에서 먼저``nosetests``를 "
"실행하십시오)."

#: ../../building.rst:705
msgid ""
"write more unit tests (ideally, the tests form the complete description "
"of the feature you are adding or correcting)."
msgstr "더 많은 단위 테스트를 작성합니다 (이상적으로는 테스트가 추가하거나 수정하는 기능에 대한 완전한 설명을 형성합니다)."

#: ../../building.rst:707
msgid ""
"make sure the feature you are adding or correcting is really completely "
"described by the unit tests you wrote."
msgstr "추가하거나 수정하는 기능이 작성한 단위 테스트에서 완전히 설명되었는지 확인하십시오."

#: ../../building.rst:709
msgid ""
"make sure your unit tests are atomic, that is, that you test variations "
"on changes along one single variable. do not give complex input to unit "
"tests or tests that do not fit on one screen (25 lines of code)."
msgstr ""
"단위 테스트가 원자 적이어야합니다. 즉, 하나의 단일 변수를 따라 변경 사항에 대한 변형을 테스트해야합니다. 한 화면 (코드 25 줄)에 "
"맞지 않는 단위 테스트 또는 테스트에 복잡한 입력을 제공하지 마십시오."

#: ../../building.rst:712
msgid "write the code that makes your tests succeed."
msgstr "테스트를 성공시키는 코드를 작성하십시오."

#: ../../building.rst:713
msgid "update the i18n files (run ``./scripts/i18n.sh``)."
msgstr "i18n 파일을 업데이트합니다 (``. / scripts / i18n.sh`` 실행)."

#: ../../building.rst:714
msgid ""
"whenever possible, translate the new strings you put in code or glade "
"files."
msgstr "가능하면 코드 또는 glade 파일에 넣은 새 문자열을 번역하십시오."

#: ../../building.rst:716
msgid ""
"when you change strings, please make sure that old translations get re-"
"used."
msgstr "문자열을 변경할 때 이전 번역이 다시 사용되는지 확인하십시오."

#: ../../building.rst:717
msgid "commit your changes."
msgstr "변경 사항을 커밋하십시오."

#: ../../building.rst:718
msgid "push to github."
msgstr "github로 푸시하십시오."

#: ../../building.rst:719
msgid "open a pull request."
msgstr "풀 리퀘스트를 엽니다."

#: ../../building.rst:722
msgid "publishing to production"
msgstr "프로덕션에 게시"

#: ../../building.rst:724
msgid ""
"please use the ``publish.sh`` script, in the ``scritps`` directory.  This"
" one takes care of every single step, and produces recognizable commit "
"comments, it publishes the release on pypi, and in perspective it will "
"contain all steps for producing a ``deb`` file, and a windows executable."
msgstr ""
"``scritps ''디렉토리에있는``publish.sh ''스크립트를 사용하십시오. 이것은 모든 단일 단계를 처리하고 인식 가능한 커밋 "
"주석을 생성하고 pypi에 릴리스를 게시하며 관점에서``deb ''파일 및 Windows 실행 파일을 생성하는 모든 단계를 포함합니다."

#: ../../building.rst:729
msgid "you can also do this by hand:"
msgstr "이 작업을 직접 수행 할 수도 있습니다.:"

#: ../../building.rst:731
msgid ""
"open the pull request page using as base a production line ``ghini-x.y``,"
" compared to ``ghini-x.y-dev``."
msgstr "``ghini-x.y-dev ''와 비교하여``ghini-x.y ''생산 라인을 기본으로 사용하여 풀 요청 페이지를 엽니 다."

#: ../../building.rst:733
msgid "make sure a ``bump`` commit is included in the differences."
msgstr "차이점에``범프 ''커밋이 포함되어 있는지 확인하십시오."

#: ../../building.rst:734
msgid "it should be possible to automatically merge the branches."
msgstr "분기를 자동으로 병합 할 수 있어야합니다."

#: ../../building.rst:735
msgid "create the new pull request, call it as “publish to the production line”."
msgstr "새로운 풀 리퀘스트를 생성하고이를 \"생산 라인에 게시\"라고합니다."

#: ../../building.rst:736
msgid "you possibly need wait for travis-ci to perform the checks."
msgstr "travis-ci가 검사를 수행 할 때까지 기다려야 할 수도 있습니다."

#: ../../building.rst:737
msgid "merge the changes."
msgstr "변경 사항을 병합하십시오."

#: ../../building.rst:739
msgid ""
"don't forget to tell the world about the new release: on `facebook "
"<https://www.facebook.com/bauble.thesoftware/>`_, the `google group "
"<https://groups.google.com/forum/#!forum/bauble>`_, in any relevant "
"linkedin group, and on `our web page <http://ghini.github.io/>`_."
msgstr ""
"새로운 릴리스에 대해 전 세계에 알리는 것을 잊지 마십시오.`facebook <https://www.facebook.com/bauble."
"thesoftware/>`_,`google 그룹 <https://groups.google.com/ forum / #! forum / "
"bauble>`_, 관련 링크드 인 그룹 및`우리 웹 페이지 <http://ghini.github.io/>`_."

#: ../../building.rst:745
msgid "your own fork"
msgstr "자신의 포크"

#: ../../building.rst:747
msgid ""
"If you want to keep your own fork of the project, keep in mind this is "
"full force work in progress, so staying up to date will require some "
"effort from your side."
msgstr "자신의 프로젝트 포크를 유지하고 싶다면 이것이 진행중인 작업이므로 최신 정보를 유지하려면 약간의 노력이 필요합니다."

#: ../../building.rst:751
msgid ""
"The best way to keep your own fork is to focus on some specific issue, "
"work relatively quickly, often open pull requests for your work, make "
"sure that you get it accepted.  Just follow Ghini's coding style, write "
"unit tests, concise and abundant, and there should be no problem in "
"having your work included in Ghini's upstream."
msgstr ""
"자신의 포크를 유지하는 가장 좋은 방법은 특정 문제에 집중하고, 비교적 빠르게 작업하고, 종종 작업에 대한 풀 요청을 열고, 수락했는지 "
"확인하는 것입니다. Ghini의 코딩 스타일을 따르고 단위 테스트를 작성하고 간결하고 풍부하며 Ghini의 업스트림에 작업을 포함시키는 "
"데 문제가 없을 것입니다."

#: ../../building.rst:757
msgid ""
"If your fork got out of sync with Ghini's upstream: read, understand, "
"follow the github guides `configuring a remote for a fork "
"<https://help.github.com/articles/configuring-a-remote-for-a-fork/>`_ and"
" `syncing a fork <https://help.github.com/articles/syncing-a-fork/>`_."
msgstr ""
"포크가 Ghini의 업스트림과 동기화되지 않은 경우 : 읽고 이해하고 github 가이드`포크 용 원격 구성 <https://help."
"github.com/articles/configuring-a-remote-for-a-fork />`_ 및`포크 동기화 "
"<https://help.github.com/articles/syncing-a-fork/>`_."

#: ../../building.rst:763
msgid "closing step"
msgstr "마감 단계"

#: ../../building.rst:765
msgid ""
"review this workflow. consider this as a guideline, to yourself and to "
"your colleagues. please help make it better and matching the practice."
msgstr "이 워크 플로우를 검토하십시오. 이것을 자신과 동료에게 지침으로 고려하십시오. 더 좋게 만들고 연습과 일치하도록 도와주세요."

#: ../../building.rst:770
msgid "Distributing ghini.desktop"
msgstr "ghini.desktop 배포"

#: ../../building.rst:773
msgid "Python Package Index - PyPI"
msgstr "Python 패키지 색인-PyPI"

#: ../../building.rst:775
msgid ""
"This is not much mentioned, but we keep ghini.desktop on the Python "
"Package Index, so you could install it by no more than::"
msgstr ""
"별로 언급되지는 않았지만 Python 패키지 색인에 ghini.desktop을 보관하므로 다음과 같은 방법으로 설치할 수 있습니다::"

#: ../../building.rst:780
msgid ""
"There are a couple packages that can't be installed with ``pip``, but "
"otherwise that's really all you need to type, and it's platform "
"independent."
msgstr "``pip ''로 설치할 수없는 몇 가지 패키지가 있지만 그렇지 않으면 입력해야 할 모든 것이 있으며 플랫폼에 독립적입니다."

#: ../../building.rst:783
msgid "Publishing on PyPI is a standard ``setup`` command::"
msgstr "PyPI에 게시하는 것은 표준``setup ''명령입니다:"

#: ../../building.rst:789
msgid "Windows"
msgstr "윈도우"

#: ../../building.rst:791
msgid ""
"For building a Windows installer or executable you need a running Windows"
" system.  The methods described here has been used successfully on "
"Windows 7, 8 and 10.  Windows Vista should also work but has not been "
"tested."
msgstr ""
"Windows 설치 프로그램 또는 실행 파일을 빌드하려면 실행중인 Windows 시스템이 필요합니다. 여기에 설명 된 방법은 "
"Windows 7, 8 및 10에서 성공적으로 사용되었습니다. Windows Vista도 작동해야하지만 테스트를 거치지는 않았습니다."

#: ../../building.rst:795
msgid ""
"If you are on GNU/Linux, or on OSX, you are not interested in the "
"remainder of this section.  None of Ghini's contributors knows how to "
"produce a Windows installer without having a Windows system."
msgstr ""
"GNU / Linux 또는 OSX를 사용하는 경우이 섹션의 나머지 부분에 관심이 없습니다. Ghini의 기여자 중 누구도 Windows "
"시스템없이 Windows 설치 프로그램을 만드는 방법을 모릅니다."

#: ../../building.rst:799
msgid ""
"The goal of the present instructions is to help you produce a Windows "
"installer, that is a single executable that you can run on any Windows "
"workstation and that will install a specific version of ghini.desktop.  "
"This is achieved with the NSIS script-driven installer authoring tool."
msgstr ""
"현재 지침의 목표는 모든 Windows 워크 스테이션에서 실행할 수 있고 특정 버전의 ghini.desktop을 설치하는 단일 실행 파일 "
"인 Windows 설치 프로그램을 생성하는 데 도움을주는 것입니다. 이는 NSIS 스크립트 기반 설치 프로그램 저작 도구를 통해 "
"이루어집니다."

#: ../../building.rst:804
msgid ""
"As a side product of the installer production, you will have a massive "
"but relocatable directory, which you can copy to a USB drive and which "
"will let you use the software without needing an installation."
msgstr ""
"설치 프로그램 프로덕션의 부수적 인 제품으로, USB 드라이브에 복사 할 수 있고 설치할 필요없이 소프트웨어를 사용할 수있는 대규모이지만 "
"재배치 가능한 디렉토리가 있습니다."

#: ../../building.rst:808
msgid "The files and directories relevant to this section:"
msgstr "이 섹션과 관련된 파일 및 디렉토리 :"

#: ../../building.rst:810
msgid "``scripts/build-win.bat`` — the single batch script to run."
msgstr "``scripts / build-win.bat`` — 실행할 단일 배치 스크립트입니다."

#: ../../building.rst:811
msgid "``setup.py`` — implements the NSIS and py2exe commands."
msgstr "``setup.py ''— NSIS 및 py2exe 명령을 구현합니다."

#: ../../building.rst:812
msgid "``scripts/build-multiuser.nsi`` — the nsis script, used by the above."
msgstr "``scripts / build-multiuser.nsi ''— 위에서 사용 된 nsis 스크립트."

#: ../../building.rst:813
msgid "``nsis/`` — contains redistributable NSIS files, put here for conveniency."
msgstr "``nsis /``— 재배포 가능한 NSIS 파일을 포함하며 편의를 위해 여기에 넣습니다."

#: ../../building.rst:814
msgid "``ghini-runtime/`` — built by ``py2exe``, used by ``nsis``."
msgstr "``ghini-runtime /``—``py2exe``에 의해 빌드되고``nsis``에 사용됩니다."

#: ../../building.rst:815
msgid "``dist/`` — receives the executable installation file."
msgstr "``dist /``— 실행 가능한 설치 파일을받습니다."

#: ../../building.rst:817
msgid ""
"Most steps are automated in the ``build-win.bat`` script.  Installation "
"of a few tools needs to be done manually:"
msgstr "대부분의 단계는``build-win.bat`` 스크립트에서 자동화됩니다. 몇 가지 도구를 수동으로 설치해야합니다:"

#: ../../building.rst:820
msgid "Download and install Git, Python 2.7 and PyGTK."
msgstr "Git, Python 2.7 및 PyGTK를 다운로드하여 설치합니다."

#: ../../building.rst:822
msgid ""
"This is outlined in the ``devinstall``-based :ref:`installation` "
"instructions."
msgstr "이것은``devinstall ''기반 : ref :`installation` 지침에 설명되어 있습니다."

#: ../../building.rst:825
msgid "Download and install `NSIS v3 <http://nsis.sourceforge.net/Download>`_."
msgstr "`NSIS v3 <http://nsis.sourceforge.net/Download>`_를 다운로드하여 설치합니다."

#: ../../building.rst:827
msgid "A **reboot** is recommended."
msgstr "** 재부팅 **이 권장됩니다."

#: ../../building.rst:829
msgid "Clone the ghini.desktop repository."
msgstr "ghini.desktop 저장소를 복제합니다."

#: ../../building.rst:831
msgid ""
"Use your own fork if you plan contributing patches, or the organization's"
" repository ``https://github.com/Ghini/ghini.desktop.git`` if you only "
"wish to follow development."
msgstr ""
"패치를 제공 할 계획이라면 자체 포크를 사용하고 개발 만 따르고 싶다면 조직의 저장소``https : // github.com / "
"Ghini / ghini.desktop.git``을 사용하십시오."

#: ../../building.rst:835
msgid ""
"Clone the repository from GitHub to wherever you want to keep it, and "
"checkout a branch.  Replace ``<path-to-keep-ghini>`` with the path of "
"your choice, e.g. ``Local\\github\\Ghini\\``. Production branch "
"``ghini-1.0`` is recommended as used in the example."
msgstr ""
"GitHub에서 보관하려는 위치로 저장소를 복제하고 브랜치를 체크 아웃합니다. ``<path-to-keep-ghini>``를 선택한 "
"경로로 바꾸십시오. ``로컬 \\ github \\ Ghini \\``. 예제에 사용 된대로 프로덕션 브랜치``ghini-1.0 ''을 "
"권장합니다."

#: ../../building.rst:840
msgid "To do this, open a command prompt and type these commands::"
msgstr "이렇게하려면 명령 프롬프트를 열고 다음 명령을 입력하십시오:"

#: ../../building.rst:847
msgid ""
"The result of the above is a complete development environment, on "
"Windows, with NSIS.  Use it to follow development, or to propose your "
"pull requests, and to build Windows installers."
msgstr ""
"위의 결과는 Windows에서 NSIS를 사용하는 완전한 개발 환경입니다. 이를 사용하여 개발을 따르거나 풀 요청을 제안하고 "
"Windows 설치 프로그램을 빌드하십시오."

#: ../../building.rst:851
msgid ""
"All subsequent steps are automated in the ``scripts\\build_win.bat`` "
"script.  Run it, and after a couple of minutes you should have a new "
"``dist\\ghini.desktop-<version>-setup.exe`` file, and a working, complete"
" relocatable directory named ``ghini-runtime``."
msgstr ""
"모든 후속 단계는``scripts \\ build_win.bat`` 스크립트에서 자동화됩니다. 그것을 실행하고 몇 분 후에 새로운``"
"dist \\ ghini.desktop- <version> -setup.exe`` 파일과``ghini-runtime``이라는 이름의 "
"작동하고 완전한 재배치 가능한 디렉토리가 있어야합니다."

#: ../../building.rst:856
msgid "Read the rest if you need details about the way the script works."
msgstr "스크립트 작동 방식에 대한 세부 정보가 필요하면 나머지를 읽으십시오."

#: ../../building.rst:858
msgid "The ``build_win.bat`` script"
msgstr "``build_win.bat`` 스크립트"

#: ../../building.rst:861
msgid ""
"A batch file is available that can complete the last few steps.  To use "
"it use this command::"
msgstr "마지막 몇 단계를 완료 할 수있는 배치 파일을 사용할 수 있습니다. 이를 사용하려면 다음 명령을 사용하십시오::"

#: ../../building.rst:866
msgid "``build_win.bat`` accepts 2 arguments:"
msgstr "``build_win.bat``는 2 개의 인수를받습니다:"

#: ../../building.rst:868
msgid "``/e`` — executable only."
msgstr "``/ e ''— 실행 만 가능합니다."

#: ../../building.rst:870
msgid ""
"Produce an executable only, skipping the extra step of building an "
"installer, and will copy ``win_gtk.bat`` into place."
msgstr "설치 프로그램 빌드의 추가 단계를 건너 뛰고 실행 파일 만 생성하고``win_gtk.bat``를 제자리에 복사합니다."

#: ../../building.rst:873
msgid "``venv_path`` — A path to the location for the virtual environment to use."
msgstr "''venv_path'' - 가상 환경에서 사용할 위치에 대한 경로입니다."

#: ../../building.rst:875
#, python-format
msgid ""
"Defaults to ``\"%HOMEDRIVE%%HOMEPATH%\"\\.virtualenvs\\%CHECKOUT%-exe``, "
"where ``CHECKOUT`` corresponds to the name of the branch you checked out."
msgstr ""
"기본값은`` \"% HOMEDRIVE %% HOMEPATH %\"\\. virtualenvs \\ % CHECKOUT % -exe``"
"이며, 여기서``CHECKOUT``은 체크 아웃 한 브랜치의 이름에 해당합니다."

#: ../../building.rst:879
msgid ""
"If you want to produce an executable only and use a virtual environment "
"in a folder beside where you have ghini.desktop, you could execute "
"``scripts\\build_win.bat /e ..\\ghi2exe``"
msgstr ""
"실행 파일 만 생성하고 ghini.desktop이있는 폴더 옆에있는 가상 환경을 사용하려면``scripts \\ build_win.bat "
"/ e .. \\ ghi2exe``를 실행할 수 있습니다"

#: ../../building.rst:884
msgid "py2exe will not work with eggs"
msgstr "py2exe는 계란과 함께 작동하지 않습니다"

#: ../../building.rst:887
msgid ""
"Building a Windows executable with py2exe requires packages **not** be "
"installed as eggs.  There are several methods to accomplish this, "
"including:"
msgstr ""
"py2exe로 Windows 실행 파일을 빌드하려면 달걀로 설치되지 ** 않는 ** 패키지가 필요합니다. 이를 수행하는 방법은 다음과 "
"같습니다:"

#: ../../building.rst:890
msgid ""
"Install using ``pip``.  The easiest method is to install into a virtual "
"environment that doesn't currently have any modules installed as eggs "
"using ``pip install .`` as described below.  If you do wish to install "
"over the top of an install with eggs (e.g. the environment created by "
"``devinstall.bat``) you can try ``pip install -I .`` but your mileage may"
" vary."
msgstr ""
"``pip ''를 사용하여 설치합니다. 가장 쉬운 방법은 아래에 설명 된대로``pip install .``을 사용하여 현재 계란으로 "
"설치된 모듈이없는 가상 환경에 설치하는 것입니다. 달걀을 사용하여 설치 위에 설치하려면 (예 :``devinstall.bat ''로 만든 "
"환경)``pip install -I .``를 시도 할 수 있지만 마일리지는 다를 수 있습니다."

#: ../../building.rst:897
msgid "By adding::"
msgstr "추가하여::"

#: ../../building.rst:902
msgid ""
"to setup.cfg (or similarly ``zip_safe = False`` to ``setuptools.setup()``"
" in ``setup.py``) you can use ``python setup.py install`` but you will "
"need to download and install `Microsoft Visual C++ Compiler for Python "
"2.7 <http://aka.ms/vcpython27>`_ to get any of the C extensions and will "
"need a fresh virtual environment with no dependent packages installed as "
"eggs."
msgstr ""
"setup.cfg (또는 유사하게``zip_safe = False``에서``setup.py ''의``setuptools.setup "
"()``으로)``python setup.py install``을 사용할 수 있지만 다음이 필요합니다. C 확장을 얻으려면`"
"Microsoft Visual C ++ Compiler for Python 2.7 <http://aka.ms/vcpython27>`_을 "
"다운로드하여 설치하고, 종속 패키지가 달걀로 설치되지 않은 새로운 가상 환경이 필요합니다."

#: ../../building.rst:908
msgid "The included ``build-win`` script uses the ``pip`` method."
msgstr "포함 된``build-win ''스크립트는``pip ''메소드를 사용합니다."

#: ../../building.rst:910
msgid "installing virtualenv and working with environments"
msgstr "virtualenv 설치 및 환경 작업"

#: ../../building.rst:913
msgid "Install virtualenv, create a virtual environment and activate it."
msgstr "virtualenv를 설치하고 가상 환경을 만들고 활성화합니다."

#: ../../building.rst:915
msgid ""
"With only Python 2.7 on your system (where ``<path-to-venv>`` is the path"
" to where you wish to keep the virtual environment) use::"
msgstr ""
"시스템에 Python 2.7 만있는 경우 (여기서``<path-to-venv>``는 가상 환경을 유지하려는 경로입니다) 다음을 "
"사용하십시오::"

#: ../../building.rst:922
msgid ""
"On systems where Python 3 is also installed you may need to either call "
"pip and virtualenv with absolute paths, e.g. "
"``C:\\Python27\\Scripts\\pip`` or use the Python launcher e.g. ``py -2.7 "
"-m pip`` (run ``python --version`` first to check.  If you get anything "
"other than version 2.7 you'll need to use one of these methods.)"
msgstr ""
"Python 3도 설치된 시스템에서는 절대 경로로 pip 및 virtualenv를 호출해야 할 수 있습니다. ``C : \\ "
"Python27 \\ Scripts \\ pip ''또는 Python 런처 (예 : ``py -2.7 -m pip ''(먼저``"
"python --version``을 실행하여 확인하십시오. 버전 2.7이 아닌 다른 것이 있으면이 방법 중 하나를 사용해야합니다.)"

#: ../../building.rst:928
msgid "Populate the virtual environment"
msgstr "가상 환경 채우기"

#: ../../building.rst:931
msgid "Install dependencies and ghini.desktop into the virtual environment::"
msgstr "가상 환경에 종속성 및 ghini.desktop을 설치합니다::"

#: ../../building.rst:936
msgid "Compile for Windows"
msgstr "Windows 용 컴파일"

#: ../../building.rst:939
msgid "Build the executable::"
msgstr "실행 파일 빌드 ::"

#: ../../building.rst:943
msgid ""
"The ``ghini-runtime`` folder will now contain a full working copy of the "
"software in a frozen, self contained state."
msgstr "이제``ghini-runtime ''폴더에는 고정 된 자체 포함 상태의 소프트웨어의 전체 작업 복사본이 포함됩니다."

#: ../../building.rst:946
msgid "This folder is what is packaged by NSIS."
msgstr "이 폴더는 NSIS에서 패키징 한 것입니다."

#: ../../building.rst:948
msgid ""
"This same folder can also be transferred however you like and will work "
"in place.  (e.g. placed on a USB flash drive for demonstration purposes "
"or copied manually to ``C:\\Program Files`` with a shortcut created on "
"the desktop).  To start ghini.desktop double click ``ghini.exe`` in "
"explorer (or create a shortcut to it)."
msgstr ""
"이 동일한 폴더도 원하는대로 전송할 수 있으며 제자리에서 작동합니다. (예 : 데모 목적으로 USB 플래시 드라이브에 배치하거나 바탕 "
"화면에 생성 된 바로 가기를 사용하여``C : \\ Program Files``에 수동으로 복사). ghini.desktop을 시작하려면 "
"탐색기에서``ghini.exe``를 두 번 클릭하거나 바로 가기를 만듭니다."

#: ../../building.rst:955
msgid "Fixing paths to GTK components."
msgstr "GTK 구성 요소에 대한 경로 수정."

#: ../../building.rst:958
msgid ""
"If you run the relocatable compiled program, unpackaged, you might "
"occasionally have trouble with the GUI not displaying correctly."
msgstr "재배치 가능한 컴파일 된 프로그램 (패키지 해제)을 실행하면 GUI가 올바르게 표시되지 않는 문제가 발생할 수 있습니다."

#: ../../building.rst:961
msgid ""
"Should this happen, you need to set up paths to the GTK components "
"correctly.  You can do this by running the ``win_gtk.bat``, from the "
"``ghini-runtime`` folder."
msgstr ""
"이 경우 GTK 구성 요소에 대한 경로를 올바르게 설정해야합니다. ``ghini-runtime ''폴더에서``win_gtk.bat``를 "
"실행하면됩니다."

#: ../../building.rst:965
msgid ""
"You will only need to run this once each time the location of the folder "
"changes.  Thereafter ``ghini.exe`` will run as expected."
msgstr "폴더 위치가 변경 될 때마다 한 번만 실행하면됩니다. 그 후``ghini.exe``가 예상대로 실행됩니다."

#: ../../building.rst:969
msgid "Finally, invoke NSIS"
msgstr "마지막으로 NSIS를 호출합니다"

#: ../../building.rst:972
msgid "Build the installer::"
msgstr "설치 프로그램 빌드 ::"

#: ../../building.rst:976
msgid ""
"This should leave a file named ``ghini.desktop-<version>-setup.exe`` in "
"the ``dist`` folder.  This is your Windows installer."
msgstr ""
"그러면``dist ''폴더에``ghini.desktop- <version> -setup.exe``라는 파일이 남습니다. 이것은 "
"Windows 설치 프로그램입니다."

#: ../../building.rst:979
msgid "about the installer"
msgstr "설치 프로그램에 대해"

#: ../../building.rst:982
msgid "Capable of single user or global installs."
msgstr "단일 사용자 또는 글로벌 설치가 가능합니다."

#: ../../building.rst:984
msgid ""
"At this point in time ghini.desktop installed this way will not check or "
"or notify you of any updated version.  You will need to check yourself."
msgstr "이 시점에서 이렇게 설치된 ghini.desktop은 업데이트 된 버전을 확인하거나 알리지 않습니다. 자신을 확인해야합니다."

#: ../../building.rst:988
msgid "Capable of downloading and installing optional extra components:"
msgstr "선택적 추가 구성 요소를 다운로드하고 설치할 수 있습니다:"

#: ../../building.rst:990
msgid ""
"Apache FOP - If you want to use xslt report templates install FOP. FOP "
"requires Java Runtime. If you do not currently have it installed the "
"installer will let you know and offer to open the Oracle web site for you"
" to download and install it from."
msgstr ""
"Apache FOP-xslt 보고서 템플릿을 사용하려면 FOP를 설치하십시오. FOP에는 Java 런타임이 필요합니다. 현재 설치되어 "
"있지 않은 경우 설치 프로그램이이를 알려주고 Oracle 웹 사이트를 열어 다운로드하여 설치할 수 있도록 제안합니다."

#: ../../building.rst:995
msgid ""
"MS Visual C runtime - You most likely don't need this but if you have any"
" trouble getting ghini.desktop to run try installing the MS Visual C "
"runtime (e.g. rerun the installer and select this component only)."
msgstr ""
"MS Visual C 런타임 - 이 기능이 필요하지 않을 수 있지만 MS Visual C 런타임(예: 설치 프로그램을 다시 실행하고 이 "
"구성 요소만 선택)을 실행하는 데 문제가 있는 경우 설치를 시도하십시오."

#: ../../building.rst:1000
msgid ""
"Can be run silently from the commandline (e.g. for remote deployment) "
"with the following arguments:"
msgstr "다음 인수를 사용하여 명령줄(예: 원격 배포용)에서 자동으로 실행할 수 있습니다:"

#: ../../building.rst:1003
msgid "``/S`` for silent;"
msgstr "침묵을 위한 ''/S'';"

#: ../../building.rst:1005
msgid "``/AllUser`` (when run as administrator) or ``/CurrentUser``"
msgstr "\"/AllUser\"(관리자로 실행될 경우) 또는 \"/현재 사용자\""

#: ../../building.rst:1007
msgid "``/C=[gFC]`` to specify components where:"
msgstr "\"/C=[gFC]\"로 구성 요소를 지정합니다:"

#: ../../building.rst:1009
msgid ""
"``g`` = Deselect the main ghini.desktop component (useful for adding "
"optional component after an initial install)"
msgstr "''g² = main ghini.component 선택 취소(초기 설치 후 선택적 구성 요소를 추가하기 위한 선택 사항)"

#: ../../building.rst:1012
msgid "``F`` = select Apache FOP"
msgstr "\"F\" = Apache FOP 선택"

#: ../../building.rst:1014
msgid "``C`` = select MS Visual C runtime"
msgstr "''C'' = MS Visual C 런타임 선택"

#: ../../building.rst:1017
msgid "Debian"
msgstr "기변"

#: ../../building.rst:1019
msgid ""
"Between 2009 and 2010 someone packaged the then already obsolete Bauble "
"0.9.7 for Debian, and the package was included in Ubuntu.  That version "
"is `still being distributed "
"<https://packages.ubuntu.com/xenial/bauble>`_, regardless being it "
"impossible to install."
msgstr ""
"2009년과 2010년 사이에 누군가가 당시 이미 쓸모없었던 바우블 0.9.7을 데비안을 위해 포장했고, 이 패키지는 우분투에 "
"포함되었다. 이 버전은 설치가 불가능하더라도 https://packages.ubuntu.com/xenial/bauble으로 배포되고 있다."
"\n"
"높임말."

#: ../../building.rst:1025
msgid ""
"Only recently has Mario Frasca produced a new bauble debian package, for "
"the latest bauble.classic version 1.0.56, and proposed for inclusion in "
"Debian. View it on `mentors "
"<https://mentors.debian.net/package/bauble>`_.  This version depends on "
"``fibra``, a package that was never added to Debian and which Mario also "
"has packaged and `proposed for inclusion in Debian "
"<https://mentors.debian.net/package/fibra>`_.  Mario has been trying to "
"activate some Debian Developer, to take action.  There's not much more we"
" can do, other than wait for a sponsor, and hoping the package will "
"eventually get all the way to Ubuntu."
msgstr ""
"최근에야 마리오 프라스카는 최신 버전인 바우블.클래식 버전 1.0.56을 위한 새로운 바우블 데비안 패키지를 제작하고 데비안에 "
"포함시키자고 제안했다. https://mentors.debian.net/package/bauble'에서 확인하십시오. 이 버전은 "
"''데비안에 추가되지 않은 패키지이며 마리오도 패키지화한 패키지이며 데비안 https://mentors.debian.net/package/"
"fibra에 포함시킬 수 있는 패키지''에 달려 있다. 마리오가 행동을 취하기 위해 데비안 개발자(Debian Developer)를 "
"활성화시키려고 노력해왔습니다. 후원자를 기다리는 것 말고는 할 수 있는 게 없어요 결국 우분투까지 소포가 도착하길 바라죠."

#: ../../building.rst:1035
msgid ""
"Once we get in contact with a `Debian Sponsor "
"<https://mentors.debian.net/sponsors>`_ who will review what we publish "
"on `mentors <https://mentors.debian.net/intro-maintainers>`_, then we "
"will be definitely expected to keep updating the debian package for "
"``ghini.desktop`` and ``fibra``."
msgstr ""
"일단 우리가 'https://mentors.debian.net/intro-maintainers'에 게재하는 내용을 검토할 데비안 스폰서 "
"https://mentors.debian.net/sponsors'과 접촉하게 되면 우리는 데비안 패키지의 ``ghini.devious\"와"
" \"ghbrazy\"를 계속 업데이트할 것이 확실하다."

#: ../../building.rst:1040
msgid ""
"I am not going to explain in a few words the content of several books on "
"Debian packaging.  Please choose your sources.  For a very compact idea "
"of what you're expected to do, have a look at ``scripts/pubish.sh``."
msgstr ""
"나는 데비안 포장지에 관한 몇 권의 책의 내용을 몇 마디로 설명하지 않을 것이다. 소스를 선택하십시오. 여러분이 무엇을 할 것으로 "
"예상되는지에 대한 아주 간단한 아이디어를 위해, \"https/pubish.sh\"을 보세요."

#: ../../editing.rst:4
msgid "Editing and Inserting Data"
msgstr "데이터 편집 및 삽입"

#: ../../editing.rst:6
msgid ""
"The main way that we add or change information in Ghini is by using the "
"editors.  Each basic type of data has its own editor.  For example there "
"is a Family editor, a Genus editor, an Accession editor, etc."
msgstr ""
"Ghini에서 정보를 추가하거나 변경하는 주요 방법은 편집기를 사용하는 것입니다.  각 기본 데이터 유형에는 고유한 편집기가 있습니다.  "
"예를 들어 패밀리 편집기, 인세이션 편집기, 등록 편집기 등이 있습니다."

#: ../../editing.rst:10
msgid ""
"To create a new record click on the :menuselection:`Insert` menu on the "
"menubar and then select the type of record your would like to create.  "
"This opens a new blank editor for the type."
msgstr ""
"새 레코드를 생성하려면 :menu selection(메뉴 선택)을 클릭하십시오.메뉴 모음에서 '삽입' 메뉴를 선택한 다음 만들려는 레코드 "
"유형을 선택합니다.  유형에 대한 새 빈 편집기가 열립니다."

#: ../../editing.rst:14
msgid ""
"To edit an existing record in the database right click on an item in the "
"search results and select :menuselection:`Edit` from the popup menu.  "
"This opens an editor that allows you to change the values on the record "
"that you selected."
msgstr ""
"데이터베이스에서 기존 레코드를 편집하려면 검색 결과의 항목을 마우스 오른쪽 버튼으로 클릭하고 다음을 선택합니다. 메뉴 선택:팝업 메뉴에서 "
"'편집'을 선택합니다.  이렇게 하면 선택한 레코드의 값을 변경할 수 있는 편집기가 열립니다."

#: ../../editing.rst:19
msgid ""
"Most types also have children which you can add by right clicking on the "
"parent and selecting \"Add ???...\" on the context menu.  For example, a "
"Family has Genus children: you can add a Genus to a Family by right "
"clicking on a Family and selecting \"Add genus\"."
msgstr ""
"또한 대부분의 유형에는 상위 항목을 마우스 오른쪽 버튼으로 클릭하고 상황에 맞는 메뉴에서 \"추가 ????...\"를 선택하여 추가할 수 "
"있는 하위 항목이 있습니다.  예를 들어 패밀리에 속자식이 있습니다. 패밀리를 마우스 오른쪽 단추로 클릭하고 \"속자 추가\"를 선택하여 "
"패밀리에 속자를 추가할 수 있습니다."

#: ../../editing.rst:26
msgid "Notes"
msgstr "주기"

#: ../../editing.rst:27
msgid ""
"Almost all of the editors in Ghini have a *Notes* tab which should work "
"the same regardless of which editor you are using."
msgstr "Ghini의 거의 모든 편집기에는 *Notes* 탭이 있습니다. 이 탭은 사용 중인 편집기에 관계없이 동일하게 작동합니다."

#: ../../editing.rst:30
msgid ""
"If you enter a web address in a note then the link shows up in the Links "
"box when the item your are editing is selected in the search results."
msgstr "노트에 웹 주소를 입력하면 편집 중인 항목이 검색 결과에서 선택되면 링크 상자에 링크가 표시됩니다."

#: ../../editing.rst:33
msgid ""
"You can browse the notes for an item in the database using the Notes box "
"at the bottom of the screen.  The Notes box is desensitized if the "
"selected item does not have any notes."
msgstr ""
"화면 아래쪽에 있는 Notes 상자를 사용하여 데이터베이스에서 항목의 노트를 찾아볼 수 있습니다.  선택한 항목에 노트가 없으면 "
"Notes 상자의 감도가 떨어집니다."

#: ../../editing.rst:39
msgid "Family"
msgstr "과명"

#: ../../editing.rst:40
msgid "The Family editor allows you to add or change a botanical family."
msgstr "패밀리 편집기를 사용하면 식물군을 추가하거나 변경할 수 있습니다."

#: ../../editing.rst:42
msgid ""
"The *Family* field on the editor lets you change the epithet of the "
"family. The Family field is required."
msgstr "편집기의 *가족* 필드를 사용하여 패밀리의 별칭을 변경할 수 있습니다. 패밀리 필드는 필수입니다."

#: ../../editing.rst:45
msgid ""
"The *Qualifier* field lets you change the family qualifier.  The value "
"can either be *sensu lato*, *sensu stricto*, or nothing."
msgstr ""
"*Qualifier* 필드를 사용하여 패밀리 한정자를 변경할 수 있습니다.  값은 *sensulato*, *sensurto* 또는 "
"nothing일 수 있습니다."

#: ../../editing.rst:48
msgid ""
"*Synonyms* allow you to add other families that are synonyms with the "
"family you are currently editing.  To add a new synonyms type in a family"
" name in the entry.  You must select a family name from the list of "
"completions. Once you have selected a family name that you want to add as"
" a synonym click on the Add button next to the synonym list and the "
"software adds the selected synonym to the list.  To remove a synonym, "
"select the synonym from the list and click on the Remove button."
msgstr ""
"*동기화*를 사용하면 현재 편집 중인 가족과 동의어인 다른 패밀리를 추가할 수 있습니다.  항목의 패밀리 이름에 새 동의어를 추가하려면 "
"다음과 같이 하십시오.  완료 목록에서 패밀리 이름을 선택해야 합니다. 동의어로 추가할 패밀리 이름을 선택한 후 동의어 목록 옆에 있는 "
"추가 단추를 클릭하면 소프트웨어가 선택한 동의어를 목록에 추가합니다.  동의어를 제거하려면 목록에서 동의어를 선택하고 [제거] 단추를 "
"클릭하십시오."

#: ../../editing.rst:56 ../../editing.rst:91 ../../editing.rst:115
msgid "To cancel your changes without saving then click on the *Cancel* button."
msgstr "저장하지 않고 변경 내용을 취소하려면 *취소* 버튼을 클릭하십시오."

#: ../../editing.rst:58
msgid "To save the family you are working on then click *OK*."
msgstr "작업 중인 가족을 저장하려면 *확인*을 클릭하십시오."

#: ../../editing.rst:60
msgid ""
"To save the family you are working on and add a genus to it then click on"
" the *Add Genera* button."
msgstr "작업 중인 패밀리를 저장하고 해당 패밀리에 속 하나를 추가하려면 *Add Gener* 버튼을 클릭합니다."

#: ../../editing.rst:63
msgid ""
"To add another family when you are finished editing the current one click"
" on the *Next* button on the bottom.  This saves the current family and "
"opens a new blank family editor."
msgstr ""
"현재 편집이 완료되면 다른 패밀리를 추가하려면 아래쪽에 있는 *다음* 버튼을 클릭하십시오.  이렇게 하면 현재 패밀리가 저장되고 새 빈 "
"패밀리 편집기가 열립니다."

#: ../../editing.rst:69
msgid "Genus"
msgstr "속명"

#: ../../editing.rst:71
msgid "The Genus editor allows you to add or change a botanical genus."
msgstr "Incular 편집기는 식물 속을 추가하거나 변경할 수 있게 해줍니다."

#: ../../editing.rst:73
msgid ""
"The *Family* field on the genus editor allows you to choose the family "
"for the genus.  When you begin type a family name it will show a list of "
"families to choose from.  The family name must already exist in the "
"database before you can set it as the family for the genus."
msgstr ""
"속 편집기의 *패밀리* 필드를 사용하여 속 편집기의 패밀리를 선택할 수 있습니다.  성을 입력하기 시작하면 선택할 수 있는 가족 목록이 "
"표시됩니다.  패밀리를 패밀리로 설정하려면 먼저 패밀리가 데이터베이스에 이미 존재해야 합니다."

#: ../../editing.rst:78
msgid "The *Genus* field allows you to set the genus for this entry."
msgstr "*Genus* 필드를 사용하여 이 항목에 대한 속을 설정할 수 있습니다."

#: ../../editing.rst:80
msgid ""
"The *Author* field allows you to set the name or abbreviation of the "
"author(s) for the genus."
msgstr "*Author* 필드를 사용하여 해당 속성의 작성자 이름이나 약어를 설정할 수 있습니다."

#: ../../editing.rst:83
msgid ""
"*Synonyms* allow you to add other genera that are synonyms with the genus"
" you are currently editing.  To add a new synonyms type in a genus name "
"in the entry.  You must select a genus name from the list of completions."
"  Once you have selected a genus name that you want to add as a synonym "
"click on the Add button next to the synonym list and it will add the "
"selected synonym to the list.  To remove a synonym select the synonym "
"from the list and click on the Remove button."
msgstr ""
"*Synonyms*를 사용하면 현재 편집 중인 속과 동의어인 다른 속들을 추가할 수 있습니다.  항목의 속 이름에 새로운 동의어를 "
"추가합니다.  완료 목록에서 속 이름을 선택해야 합니다.  동의어로 추가할 속 이름을 선택한 후 동의어 목록 옆에 있는 추가 단추를 "
"클릭하면 선택한 동의어가 목록에 추가됩니다.  동의어를 제거하려면 목록에서 동의어를 선택하고 [제거] 단추를 클릭하십시오."

#: ../../editing.rst:93
msgid "To save the genus you are working on then click *OK*."
msgstr "작업 중인 속을 저장하려면 *OK*를 클릭하십시오."

#: ../../editing.rst:95
msgid ""
"To save the genus you are working on and add a species to it then click "
"on the *Add Species* button."
msgstr "작업 중인 속을 저장하고 여기에 종을 추가하려면 *종 추가* 버튼을 클릭하십시오."

#: ../../editing.rst:98
msgid ""
"To add another genus when you are finished editing the current one click "
"on the *Next* button on the bottom.  This will save the current genus and"
" open a new blank genus editor."
msgstr ""
"현재 편집을 마쳤을 때 다른 속을 추가하려면 하단의 *다음* 버튼을 클릭하십시오.  이로써 현재의 속은 보존되고 새로운 빈 속 편집기가 "
"열린다."

#: ../../editing.rst:104
msgid "Species/Taxon"
msgstr "종/속"

#: ../../editing.rst:106
msgid ""
"For historical reasons called a `species`, but by this we mean a `taxon` "
"at rank `species` or lower.  It represents a unique name in the database."
"  The species editor allows you to construct the name as well as "
"associate metadata with the taxon such as its distribution, synonyms and "
"other information."
msgstr ""
"종(種)이라 불리는 역사적 이유로 우리는 종(種) 이하에서 종(種)의 세금을 뜻한다.  데이터베이스의 고유한 이름을 나타냅니다.  종 "
"편집기를 사용하면 이름을 구성하고 배포, 동의어 및 기타 정보와 같은 분류 제목과 메타데이터를 연결할 수 있습니다."

#: ../../editing.rst:112
msgid ""
"The *Infraspecific parts* in the species editor allows you to specify the"
" `taxon` further than at `species` rank."
msgstr "종 편집기의 *Infraspecific parts*를 사용하면 종별 순위에서 '종별'보다 '택시'를 더 지정할 수 있습니다."

#: ../../editing.rst:117
msgid "To save the species you are working on then click *OK*."
msgstr "작업 중인 종을 저장하려면 *확인*을 클릭하십시오."

#: ../../editing.rst:119
msgid ""
"To save the species you are working on and add an accession to it then "
"click on the *Add Accession* button."
msgstr "작업 중인 종을 저장하고 등록 정보를 추가하려면 *등록 추가* 버튼을 클릭하십시오."

#: ../../editing.rst:122
msgid ""
"To add another species when you are finished editing the current one "
"click on the *Next* button on the bottom.  This will save the current "
"species and open a new blank species editor."
msgstr ""
"현재 편집을 마쳤을 때 다른 종을 추가하려면 하단의 *다음* 버튼을 클릭하십시오.  이렇게 하면 현재 종을 저장하고 새 빈 종 편집기가 "
"열립니다."

#: ../../editing.rst:127
msgid "Accessions"
msgstr "액세스 권한"

#: ../../editing.rst:129
msgid ""
"The Accession editor allows us to add an accession to a species.  In "
"Ghini an accession represents a group of plants or clones that are of the"
" same taxon, are of the same propagule type (or treatment), were received"
" from the same source, were received at the same time."
msgstr ""
"등록 편집기를 사용하면 등록 정보를 종에 추가할 수 있습니다.  기니에서 등록은 동일한 분류군(또는 처리군)의 식물 또는 클론 그룹을 "
"나타내며, 같은 소스로부터 같은 전파형(또는 처리군)이 동시에 수신되었다."

#: ../../editing.rst:134
msgid "Choose the Taxon name, add one if you forgot to do that in advance."
msgstr "택스온 이름을 선택하고 잊어버린 경우 택스온 이름을 추가합니다."

#: ../../editing.rst:136
msgid ""
"You may note uncertainty in identification by adding an identification "
"qualifier, at the proper rank, so you can for example have a plant "
"initially identified as *Iris* cf. *florentina* by choosing *Iris "
"florentina* in the taxon name, identification qualifier 'cf.', qualified "
"rank 'species'."
msgstr ""
"식별 한정자를 적절한 순위에서 추가하여 식별의 불확실성을 확인할 수 있으므로, 예를 들어 분류 이름인 식별 한정자 'cf.'에서 *"
"Iris florentina*를 선택하여 *Iris* cf. *forentina*로 처음 식별된 식물을 지정할 수 있다."

#: ../../editing.rst:141
msgid "Type the Accession ID, preferably also the Quantity received."
msgstr "등록 ID를 입력합니다. 수신 수량도 입력합니다."

#: ../../editing.rst:145
msgid "Accession Source"
msgstr "소스 가입"

#: ../../editing.rst:147
msgid ""
"The source of the accessions lets you add more information about where "
"this accession came from.  Select a Contact from the drop-down list, or "
"choose \"Garden Propagation\", which is placed as a default first item in"
" the list of contacts."
msgstr ""
"접근 권한의 원본을 사용하여 접근 권한의 출처 정보를 추가할 수 있습니다.  드롭다운 목록에서 연락처를 선택하거나 연락처 목록에서 기본 "
"첫 번째 항목으로 배치된 \"정원 전파\"를 선택합니다."

#: ../../editing.rst:152
msgid "A Garden Propagation is the result of successful Propagation."
msgstr "정원 전파는 성공적인 전파의 결과이다."

#: ../../editing.rst:154
msgid ""
"When accessing material from a Garden Propagation, you would initially "
"leave the first tab alone (General) and start from the second tab "
"(Source). Select as Contact \"Garden Propagation\", indicate which plant "
"is the parent plant and choose among the still not completely accessed "
"propagations the one you intend to add as an accession in your database."
msgstr ""
"정원 전파에서 재료에 액세스할 때 처음에는 첫 번째 탭(일반)을 그대로 두고 두 번째 탭(소스)에서 시작합니다. 연락처 \"정원 전파\"로"
" 선택하고 상위 플랜트인 플랜트를 표시한 다음 데이터베이스에 등록으로 추가하려는 아직 완전히 액세스되지 않은 전파 중 하나를 선택합니다."

#: ../../editing.rst:160
msgid ""
"Once you select a propagation, the software will set several fields in "
"the General tab, which you can now review.  The Taxon (maybe you managed "
"to obtain something slightly different than the parent plant). The "
"Initial quantity (in case not all plants go in the same accession). The "
"Type of Material, inferred from the propagation type."
msgstr ""
"전파를 선택하면 소프트웨어가 일반 탭에서 여러 필드를 설정할 수 있습니다. 이제 이 필드를 검토할 수 있습니다.  Taxon(모공장과는 "
"약간 다른 것을 얻었을 수도 있습니다.) 초기 수량(모든 플랜트가 동일한 등록에 속하지 않는 경우)입니다. 전파 유형에서 유추된 재료 "
"유형입니다."

#: ../../editing.rst:170 ../../use_cases-jbq.rst:669
#: ../../use_cases-jbq.rst:704
msgid "Plant"
msgstr "식물"

#: ../../editing.rst:172
msgid ""
"A ``Plant`` in the Ghini database describes an individual plant in your "
"collection. A plant belongs to an accession, and it has a specific "
"location."
msgstr ""
"기니 데이터베이스에 있는 \"공장\"은 컬렉션에 있는 개별 공장에 대해 설명합니다. 식물은 등록에 속하며, 특정한 위치를 가지고 있다."

#: ../../editing.rst:176
msgid "Creating multiple plants"
msgstr "다중 식물 생성"

#: ../../editing.rst:178
msgid ""
"You can create multiple Plants by using ranges in the code entry. This is"
" only allowed when creating new plants and it is not possible when "
"editing existing Plants in the database."
msgstr ""
"코드 항목의 범위를 사용하여 여러 공장을 생성할 수 있습니다. 이것은 새 식물을 작성할 때만 허용되며 데이터베이스에서 기존 식물을 편집할 "
"때는 허용되지 않습니다."

#: ../../editing.rst:182
msgid ""
"For example the range, 3-5 will create plant with code 3,4,5.  The range "
"1,4-7,25 will create plants with codes 1,4,5,6,7,25."
msgstr ""
"예를 들어, 3-5는 코드 3,4,5로 공장을 만듭니다.  1,4-7,25의 범위는 코드 1,4,5,6,7,25의 식물을 생성할 것이다."

#: ../../editing.rst:185
msgid ""
"When you enter the range in the plant code entry the entry will turn blue"
" to indicate that you are now creating multiple plants.  Any fields that "
"are set while in this mode will be copied to all the plants that are "
"created."
msgstr ""
"식물코드 항목에 범위를 입력하면 파란색으로 바뀌어 여러 공장을 만들고 있음을 나타냅니다.  이 모드에 있는 동안 설정된 모든 필드는 "
"생성된 모든 식물에 복사됩니다."

#: ../../editing.rst:193
msgid "Pictures"
msgstr "사진"

#: ../../editing.rst:195
msgid ""
"Just as almost all objects in the Ghini database can have *Notes* "
"associated to them, Plants and Species can also have *Pictures*: next to "
"the tab for Notes, the Plant and the Species editors contain an extra tab"
" called \"Pictures\". You can associate as many pictures as you might "
"need to a plant and to a species object."
msgstr ""
"Ghini 데이터베이스의 거의 모든 개체가 *Notes*와 연결될 수 있듯이, 식물 및 종 편집기도 Notes, 식물 및 종 편집기의 탭 "
"옆에 *Pictures*:를 가질 수 있습니다. \"Pictures\"라는 추가 탭이 있습니다. 필요한 만큼의 그림을 식물과 종 개체와 "
"연결할 수 있습니다."

#: ../../editing.rst:201
msgid ""
"When you associate a picture to an object, the file is copied in the "
"*pictures* folder, and a miniature (500x500) is generated and copied in "
"the `thumbnails` folder inside of the pictures folder."
msgstr ""
"그림을 객체에 연결하면 *그림* 폴더에 파일이 복사되고 사진 폴더 안의 '썸네일' 폴더에 축소판 그림(500x500)이 생성되어 "
"복사됩니다."

#: ../../editing.rst:205
msgid ""
"As of Ghini-1.0.62, Pictures are not kept in the database. To ensure "
"pictures are available on all terminals where you have installed and "
"configured Ghini, you can use a network drive, or a file sharing service "
"like Tresorit or Dropbox."
msgstr ""
"Ghini-1.0.62 현재, 사진은 데이터베이스에 보관되지 않습니다. Ghini를 설치하고 구성한 모든 터미널에서 사진을 사용할 수 "
"있도록 네트워크 드라이브 또는 Tresorit 또는 Dropbox와 같은 파일 공유 서비스를 사용할 수 있습니다."

#: ../../editing.rst:210
msgid ""
"Remember that you have configured the pictures root folder when you "
"specified the details of your database connection. Again, you should make"
" sure that the pictures root folder is shared with your file sharing "
"service of choice."
msgstr ""
"데이터베이스 연결 세부 정보를 지정할 때 사진 루트 폴더를 구성했다는 점을 기억하십시오. 다시 사진 루트 폴더가 선택한 파일 공유 "
"서비스와 공유되는지 확인해야 합니다."

#: ../../editing.rst:215
msgid ""
"When a Plant or a Species in the current selection is highlighted, its "
"pictures are displayed in the pictures pane, the pane left of the "
"information pane. When an Accession in the selection is highlighted, any "
"picture associated to the plants in the highlighted accession are "
"displayed in the pictures pane."
msgstr ""
"현재 선택 영역의 식물 또는 종이 강조 표시되면 해당 그림이 정보 창의 왼쪽 창인 사진 창에 표시됩니다. 선택 영역의 등록이 강조 "
"표시되면 강조 표시된 등록의 식물과 관련된 모든 그림이 그림 창에 표시됩니다."

#: ../../editing.rst:221
msgid ""
"In Ghini-1.0, pictures are special notes, with category \"<picture>\", "
"and text the path to the file, relative to the pictures root folder.  In "
"the Notes tab, Picture notes will show as normal notes, and you can edit "
"them without limitations."
msgstr ""
"Ghini-1.0에서는 사진이 특수 노트로, \"<그림>\" 범주와 함께 사진 루트 폴더에 상대적인 파일 경로를 텍스트로 지정합니다.  "
"노트 탭에서 사진 노트는 일반 노트로 표시되며 제한 없이 편집할 수 있습니다."

#: ../../editing.rst:226
msgid ""
"A Plant is a physical object, so you associate to it pictures taken of "
"that individual plant, taken at any relevant development stage of the "
"plant, possibly helping its identification."
msgstr ""
"식물은 물리적인 물체이므로, 여러분은 식물의 모든 관련 개발 단계에서 찍은 개별 식물의 사진을 그것과 연관시켜, 그 식별에 도움을 줄 수 "
"있습니다."

#: ../../editing.rst:230
msgid ""
"Species are abstract objects, so you would associate to it pictures "
"showing the characteristic elements of the species, so it makes sense to "
"associate a flora illustration to it. You can also do that by reference: "
"go to the Notes tab, add a note and specify as category \"<picture>\", "
"then in the text field you type the URL for the illustration of your "
"choice."
msgstr ""
"종들은 추상적인 물건들이기 때문에, 여러분은 종의 특징적인 요소들을 보여주는 그림들을 그것과 연관시키게 될 것입니다. 그래서 그것에 "
"동식물 삽화를 연관시키는 것이 타당합니다. 참고: Notes 탭으로 이동하여 메모를 추가한 후 \"그림\"으로 지정한 다음 텍스트 필드에 "
"선택한 그림의 URL을 입력할 수 있습니다."

#: ../../editing.rst:238
msgid "Locations"
msgstr "위치"

#: ../../editing.rst:240
msgid "The Location editor"
msgstr "위치 편집기"

#: ../../editing.rst:243
msgid "danger zone"
msgstr "아들 가운데 짝을 고르고 있다"

#: ../../editing.rst:245
msgid ""
"The location editor contains an initially hidden section named *danger "
"zone*. The widgets contained in this section allow the user to merge the "
"current location into a different location, letting the user correct "
"spelling mistakes or implement policy changes."
msgstr ""
"위치 편집기에는 *위험 영역*이라는 이름의 초기 숨겨진 섹션이 포함되어 있습니다. 이 섹션에 포함된 위젯을 통해 사용자는 현재 위치를 "
"다른 위치로 병합하여 맞춤법 오류를 수정하거나 정책 변경 사항을 구현할 수 있습니다."

#: ../../ghini-family.rst:3
msgid "the Ghini family"
msgstr "기니 가문"

#: ../../ghini-family.rst:5
msgid ""
"Let's start by recalling the composition of the Ghini family, as shown in"
" the diagram:"
msgstr "다이어그램에 나와 있는 것처럼 Ghini 계열의 구성을 상기하는 것부터 시작하겠습니다:"

#: ../../ghini-family.rst:9
msgid ""
"You have learned how to use ghini.desktop, here we introduce the other "
"members of the family, and their interaction."
msgstr "gini.desktop 사용법을 배웠습니다. 여기서는 다른 가족 구성원과 그들의 상호 작용에 대해 소개합니다."

#: ../../ghini-family.rst:20
msgid ""
"ghini.pocket is an Android app which you can install from the `play store"
" <https://play.google.com/store/apps/details?id=me.ghini.pocket>`_. "
"ghini.pocket is definitely the tool you will use most, next to "
"ghini.desktop."
msgstr ""
"ghini.pocket은 https://play.google.com/store/apps/"
"details?id=me.ghini.pocket.ghini 플레이스토어에서 설치할 수 있는 안드로이드 앱이다.포켓은 분명히 당신이 가장 "
"많이 사용하게 될 도구입니다, ghini.computer 옆에."

#: ../../ghini-family.rst:26
msgid ""
"With ghini.pocket you always have the latest snapshot of your database "
"with you."
msgstr "기니랑.포켓 항상 데이터베이스의 최신 스냅샷을 가지고 있습니다."

#: ../../ghini-family.rst:29
msgid "Type an accession number, or scan its barcode or QR label, and you know:"
msgstr "등록 번호를 입력하거나 바코드 또는 QR 레이블을 스캔합니다:"

#: ../../ghini-family.rst:31
msgid "the identification of the plant,"
msgstr "식물의 식별,"

#: ../../ghini-family.rst:32
msgid "whether it already has pictures,"
msgstr "이미 사진이 있든 말든"

#: ../../ghini-family.rst:33
msgid "when it entered the garden and"
msgstr "그것이 정원에 들어갔을 때 그리고"

#: ../../ghini-family.rst:34
msgid "from which source."
msgstr "어느 출처에서 왔는지."

#: ../../ghini-family.rst:36
msgid "Apart as a quick data viewer, you can use ghini.pocket for..."
msgstr "빠른 데이터 뷰어 외에도 기니를 사용할 수 있습니다....을 위해 돈을 쓰다."

#: ../../ghini-family.rst:38
msgid "data correction"
msgstr "자료 수정"

#: ../../ghini-family.rst:41
msgid ""
"If by your judgement, some of the information is incorrect, or if the "
"plant is flowering and you want to immediately take a picture and store "
"it in the database, you do not need take notes on paper, nor follow "
"convolute procedures: ghini.pocket lets you write your corrections in a "
"log file, take pictures associated to the plant, and you will import this"
" information straight into the database, with further minimal user "
"intervention."
msgstr ""
"만약 여러분의 판단으로 일부 정보가 부정확하거나, 식물이 꽃을 피우고 있고, 즉시 사진을 찍어 데이터베이스에 저장하고자 한다면, 여러분은 "
"종이에 필기할 필요도 없고, 모순적인 절차를 따를 필요도 없습니다: 기니.pocket을 사용하면 로그 파일에 수정 사항을 기록하고 공장에 "
"연결된 사진을 찍을 수 있으며, 사용자가 개입하는 것을 최소화하면서 이 정보를 데이터베이스로 직접 가져올 수 있습니다."

#: ../../ghini-family.rst:49
msgid "inventory review"
msgstr "재고 조사"

#: ../../ghini-family.rst:52
msgid ""
"The initial idea on which we based ghini.pocket is still one of its "
"functionalities: inventory review."
msgstr "기니의 기초가 된 최초의 아이디어.포켓은 여전히 그 기능 중 하나이다: 재고 검토."

#: ../../ghini-family.rst:55
msgid ""
"Using ghini.pocket, reviewing the inventory of a greenhouse, in "
"particular if you have QR codes on plant labels, goes as fast as you can "
"walk: simply enter the location code of your greenhouse, reset the log, "
"then one by one scan the plant codes of the plants in the greenhouse.  No"
" further data collection action is required."
msgstr ""
"기니로.포켓, 온실 재고 조사, 특히 식물 라벨에 QR 코드가 있는 경우 걸을 수 있는 한 빨리 진행됩니다: 단순히 온실의 위치 코드를 "
"입력하고 로그를 재설정한 다음, 온실에 있는 식물의 식물 코드를 하나씩 스캔합니다.  추가 데이터 수집 작업은 필요하지 않습니다."

#: ../../ghini-family.rst:61
msgid ""
"When you're done, import the log in ghini.desktop.  The procedure "
"available in ghini.desktop includes adding unknown but labelled plants in"
" the database, marking as lost/dead all plants that the database reports "
"as alive and present in the inventoried location, but were not found "
"during the inventory."
msgstr ""
"작업이 완료되면 로그인 ghini.desktop을 가져옵니다.  ghini.desktop에서 사용할 수 있는 절차에는 데이터베이스에 알 "
"수 없지만 라벨이 부착된 플랜트를 추가하고, 데이터베이스가 재고 위치에 존재하며 있다고 보고하지만 재고 조사 중에는 발견되지 않은 모든 "
"플랜트를 분실/사망으로 표시하는 것이 포함됩니다."

#: ../../ghini-family.rst:67
msgid "taxonomic support"
msgstr "분류학적 지원"

#: ../../ghini-family.rst:70
msgid ""
"As a bonus, ghini.pocket contains a phonetic genus search, and a quite "
"complete database of botanic taxa with rank between order and genus, "
"including tribes, and synonymies."
msgstr ""
"보너스로, 기니.포켓은 음성 속 탐색과, 종족과 동의어를 포함한 순서와 속 사이의 순위를 가진 식물 택시의 꽤 완전한 데이터베이스를 "
"포함한다."

#: ../../ghini-family.rst:74 ../../ghini-family.rst:92
#: ../../ghini-family.rst:122
msgid "check further :any:`interaction among components`."
msgstr "추가 정보:any:'interaction incomponents'를 확인하십시오."

#: ../../ghini-family.rst:84
msgid "ghini.web is a web server, written in nodejs."
msgstr "ghini.web은 nodejs로 작성된 웹 서버이다."

#: ../../ghini-family.rst:86
msgid ""
"Its most visible part runs at http://gardens.ghini.me and shows as a map "
"of the world, where you browse gardens and search their published "
"collection."
msgstr ""
"가장 눈에 띄는 부분은 http://gardens.ghini.me에서 진행되며, 세계의 지도로서 여러분이 정원을 찾아보고 그들의 출판된 "
"컬렉션을 검색하는 곳입니다."

#: ../../ghini-family.rst:90
msgid "It also serves configuration data to ghini.tour instances."
msgstr "또한 구성 데이터를 기니로 제공합니다.예문을 답사하다."

#: ../../ghini-family.rst:103
msgid ""
"ghini.tour is an Android app which you can install from the `play store "
"<https://play.google.com/store/apps/details?id=me.ghini.tour>`_."
msgstr ""
"ghini.tour는 플레이 스토어 https://play.google.com/store/apps/"
"details?id=me.ghini.tour에서 설치할 수 있는 안드로이드 앱이다."

#: ../../ghini-family.rst:107
msgid ""
"People visiting your garden will install ghini.tour on their phone or "
"tablet, enjoy having a map of the garden, knowing where they are, and "
"will be able to listen to audio files that you have placed as virtual "
"information panels in strategic spots in your garden."
msgstr ""
"당신의 정원을 방문하는 사람들은 기니를 설치할 것입니다.휴대폰이나 태블릿으로 둘러보고, 정원의 지도를 가지고, 어디에 있는지 알고, "
"정원의 전략적 위치에 가상 정보 패널로 배치한 오디오 파일을 들을 수 있습니다."

#: ../../ghini-family.rst:112
msgid "world view"
msgstr "세계관"

#: ../../ghini-family.rst:115
msgid "at startup, you see the world and gardens.  select a garden, and enter."
msgstr "시작할 때, 당신은 세상과 정원을 보고 정원을 선택하고 입장합니다."

#: ../../ghini-family.rst:117
msgid "garden view"
msgstr "정원의 경치"

#: ../../ghini-family.rst:120
msgid "when viewing at garden level, you see panels.  select a panel, and listen."
msgstr "정원 수준에서 볼 때, 여러분은 패널을 보고, 패널을 선택하고, 귀를 기울입니다."

#: ../../ghini-family.rst:128
msgid "data streams between software components"
msgstr "소프트웨어 구성 요소 간의 데이터 스트림"

#: ../../ghini-family.rst:130
msgid ""
"This section contains technical information for database managers and "
"software developers."
msgstr "이 섹션에는 데이터베이스 관리자 및 소프트웨어 개발자를 위한 기술 정보가 포함되어 있습니다."

#: ../../ghini-family.rst:136
msgid ""
"In the diagram showing the composition of the Ghini family, the alert "
"reader noticed how different arrows representing different data flows, "
"had different colours: some are deep green, some have a lighter tint."
msgstr ""
"Ghini 계열의 구성을 보여주는 다이어그램에서, 알림 리더는 서로 다른 데이터 흐름을 나타내는 다른 화살표가 다른 색을 가지고 있다는 "
"것을 알아냈습니다. 어떤 화살표는 짙은 녹색이고 어떤 화살표는 밝은 색입니다."

#: ../../ghini-family.rst:142
msgid ""
"Deeper green streams are constant flows of data, representing the core "
"activity of a component, eg: the interaction between ghini.desktop and "
"its database server, or your internet browser and ghini.web."
msgstr ""
"더 깊은 녹색 스트림은 구성 요소의 핵심 활동(예: ghini.desktop과 해당 데이터베이스 서버 간의 상호 작용, 인터넷 브라우저 "
"및 ghini)을 나타내는 지속적인 데이터 흐름입니다.거미줄을 치다."

#: ../../ghini-family.rst:146
msgid ""
"Lighter green streams are import/export actions, initiated by the user at"
" the command panel of ghini.desktop, or in the ghini.tour settings page."
msgstr ""
"밝은 녹색 스트림은 ghini.desktop의 명령 패널 또는 ghini에서 사용자가 시작한 가져오기/내보내기 작업입니다.둘러보기 설정 "
"페이지."

#: ../../ghini-family.rst:149
msgid ""
"This is the same graph, in which all import data streams have been given "
"an identifier."
msgstr "이 그래프는 모든 가져오기 데이터 스트림에 식별자가 지정된 그래프와 동일합니다."

#: ../../ghini-family.rst:154
msgid "d2p: copy a snapshot of the desktop database to ghini.pocket"
msgstr "d2p: 데스크톱 데이터베이스의 스냅샷을 기니로 복사합니다.호주머니에 넣다"

#: ../../ghini-family.rst:157
msgid "export the desktop database to a pocket snapshot"
msgstr "데스크톱 데이터베이스를 포켓 스냅샷으로 내보내기"

#: ../../ghini-family.rst:158
msgid "copy the snapshot to the handheld device"
msgstr "스냅샷을 휴대용 장치에 복사하다"

#: ../../ghini-family.rst:160
msgid ""
"ghini.pocket integrates closely with ghini.desktop, and it's not a tool "
"for the casual nor the external user.  One task of your garden database "
"manager is to regularly copy an updated database snapshot to your Android"
" device."
msgstr ""
"ghini.pocket은 ghini.pocket과 긴밀하게 통합되며, 캐주얼이나 외부 사용자를 위한 도구가 아닙니다.  Garden "
"Database Manager의 작업 중 하나는 업데이트된 데이터베이스 스냅샷을 Android 장치에 정기적으로 복사하는 것입니다."

#: ../../ghini-family.rst:165
msgid ""
"We advise enabling USB debugging on the device.  In perspective, this "
"will allow ghini.desktop writing directily into the ghini.pocket device."
msgstr "장치에서 USB 디버깅을 활성화하는 것이 좋습니다.  이를 통해 기니 데스크톱에서 기니로 직접 쓸 수 있습니다.포켓 장치."

#: ../../ghini-family.rst:168
msgid ""
"Export the file from ghini.desktop, call the file pocket.db, copy it to "
"the phone::"
msgstr "ghini.desktop에서 파일을 내보내고 pocket.db 파일을 호출하여 전화기에 복사합니다::"

#: ../../ghini-family.rst:172
msgid ""
"The above location is valid even if your phone does not have a memory "
"card."
msgstr "위 위치는 휴대폰에 메모리 카드가 없는 경우에도 유효합니다."

#: ../../ghini-family.rst:174
msgid ""
"Other options include bluetooth, or whatever other way you normally use "
"to copy regular files into your Android device."
msgstr "다른 옵션으로는 Bluetooth 또는 일반 파일을 Android 장치로 복사하는 데 일반적으로 사용하는 다른 방법이 있습니다."

#: ../../ghini-family.rst:179
msgid ""
"p2d: import from the ghini.pocket log file and pictures into the central "
"database"
msgstr "p2d: 기니에서 가져옵니다.로그 파일 및 사진을 중앙 데이터베이스에 저장"

#: ../../ghini-family.rst:182
msgid ""
"even if we're still calling it “inventory log”, ghini.pocket's log "
"contains more than just inventory corrections."
msgstr "우리가 여전히 \"실질 로그\"라고 불러도, 기니Pocket의 로그에는 단순한 인벤토리 수정 이상의 내용이 포함되어 있습니다."

#: ../../ghini-family.rst:185
msgid "produce a log on the handheld device"
msgstr "휴대용 장치에 통나무를 달다"

#: ../../ghini-family.rst:186
msgid "import the log in the desktop database"
msgstr "데스크탑 데이터베이스의 로그 가져오기"

#: ../../ghini-family.rst:188
msgid ""
"first of all, copy the collected information from ghini.pocket into your "
"computer::"
msgstr "우선, 수집된 정보를 기니에서 복사하세요.컴퓨터에 포켓 연결:"

#: ../../ghini-family.rst:194
msgid "then use ghini.desktop to import this information into your database."
msgstr "그런 다음 ghini.dump를 사용하여 이 정보를 데이터베이스로 가져옵니다."

#: ../../ghini-family.rst:197
msgid "d2w: send a selection of your garden data to ghini.web"
msgstr "d2w: 선택한 정원 데이터를 기니에게 보냅니다.거미줄을 치다"

#: ../../ghini-family.rst:200
msgid ""
"Offer a selection of your garden data to a central ghini.web site, so "
"online virtual visitors can browse it.  This includes plant "
"identification and their geographic location."
msgstr ""
"중앙 기니에게 정원 데이터 선택 항목을 제공합니다.온라인 가상 방문자가 검색할 수 있도록 웹 사이트입니다.  여기에는 발전소 식별 및 "
"지리적 위치가 포함된다."

#: ../../ghini-family.rst:204 ../../ghini-family.rst:219
#: ../../ghini-family.rst:231
msgid "content of this flow:"
msgstr "이 흐름의 내용:"

#: ../../ghini-family.rst:206
msgid "garden: coords, name, zoom level (for initial view)"
msgstr "정원: 좌표, 이름, 확대/축소 수준(초기 보기용)"

#: ../../ghini-family.rst:207
msgid "plants: coords, identification, zoom level (for visibility)"
msgstr "식물: 좌표, 식별, 확대/축소 수준(가시성을 위해)"

#: ../../ghini-family.rst:208
msgid "species: binomial, phonetic approximation"
msgstr "종: 이항, 음성 근사치"

#: ../../ghini-family.rst:212
msgid "g2w: add geographic non-botanic data to ghini.web"
msgstr "g2w: 지리적으로 비확장 데이터를 ghini에 추가합니다.거미줄을 치다"

#: ../../ghini-family.rst:215
msgid ""
"Write geographic information about non-botanic data (ie: point of "
"interest within the garden, required by ghini.tour) in the central "
"ghini.web site."
msgstr ""
"중앙 기니에서 보타닉이 아닌 데이터(즉, ghini.tour에 필요한 정원 내 관심 지점)에 대한 지리적 정보를 작성합니다.웹 사이트."

#: ../../ghini-family.rst:221
msgid "virtual panels: coords, title, audio file"
msgstr "가상 패널: 좌표, 제목, 오디오 파일"

#: ../../ghini-family.rst:222
msgid "photos: coords, title, picture"
msgstr "사진: 좌표, 제목, 사진"

#: ../../ghini-family.rst:224
msgid ""
"virtual panels don't necessarily have an associated photo, photos don't "
"necessarily have an associated audio file."
msgstr "가상 패널에는 반드시 연결된 사진이 없으며, 사진에는 반드시 연결된 오디오 파일이 없습니다."

#: ../../ghini-family.rst:228
msgid "w2t: importing locations and POIs from ghini.web to tour"
msgstr "w2t: 기니에서 위치 및 POI를 가져옵니다.웹 투 투어"

#: ../../ghini-family.rst:233
msgid "Garden (coords, name, zoom level)"
msgstr "정원(좌표, 이름, 확대/축소 수준)"

#: ../../ghini-family.rst:234
msgid "Points of Interest (coords, title, audio file, photo)"
msgstr "관심장소(좌표, 제목, 오디오 파일, 사진)"

#: ../../goal.rst:2
msgid "Ghini's goals and highlights"
msgstr "기니의 목표와 하이라이트"

#: ../../goal.rst:4
msgid ""
"Should you use this software? This question is for you to answer. We "
"trust that if you manage a botanic collection, you will find Ghini overly"
" useful and we hope that this page will convince you about it."
msgstr ""
"이 소프트웨어를 사용할까요?로 답변 드리기 이 질문은.우리는 만약 당신이 식물원 수집 관리하고, 여러분은 과도하게 유용한 Ghini을 "
"찾을 것이다. 그리고 이 페이지 이것에 대해 납득시키기를 바라를 신뢰한다."

#: ../../goal.rst:8
msgid ""
"This page shows how Ghini makes software meet the needs of a botanic "
"garden."
msgstr "이 페이지는 Ghini가 어떻게 소프트웨어를 식물원의 요구에 맞게 만드는지 보여줍니다."

#: ../../goal.rst:10
msgid ""
"If you already know, and all you want is to do something practical, just"
"  `install the software <installing.html>`_, then check our `user-"
"contributed recipes <use_cases.html>`_."
msgstr ""
"만약 여러분이 이미 알고 있고 여러분이 원하는 것은 실용적인 것을 하는 것이라면, \"소프트웨어 <installing.html\"을 "
"설치한 다음, \"사용자 제작 레시피 <use_cases.html>\"를 확인해 보세요."

#: ../../goal.rst:13
msgid "Botanic Garden"
msgstr "식물원"

#: ../../goal.rst:15
msgid ""
"According to the Wikipedia, »A botanic(al) garden is a garden dedicated "
"to the collection, cultivation and display of a wide range of plants "
"labelled with their botanical names«, and still according to the "
"Wikipedia, »a garden is a planned space, usually outdoors, set aside for "
"the display, cultivation, and enjoyment of plants and other forms of "
"nature.«"
msgstr ""
"위키백과에 따르면, \"식물원(al) 정원\"은 식물명을 가진 다양한 식물들의 수집, 재배, 전시를 위한 정원이며, 여전히 위키백과에 "
"따르면, \"정원은 보통 야외에서 계획된 공간이며, 식물과 다른 형태의 식물들의 전시, 재배, 즐거움을 위한 공간이다.튜레의"

#: ../../goal.rst:21
msgid ""
"So we have in a botanic garden both the physical space, the garden, as "
"its dynamic, the activities to which the garden is dedicated, activities "
"which makes us call the garden a botanic garden."
msgstr ""
"그래서 우리는 식물원 안에 물리적 공간, 정원의 역동성, 정원이 바쳐지는 활동, 정원을 식물원이라고 부르는 활동들을 가지고 있습니다."

#: ../../goal.rst:27
msgid "**the physical garden**"
msgstr "**물리적 정원**"

#: ../../goal.rst:31
msgid "**collection related activities in the garden**"
msgstr "**Physical Garden**"

#: ../../goal.rst:36
msgid "Botanic Garden Software"
msgstr "보타닉 가든 소프트웨어"

#: ../../goal.rst:38
msgid ""
"At the other end of our reasoning we have the application program Ghini, "
"and again quoting the Wikipedia, »an application program is a computer "
"program designed to perform a group of coordinated functions, tasks, or "
"activities for the benefit of the user«, or, in short, »designed to help "
"people perform an activity«."
msgstr ""
"우리의 추론의 다른 쪽 끝에는 애플리케이션 프로그램 기니가 있고, 위키백과를 다시 인용하면, 애플리케이션 프로그램은 사용자의 이익을 위해 "
"조정된 기능, 작업 또는 활동의 그룹을 수행하도록 설계된 컴퓨터 프로그램이며, 간단히 말해서, 사람들이 활동을 하도록 돕기 위해 고안된 "
"것이다."

#: ../../goal.rst:44
msgid ""
"Data and algorithms within Ghini have been designed to represent the "
"physical space and the dynamic of a botanic garden."
msgstr "기니 내의 데이터와 알고리즘은 식물원의 물리적 공간과 역동성을 나타내도록 설계되었다."

#: ../../goal.rst:49 ../../searching.rst:160
msgid "**core structure of Ghini's database**"
msgstr "**Ghini 데이터베이스의 핵심 구조**"

#: ../../goal.rst:51
msgid ""
"In the above figure, a simplified view on the database, the highlighted "
"blocks are those relative to objects you definitely need insert in the "
"database."
msgstr "위의 그림에서, 데이터베이스의 단순화된 보기, 강조 표시된 블록은 데이터베이스에 삽입해야 하는 객체와 관련된 블록입니다."

#: ../../goal.rst:55
msgid ""
"We distinguish three main sections in the database.  Start reading the "
"graph from the right hand side, with the relevant **Taxonomy** "
"information, then step to administering your **Collection**, and finally "
"consider the physical **Garden**."
msgstr ""
"우리는 데이터베이스에서 세 개의 주요 섹션을 구별한다.  관련 **Taxonomy** 정보를 사용하여 그래프를 읽기 시작한 후 "
"**Collection** 관리 단계를 수행하고 마지막으로 물리적 **Garden***를 고려합니다."

#: ../../goal.rst:60
msgid ""
"The central element in Ghini's point of view is the ``Accession``. "
"Following its links to other database objects lets us better understand "
"the structure:"
msgstr ""
"기니의 관점에서 중심적인 요소는 ``액세스션\"이다. 다른 데이터베이스 개체에 대한 링크를 클릭하면 다음 구조를 더 잘 이해할 수 있습다:"

#: ../../goal.rst:63
msgid "**Accession links Planting to Species**"
msgstr "**액세스 링크 종에 대한 심기**"

#: ../../goal.rst:65
msgid ""
"An ``Accession`` represents the action of receiving this specific plant "
"material in the garden. As such, ``Accession`` is an abstract concept, it"
" links physical living ``Plantings`` —groups of plants placed each at a "
"``Location`` in the garden— to the corresponding ``Species``. It is not "
"the same as an acquisition from a source, because in a single acquisition"
" you can access material of more than one species. In other words: a "
"single aquisition can embark multiple accessions. An ``Accession`` has "
"zero or more ``Plantings`` associated to it (0..n), and it is at all "
"times connected to exactly 1 ``Species``. Each ``Planting`` belongs to "
"exactly one ``Accession``, each ``Species`` may have multiple "
"``Accessions`` relating to it."
msgstr ""
"\"접근\"은 정원에서 이 특정한 식물 재료를 받는 행위를 의미한다. 이처럼 '액세스션'은 추상적인 개념으로 정원의 '위치'에 각각 놓여 "
"있는 식물군인 '식물군'을 해당 '종'과 연결시킨다. 소스로부터의 획득과 동일하지 않습니다. 단일 획득에서는 둘 이상의 종에 대한 재료에 "
"액세스할 수 있기 때문입니다. 즉, 단일 획득이 여러 액세스에 착수할 수 있습니다. '액세스션'에는 0개 이상의 '식물'이 관련돼 "
"있고(0..n) 항상 정확히 1개 '종'과 연결되어 있다. 각각의 ``식물\"은 정확히 하나의 \"접속\"에 속하며 각각의 \"종\"은 "
"그것과 관련된 여러 개의 \"접속\"을 가질 수 있다."

#: ../../goal.rst:74
msgid ""
"An ``Accession`` stays in the database even if all of its ``Plantings`` "
"have been removed, sold, or have died. Identifying the ``Species`` of an "
"``Accession`` consistently connects all its ``Plantings`` to the "
"``Species``."
msgstr ""
"'액세스션'은 모든 ``플랜팅\"이 제거되거나, 판매되거나, 죽더라도 데이터베이스에 남아 있다. '액세스션'의 '종'을 식별하면 모든 "
"'식물'과 '종'이 일관되게 연결된다."

#: ../../goal.rst:79
msgid "**Accession at the base of the history of your plants**"
msgstr "**식물 역사의 기초에 접근**"

#: ../../goal.rst:81
msgid ""
"``Propagations`` and ``Contacts`` provide plant material for the garden; "
"this information is optional and smaller collectors might prefer to leave"
" this aside. A ``Propagation`` trial may be unsuccessful, most of the "
"time it will result in exactly one accession, but it may also produce "
"slightly different taxa, so the database allows for zero  or more "
"``Accessions`` per ``Propagation`` (0..n). Also a ``Contact`` may provide"
" zero or more ``Accessions`` (0..n)."
msgstr ""
"\"전파\"와 \"연락처\"는 정원에 식물 재료를 제공한다. 이 정보는 선택 사항이며 소규모 수집가들은 이것을 그냥 내버려두는 것을 "
"선호할 수 있다. ``전파\" 재판은 성공하지 못할 수도 있는데, 대부분의 경우 그것은 정확히 하나의 가입으로 귀속될 수도 있지만 약간 "
"다른 세금도 발생할 수 있기 때문에 데이터베이스는 \"전파\"(0..n)당 0개 이상의 \"접속\"을 허용한다. 또한 '연락처'는 0 "
"또는 그 이상의 '액세스'(0..n)를 제공할 수 있다."

#: ../../goal.rst:88
msgid "**Accession and Verification opinions**"
msgstr "**접근 및 검증의견**"

#: ../../goal.rst:90
msgid ""
"Specialists may formulate their opinion about the ``Species`` to which an"
" ``Accession`` belongs, by providing a ``Verification``, signing it, and "
"stating the applicable level of confidence."
msgstr "전문가들은 '접근'이 속한 '종'에 대해 '검증'을 제공하고 서명하며 해당 신뢰도를 명시함으로써 의견을 공식화할 수 있다."

#: ../../goal.rst:94
msgid "**Accessing your own Propagations**"
msgstr "**자신의 전파 액세스**"

#: ../../goal.rst:96
msgid ""
"If an ``Accession`` was obtained in the garden nursery from a successful "
"``Propagation``, the ``Propagation`` links the ``Accession`` and all of "
"its ``Plantings`` to a single parent ``Planting``, the seed or the "
"vegetative parent."
msgstr ""
"만약 \"접속\"이 성공적인 ``전파\"로부터 정원 보육원에서 얻어졌다면 \"전파\"는 \"접속\"과 그 모든 ``식물\"을 씨앗이나 "
"식물 부모인 한 부모인 \"식물\"과 연결시킨다."

#: ../../goal.rst:103
msgid ""
"Even after the above explanation, new users generally still ask why they "
"need pass through an ``Accession`` screen while all they want is to "
"insert a ``Plant`` in the collection, and again: what is this "
"\"accession\" thing anyway?  Most discussions on the net don't make the "
"concept any clearer. One of our users gave an example which I'm glad to "
"include in Ghini's documentation."
msgstr ""
"위의 설명 이후에도 새로운 사용자들은 일반적으로 \"액세스\" 화면을 통과해야 하는 이유를 묻는 반면 그들이 원하는 것은 컬렉션에 "
"\"플랜트\"를 삽입하는 것뿐이고, 다시 말해서 어쨌든 \"액세스\"란 무엇인가?  대부분의 인터넷 상의 논의는 개념을 더 명확하게 하지 "
"못한다. 저희 사용자 중 한 명이 제가 기니의 설명서에 기꺼이 포함시킨 예를 들었습니다."

#: ../../goal.rst
msgid "use case"
msgstr "케이스를 사용하다"

#: ../../goal.rst:110
msgid ""
"At the beginning of 2007 we got five seedlings of *Heliconia longa* (a "
"plant ``Species``) from our neighbour (the ``Contact`` source). Since it "
"was the first acquisition of the year, we named them 2007.0001 (we gave "
"them a single unique ``Accession`` code, with quantity 5) and we planted "
"them all together at one ``Location`` as a single ``Planting``, also with"
" quantity 5."
msgstr ""
"2007년 초에 우리는 이웃나라('연락처')로부터 '헬레코니아 롱가'('종의 식물') 묘목 5점을 받았다. 올해 첫 번째 인수였기 때문에 "
"우리는 그들에게 2007.0001이라는 이름을 붙였고 우리는 그들 모두를 하나의 \"위치\"에 하나의 \"식물\"으로 그리고 또한 5개의 "
"\"식물\"으로 심었다."

#: ../../goal.rst:118
msgid ""
"At the time of writing, nine years later, ``Accession`` 2007.0001 has 6 "
"distinct ``Plantings``, each at a different ``Locations`` in our garden, "
"obtained vegetatively (asexually) from the original 5 plants. Our only "
"intervention was splitting, moving, and of course writing this "
"information in the database. Total plant quantity is above 40."
msgstr ""
"9년이 지난 2007.0001은 9년이 지난 현재 우리 정원에 있는 각기 다른 '위치'에 있는 6개의 '식물'이 원래의 5개 식물에서 "
"채소를 (성적으로) 얻었다. 우리의 유일한 개입은 분할, 이동, 그리고 물론 데이터베이스에 이 정보를 작성하는 것이었습니다. 총 플랜트 "
"수량이 40개 이상입니다."

#: ../../goal.rst:125
msgid ""
"New ``Plantings`` obtained by (assisted) sexual ``Propagation`` come in "
"our database under different ``Accession`` codes, where our garden is the"
" ``Contact`` source and where we know which of our ``Plantings`` is the "
"seed parent."
msgstr ""
"성적인 ''전파''가 입수한 새로운 ''전파''는 우리의 데이터베이스에 우리 정원이 ``접촉\"의 원천이고 ``전파\" 중 어느 것이 "
"종자 부모인지 우리가 아는 다른 ``접근\" 코드로 나온다."

#: ../../goal.rst:130
msgid "the above three cases translate into several short usage stories:"
msgstr "위의 세 가지 사례는 몇 가지 짧은 사용 사례로 해석됩니다:"

#: ../../goal.rst:132
msgid ""
"activate the menu Insert → Accession, verify the existence and "
"correctness of the ``Species`` *Heliconia longa*, specify the initial "
"quantity of the ``Accession``; add its ``Planting`` at the desired "
"``Location``."
msgstr ""
"→ 등록 삽입 메뉴를 활성화하고, \"종\" *헬리코니아 longa*의 존재와 정확성을 확인하고, \"접속\"의 초기 수량을 지정하고, "
"원하는 \"위치\"에 \"식물\"을 추가합니다."

#: ../../goal.rst:136
msgid ""
"edit ``Planting`` to correct the amount of living plants — repeat this as"
" often as necessary."
msgstr "\"식물 재배\"를 수정하여 생식물의 양을 수정하고 필요한 경우 이를 자주 반복한다."

#: ../../goal.rst:138
msgid ""
"edit ``Planting`` to split it at separate ``Locations`` — this produces a"
" different ``Planting`` under the same ``Accession``."
msgstr "``플랜팅\"을 편집해 별도의 ``위치\"로 나누면 같은 ``액세스\" 하에서 다른 ``플랜팅\"이 나온다."

#: ../../goal.rst:140
msgid "edit ``Planting`` to add a (seed) ``Propagation``."
msgstr "'심기'를 편집해 '전파'를 붙인다."

#: ../../goal.rst:141
msgid "edit ``Planting`` to update the status of the ``Propagation``."
msgstr "'플랜팅'을 편집해 '전파'의 위상을 새롭게 하다."

#: ../../goal.rst:142
msgid ""
"activate the menu Insert → Accession to associate an accession to a "
"successful ``Propagation`` trial; add the ``Planting`` at the desired "
"``Location``."
msgstr "→ 등록 삽입 메뉴를 활성화하여 성공적인 ``전파\" 재판에 등록하고 원하는 \"위치\"에 \"플랜팅\"을 추가합니다."

#: ../../goal.rst:146
msgid ""
"In particular the ability to split a ``Planting`` at several different "
"``Locations`` and to keep all uniformly associated to one ``Species``, or"
" the possibility to keep information about ``Plantings`` that have been "
"removed from the collection, help justify the presence of the "
"``Accession`` abstraction level."
msgstr ""
"특히 ``식물\"을 여러 다른 ``위치\"에 분할하고 하나의 ``종\"과 모든 연관성을 균일하게 유지할 수 있는 능력이나 수집에서 제거된 "
"``식물\"에 대한 정보를 유지할 수 있는 가능성은 \"접근\" 추상화 수준의 존재를 정당화하는 데 도움이 된다."

#: ../../goal.rst:153
msgid "Hypersimplified view"
msgstr "지나치게 단순화된 보기"

#: ../../goal.rst:155
msgid ""
"People using Ghini only sporadically may prefer ignoring the database "
"structure and look at it as two nested sequences of objects, each element"
" of the sequence being necessary to add element at the next level."
msgstr ""
"Ghini를 산발적으로만 사용하는 사람들은 데이터베이스 구조를 무시하고 다음 단계에서 요소를 추가하는 데 필요한 두 개의 중첩된 객체 "
"시퀀스로 보는 것을 선호할 수열의 각 요소는 다음과 같다."

#: ../../goal.rst:159
msgid ""
"In order to get down to an Accession, you will need four levels, as in "
"this example:"
msgstr "등록으로 이동하려면 다음 예와 같이 네 가지 수준이 필요합니다:"

#: ../../goal.rst:164
msgid ""
"A quite complete set of Families and Genera are inserted in your database"
" at the moment Ghini initializes it. So all you need is adding Species "
"and Accessions, in this order."
msgstr ""
"Ghini가 데이터베이스를 초기화하는 순간 완전한 패밀리 및 제네레이션 집합이 데이터베이스에 삽입됩니다. 따라서 종과 접근법만 추가하면 "
"됩니다."

#: ../../goal.rst:168
msgid ""
"When placing a physical Plant (relative to an Accession) somewhere in the"
" garden, you need to describe this \"somewhere\" digitally, as a Location"
" in the garden."
msgstr ""
"(등록과 관련된) 실제 식물을 정원 어딘가에 배치할 때, 여러분은 이 \"어딘가\"를 디지털로, 정원의 위치라고 설명할 필요가 있습니다."

#: ../../goal.rst:177
msgid "Highlights"
msgstr "하이라이트"

#: ../../goal.rst:178
msgid "not-so-brief list of highlights, meant to whet your appetite."
msgstr "식욕을 돋우기 위한 하이라이트 목록이야."

#: ../../goal.rst:181
msgid "taxonomic information"
msgstr "분류학적 정보"

#: ../../goal.rst:183
msgid ""
"When you first start Ghini, and connect to a database, Ghini will "
"initialize the database not only with all tables it needs to run, but it "
"will also populate the taxon tables for ranks family and genus, using the"
" data from the “RBG Kew's Family and Genera list from Vascular Plant "
"Families and Genera compiled by R. K. Brummitt and published by the Royal"
" Botanic Gardens, Kew in 1992”.  In 2015 we have reviewed the data "
"regarding the Orchidaceae, using “Tropicos, botanical information system "
"at the Missouri Botanical Garden - www.tropicos.org” as a source."
msgstr ""
"Ghini를 처음 시작하고 데이터베이스에 연결하면, Ghini는 데이터베이스를 실행해야 하는 모든 테이블로 초기화할 뿐만 아니라 R.K. "
"Brummt가 컴파일한 \"RBG Kew's Family and General list\"의 데이터를 사용하여 순위 패밀리와 속에서의 "
"Taxon 테이블도 채울 수 있습니다.1992년 큐우 왕립 식물원\"  2015년에는 \"Tropicos, 미주리 식물원의 식물 정보 "
"시스템 - www.tropicos.org\"을 출처로 사용하여 난초과와 관련된 데이터를 검토하였다."

#: ../../goal.rst:193
msgid "importing data"
msgstr "데이터 가져오기"

#: ../../goal.rst:195
msgid ""
"Ghini will let you import any data you put in an intermediate json "
"format. What you import will complete what you already have in the "
"database. If you need help, you can ask some Ghini professional to help "
"you transform your data into Ghini's intermediate json format."
msgstr ""
"Ghini는 중간 json 형식으로 입력한 모든 데이터를 가져올 수 있도록 합니다. 가져온 내용은 데이터베이스에 이미 있는 내용을 "
"완료합니다. 도움이 필요한 경우 Ghini 전문가에게 데이터를 Ghini의 중간 json 형식으로 변환하도록 도움을 요청할 수 있습니다."

#: ../../goal.rst:201
msgid "synonyms"
msgstr "동의어"

#: ../../goal.rst:203
msgid ""
"Ghini will allow you define synonyms for species, genera, families. Also "
"this information can be represented in its intermediate json format and "
"be imported in an existing Ghini database."
msgstr ""
"Ghini 당신 종, 속, 가정들은 동의어들을 정의할 것이다.또한 이 정보를 대한 중간json 형식으로 기존 Ghini 데이터베이스에 "
"수입될 표시할 수 있다."

#: ../../goal.rst:208
msgid "scientific responsible"
msgstr "과학적 책임이 있는"

#: ../../goal.rst:210
msgid ""
"Ghini implements the concept of 'accession', intermediate between "
"physical plant (or a group thereof) and abstract taxon. Each accession "
"can associate the same plants to different taxa, if two taxonomists do "
"not agree on the identification: each taxonomist can have their say and "
"do not need overwrite each other's work. All verifications can be found "
"back in the database, with timestamp and signature."
msgstr ""
"기니는 '접근'의 개념, 물리적 식물(또는 물리적 식물 그룹)과 추상적 과세(taxon)의 중간 개념을 구현한다. 두 명의 분류학자가 "
"식별에 동의하지 않는 경우, 각 분류학자는 서로 다른 분류학에 동일한 식물을 연관시킬 수 있으며, 서로의 작업을 덮어쓸 필요가 없다. "
"모든 확인은 타임스탬프와 서명을 사용하여 데이터베이스에서 다시 찾을 수 있습니다."

#: ../../goal.rst:218
msgid "helps off-line identification"
msgstr "오프라인 식별에 도움이 됩니다"

#: ../../goal.rst:220
msgid ""
"Ghini allows you associate pictures to physical plants, this can help "
"recognize the plant in case a sticker is lost, or help taxonomic "
"identification if a taxonomist is not available at all times."
msgstr ""
"기니를 사용하면 그림을 물리적 식물과 연결할 수 있으며, 스티커가 분실된 경우 식물을 인식하는 데 도움이 될 수 있으며, 분류학자를 항상 "
"사용할 수 없는 경우 분류법을 식별하는 데 도움이 될 수 있습니다."

#: ../../goal.rst:225
msgid "exports and reports"
msgstr "수출과 보고"

#: ../../goal.rst:227
msgid ""
"Ghini will let you export a report in whatever textual format you need. "
"It uses a powerful templating engine named 'mako', which will allow you "
"export the data in a selection to whatever format you need. Once "
"installed, a couple of examples are available in the mako subdirectory."
msgstr ""
"Ghini 당신이 원하는 모든 것이 텍스트 형식에서 너가 필요한 보고서를 내보내 줄 것이다.그것은 선택에서 무엇이든지 형식이 필요할 수 "
"있도록 데이터를 수출하게 할 강력한 templating 엔진 'mako'이라고 이름을 사용합니다.한번 설치한 뒤에는 두개의 예들은mako "
"디렉터리에서 이용할 수 있다."

#: ../../goal.rst:233
msgid "annotate your info"
msgstr "정보에 주석을 달다"

#: ../../goal.rst:235
msgid ""
"You can associate notes to plants, accessions, species, .... Notes can be"
" categorized and used in searches or reports."
msgstr "노트를 식물, 접근권, 종, ..에 연결할 수 있습니다. 노트를 분류하여 검색 또는 보고서에 사용할 수 있습니다."

#: ../../goal.rst:239
msgid "garden or herbarium"
msgstr "정원이나 허바리움"

#: ../../goal.rst:241
msgid "Management of plant locations."
msgstr "발전소 위치 관리."

#: ../../goal.rst:244
msgid "database history"
msgstr "데이터베이스 기록"

#: ../../goal.rst:246
msgid ""
"All changes in the database is stored in the database, as history log. "
"All changes are 'signed' and time-stamped.  Ghini makes it easy to "
"retrieve the list of all changes in the last working day or week, or in "
"any specific period in the past."
msgstr ""
"데이터베이스의 모든 변경사항은 데이터베이스에 기록 로그로 저장됩니다. 모든 변경 사항은 '서명' 및 시간 스탬프로 표시됩니다.  기니는 "
"마지막 근무일이나 주, 또는 과거의 특정 기간에 대한 모든 변경사항 목록을 쉽게 검색할 수 있도록 합니다."

#: ../../goal.rst:252
msgid "simple and powerful search"
msgstr "간단명료한 수색"

#: ../../goal.rst:254
msgid ""
"Ghini allows you search the database using simple keywords, e.g.: the "
"name of the location or a genus name, or you can write more complex "
"queries, which do not reach the complexity of SQL but allow you a decent "
"level of detail localizing your data."
msgstr ""
"Ghini는 간단한 키워드(예: 위치의 이름 또는 속 이름)를 사용하여 데이터베이스를 검색하거나, SQL의 복잡성에 도달하지는 않지만 "
"데이터를 로컬라이징하는 적절한 수준의 세부 정보를 허용하는 더 복잡한 쿼리를 작성할 수 있습니다."

#: ../../goal.rst:260
msgid "database agnostic"
msgstr "데이터베이스 불가지론"

#: ../../goal.rst:262
msgid ""
"Ghini is not a database management system, so it does not reinvent the "
"wheel. It works storing its data in a SQL database, and it will connect "
"to any database management system which accepts a SQLAlchemy connector. "
"This means any reasonably modern database system and includes MySQL, "
"PostgreSQL, Oracle. It can also work with sqlite, which, for single user "
"purposes is quite sufficient and efficient. If you connect Ghini to a "
"real database system, you can consider making the database part of a LAMP"
" system (Linux-Apache-MySQL-Php) and include your live data on your "
"institution web site."
msgstr ""
"Ghini는 데이터베이스 관리 시스템이 아니므로 운영 환경을 혁신하지 않습니다. 데이터를 SQL 데이터베이스에 저장하고 SQL 스키마 "
"커넥터를 허용하는 데이터베이스 관리 시스템에 연결합니다. 이는 합리적인 최신 데이터베이스 시스템을 의미하며 MySQL, Postgre를 "
"포함합니다.SQL, Oracle. 또한 sqlite와 함께 사용할 수 있습니다. sqlite는 단일 사용자 목적을 위해 매우 충분하고 "
"효율적입니다. Ghini를 실제 데이터베이스 시스템에 연결하는 경우 데이터베이스를 LAMP 시스템(Linux-Apache-MySQL-"
"Php)의 일부로 만들고 라이브 데이터를 기관 웹 사이트에 포함할 수 있습니다."

#: ../../goal.rst:273
msgid "language agnostic"
msgstr "언어에 구애받지 않는"

#: ../../goal.rst:275
msgid ""
"The program was born in English and all its technical and user "
"documentation is first written in that language. Both technical and user "
"documentation use ``gettext``, an advanced tool for semi-automatic "
"translation."
msgstr ""
"이 프로그램은 영어로 작성되었으며 모든 기술 및 사용자 설명서가 해당 언어로 작성되었습니다. 기술 문서와 사용자 문서 모두 반자동 번역을 "
"위한 고급 도구인 \"gettext\"를 사용한다."

#: ../../goal.rst:279
msgid ""
"The program has been translated and can be used in various other "
"languages, including Spanish (97%), French (82%), Portuguese (71%), to "
"name some Southern American languages, as well as Ukrainian (100%) and "
"Czech (71%)."
msgstr ""
"이 프로그램은 번역되었으며 스페인어(97%), 프랑스어(82%), 포르투갈어(71%), 우크라이나어(100%), 체코어(71%) 등 "
"다양한 언어로 사용될 수 있다."

#: ../../goal.rst:283
msgid ""
"Translation of documentation goes a bit slower, with only Ukrainian, "
"Spanish and Italian at more than 50%."
msgstr "문서 번역은 우크라이나어, 스페인어, 이탈리아어만 50%가 넘는 등 다소 더디게 진행되고 있습니다."

#: ../../goal.rst:287
msgid "platform agnostic"
msgstr "플랫폼에 구애받지 않는"

#: ../../goal.rst:289
msgid ""
"Installing Ghini on Windows is an easy and linear process, it will not "
"take longer than 10 minutes. Ghini was born on Linux and installing it on"
" ubuntu, fedora or debian is consequently even easier. MacOSX being based"
" on unix, it is possible to successfully run the Linux installation "
"procedure on any recent Apple computer, after a few preparation steps."
msgstr ""
"Windows(윈도우)에 기니를 설치하는 것은 쉽고 선형적인 프로세스로, 10분 이상 걸리지 않습니다. 기니는 리눅스에서 태어났고 "
"우분투, 페도라, 데비안에 설치하는 것이 결과적으로 훨씬 더 쉬워졌다. MacOSX는 유닉스 기반이므로 몇 가지 준비 단계를 거쳐 최신 "
"Apple 컴퓨터에서 Linux 설치 절차를 성공적으로 실행할 수 있습니다."

#: ../../goal.rst:296
msgid "easily updated"
msgstr "쉽게 업데이트되는"

#: ../../goal.rst:298
msgid ""
"The installation process will produce an updatable installation, where "
"updating it will take less than one minute. Depending on the amount of "
"feedback we receive, we will produce updates every few days or once in a "
"while."
msgstr ""
"설치 프로세스에서는 업데이트 가능한 설치가 생성되며, 여기서 업데이트하는데 1분도 걸리지 않습니다. 피드백의 양에 따라 며칠에 한 번 "
"또는 가끔씩 업데이트를 제공합니다."

#: ../../goal.rst:304
msgid "unit tested"
msgstr "단위 시험"

#: ../../goal.rst:306
msgid ""
"Ghini is continuously and extensively unit tested, something that makes "
"regression of functionality close to impossible. Every update is "
"automatically quality checked, on the Travis Continuous Integration "
"service. Integration of TravisCI with the github platform will make it "
"difficult for us to release anything which has a single failing unit "
"test."
msgstr ""
"기니는 지속적이고 광범위하게 유닛 테스트를 거쳤으며, 이는 기능 회귀를 거의 불가능하게 만드는 것이다. 모든 업데이트는 Travis "
"Continuous Integration 서비스에서 자동으로 품질 검사를 받습니다. 트라비스의 통합github 플랫폼이 있는 CI는 단일 "
"장애 장치 테스트를 가진 모든 것을 출시하는 것을 어렵게 만들 것입니다."

#: ../../goal.rst:312
msgid ""
"Most changes and additions we make, come with some extra unit test, which"
" defines the behaviour and will make any undesired change easily visible."
msgstr ""
"우리가 수행하는 대부분의 변경사항과 추가사항은 추가적인 단위 테스트를 동반하며, 이는 동작을 정의하고 원하지 않는 변경을 쉽게 눈에 띄게 "
"한다."

#: ../../goal.rst:316
msgid "customizable/extensible"
msgstr "맞춤화/사용할 수 없는"

#: ../../goal.rst:318
msgid ""
"Ghini is extensible through plugins and can be customized to suit the "
"needs of the institution."
msgstr "기니는 플러그인을 통해 확장 가능하며 기관의 필요에 따라 맞춤화할 수 있다."

#: ../../imex.rst:2
msgid "Importing and Exporting Data"
msgstr "데이터 가져오기 및 내보내기"

#: ../../imex.rst:4
msgid ""
"Although Ghini can be extended through plugins to support alternate "
"import and export formats, by default it can only import and export comma"
" separated values files or CSV."
msgstr ""
"Ghini는 플러그인을 통해 확장되어 대체 가져오기 및 내보내기 형식을 지원할 수 있지만 기본적으로 쉼표로 구분된 값 파일 또는 CSV만 "
"가져오고 내보낼 수 있습니다."

#: ../../imex.rst:8
msgid ""
"There is some support for exporting to the Access for Biological "
"Collections Data it is limited."
msgstr "제한된 생물학적 수집 데이터에 대한 액세스 권한으로 내보낼 수 있습니다."

#: ../../imex.rst:11
msgid ""
"There is also limited support for exporting to an XML format that more or"
" less reflects exactly the tables and row of the database."
msgstr "또한 데이터베이스의 테이블과 행을 정확히 반영하는 XML 형식으로 내보낼 수 있는 지원도 제한됩니다."

#: ../../imex.rst:14
msgid "Exporting ABCD and XML will not be covered here."
msgstr "ABCD 및 XML 내보내기는 여기에서 다루지 않습니다."

#: ../../imex.rst:16
msgid ""
"Importing files will most likely destroy any data you have in the "
"database so make sure you have backed up your data."
msgstr "파일을 가져오면 데이터베이스에 있는 모든 데이터가 삭제될 가능성이 높으므로 데이터를 백업했는지 확인합니다."

#: ../../imex.rst:20
msgid "Importing from CSV"
msgstr "CSV에서 가져오기"

#: ../../imex.rst:21
msgid ""
"In general it is best to only import CSV files into Ghini that were "
"previously exported from Ghini. It is possible to import any CSV file but"
" that is more advanced that this doc will cover."
msgstr ""
"일반적으로 이것은 단지 Ghini 이전에 Ghini에서 외국으로 수출에 CSV파일을 가져오는 것이 가장 좋다.그것은 어떤 CSV파일을 "
"가져오지만 그에게는 더 이렇습니다를 해결할 것이다 진보된 가능성이 있다."

#: ../../imex.rst:25
msgid ""
"To import CSV files into Ghini select "
":menuselection:`Tools-->Export-->Comma Separated Values` from the menu."
msgstr ""
"CSV 파일을 Gini로 가져오려면 다음을 선택합니다. 메뉴 선택:메뉴에서 'Tools-->Export-->Comma Separated "
"Values'를 선택합니다."

#: ../../imex.rst:29
msgid ""
"After clicking OK on the dialog that ask if you are sure you know what "
"you're doing a file chooser will open.  In the file chooser select the "
"files you want to import."
msgstr "대화 상자에서 [확인]을 클릭하면 파일 선택기가 열립니다.  파일에서 가져올 파일을 선택합니다."

#: ../../imex.rst:35
msgid "Exporting to CSV"
msgstr "CSV로 내보내기"

#: ../../imex.rst:37
msgid ""
"To export the Ghini data to CSV select "
":menuselection:`Tools-->Export-->Comma Separated Values` from the menu."
msgstr ""
"Ghini 데이터를 CSV로 내보내려면 다음을 선택합니다. 메뉴 선택:메뉴에서 'Tools-->Export-->Comma "
"Separated Values'를 선택합니다."

#: ../../imex.rst:40
msgid ""
"This tool will ask you to select a directory to export the CSV data. All "
"of the tables in Ghini will be exported to files in the format "
"tablename.txt where tablename is the name of the table where the data was"
" exported from."
msgstr ""
"이 툴은 디렉터리는 CSV데이터를 내보낼 선택하라고 물어볼 것입니다.모든 Ghini의 표의 파일로 형식을 tablename에 수출될 "
"것이다.Txt 데이터가 어디에서 내보내던 테이블의 tablename의 이름이다."

#: ../../imex.rst:46
msgid "Importing from JSON"
msgstr "JSON에서 가져오기"

#: ../../imex.rst:48
msgid ""
"This is *the* way to import data into an existing database, without "
"destroying previous content. A typical example of this functionality "
"would be importing your digital collection into a fresh, just initialized"
" Ghini database. Converting a database into bauble json interchange "
"format is beyond the scope of this manual, please contact one of the "
"authors if you need any further help."
msgstr ""
"이것은*the* 방법 기존 데이터베이스에 등록하고, 이전의 내용을 파괴하지 않고 데이터 가져올 수 없습니다.이 기능성의 전형적인 예는 "
"신선한, 단지 초기화되 Ghini 데이터베이스에 디지털 컬렉션 많이 수입하게 될 것이다.싸구려 보석json 교환 형식에 데이터베이스 변환 "
"이 매뉴얼의 범위 밖이다 만약 추가 도움이 필요하면 하나를 작가로 연락하십시오."

#: ../../imex.rst:55
msgid ""
"Using the Ghini json interchange format, you can import data which you "
"have exported from a different Ghini installation."
msgstr "Ginijson 교환 형식을 사용하면 다른 Gini 설치에서 내보낸 데이터를 가져올 수 있습니다."

#: ../../imex.rst:59
msgid "Exporting to JSON"
msgstr "JSON으로 내보내기"

#: ../../imex.rst:61
msgid "This feature is still under development."
msgstr "이 기능은 아직 개발 중입니다."

#: ../../imex.rst:65
msgid ""
"when you activate this export tool, you are given the choice to specify "
"what to export. You can use the current selection to limit the span of "
"the export, or you can start at the complete content of a domain, to be "
"chosen among Species, Accession, Plant."
msgstr ""
"이 내보내기 도구를 활성화하면 내보낼 항목을 지정할 수 있습니다. 현재 선택 항목을 사용하여 내보내기 범위를 제한하거나, 종, 등록, "
"식물 중에서 선택할 도메인의 전체 내용에서 시작할 수 있습니다."

#: ../../imex.rst:71
msgid ""
"Exporting *Species* will only export the complete taxonomic information "
"in your database. *Accession* will export all your accessions plus all "
"the taxonomic information it refers to: unreferred to taxa will not be "
"exported. *Plant* will export all living plants (some accession might not"
" be included), all referred to locations and taxa."
msgstr ""
"*종*을 내보내면 데이터베이스의 전체 분류 정보만 내보냅니다. *액세스*는 모든 액세스 권한과 참조되는 모든 분류 정보를 내보냅니다. "
"taxa에 참조되지 않은 정보는 내보내지지 않습니다. *공장*은 모든 살아있는 식물(일부 등록은 포함되지 않을 수 있음)을 수출합니다. "
"모든 곳은 위치 및 택시입니다."

#: ../../imex.rst:79
msgid "Importing from a Generic Database"
msgstr "일반 데이터베이스에서 가져오기"

#: ../../imex.rst:81
msgid ""
"This functionality is the object of `issue #127 "
"<https://github.com/Ghini/ghini.desktop/issues/127>`_, for which we have "
"no generic solution yet."
msgstr ""
"이 기능은 아직 일반적인 솔루션이 없는 '이슈 #127 https://github.com/Ghini/ghini.desktop/issues/"
"127'의 객체이다."

#: ../../imex.rst:85
msgid ""
"If you're interested in importing data from some flat file (e.g.: Excel "
"spreadsheet) or from any database, contact the developers."
msgstr "일부 플랫 파일에서 데이터를 가져오려는 경우(예: Excel 스프레드시트) 또는 데이터베이스에서 개발자에게 문의하십시오."

#: ../../imex.rst:90
msgid "Importing a Pictures Collection"
msgstr "사진 모음 가져오기"

#: ../../imex.rst:92
msgid ""
"We can consider a collection of plant pictures as a particular form of "
"botanical database, in which each picture is clearly associated with one "
"specific plant."
msgstr "우리는 식물 사진의 컬렉션을 식물 데이터베이스의 특정 형태로 고려할 수 있으며, 각 그림은 특정 식물과 명확하게 연관되어 있다."

#: ../../imex.rst:96
msgid ""
"Even without using a photo collection software, you can associate "
"pictures to accessions by following one and the same clear rule when "
"naming picture files."
msgstr ""
"사진 수집 소프트웨어를 사용하지 않더라도 사진 파일 이름을 지정할 때 하나와 동일한 명확한 규칙을 따라 사진을 액세스에 연결할 수 "
"있습니다."

#: ../../imex.rst:100
msgid ""
"For example, ``2018.0020.1 (4) Epidendrum.jpg`` would be the name of the "
"fourth picture for plant number 1 within accession 2018.0020, identified "
"to rank genus as an Epidendrum."
msgstr ""
"예를 들어, \"2018.0020.1(4) Epidendrum.jpg\"는 등록 2018.0020 내에서 제1공장에 대한 네 번째 그림의 "
"이름이 될 것이며, 이는 속(속)을 Epidendrum으로 분류한 것이다."

#: ../../imex.rst:104
msgid ""
"The :menuselection:`Tools-->Import-->Pictures` functionality here "
"described is meant for importing an ordered collection of plant pictures "
"either to initialize a ghini database, or for periodically adding to it."
msgstr ""
": 메뉴 선택:여기서 설명하는 '도구--> 가져오기--> 사진' 기능은 기니 데이터베이스를 초기화하거나 주기적으로 추가하기 위해 정렬된 "
"플랜트 그림 컬렉션을 가져오는 것을 의미한다."

#: ../../imex.rst:109
msgid ""
"Use :menuselection:`Tools-->Import-->Pictures` to activate this import "
"tool.  Import goes in several steps: parameter definition; data revision "
"and confirmation; the import step proper; finally review the import log."
"  At the first two steps you can confirm the data and go to the next step"
" by clicking on the ``next`` button, or you can go back to the previous "
"step by clicking on the ``prev`` button.  Once the import is done and "
"you're reviewing the log, you can only either confirm —or abort— the "
"whole transaction."
msgstr ""
"사용: 메뉴 선택:이 가져오기 도구를 활성화하려면 '도구-->가 필요합니다.  가져오기는 매개 변수 정의, 데이터 수정 및 확인, "
"가져오기 단계 적절, 마지막으로 가져오기 로그를 검토합니다.  처음 두 단계에서 데이터를 확인하고 \"다음\" 버튼을 클릭하여 다음 "
"단계로 이동하거나 \"사전\" 버튼을 클릭하여 이전 단계로 돌아갈 수 있습니다.  가져오기가 완료되고 로그를 검토하고 나면 전체 "
"트랜잭션을 확인하거나 중단할 수만 있습니다."

#: ../../imex.rst:119
msgid ""
"In the \"parameter definition\" pane you: select the directory from which"
" you intend to import pictures; indicate whether to import pictures "
"recursively; select or create a location which will be used as default "
"location for new plants; inform the tool about the rule you've been "
"following when naming picture files."
msgstr ""
"매개 변수 정의 창에서 사진을 가져올 디렉토리를 선택하고, 사진을 반복적으로 가져올지 여부를 나타냅니다. 새 식물의 기본 위치로 사용할 "
"위치를 선택하거나 만듭니다. 사진 파일의 이름을 지정할 때 따랐던 규칙에 대해 도구에 알립니다."

#: ../../imex.rst:127
msgid ""
"In the \"data revision\" pane you are shown a table with as many rows as "
"the pictures you are importing.  Each row holds as much information as "
"the tool managed to extract from the picture name.  You can review the "
"information, correct or confirm, and indicate whether or not the row "
"should be imported."
msgstr ""
"데이터 수정기호 창에서 가져올 사진만큼 행이 있는 테이블이 표시됩니다.  각 행에는 그림 이름에서 추출한 도구만큼 많은 정보가 들어 "
"있습니다.  정보를 검토하고, 수정 또는 확인하며, 행을 가져올지 여부를 지정할 수 있습니다."

#: ../../imex.rst:135
msgid ""
"In the final \"commit or rollback\" pane you read the logs relative to "
"your data import, and decide whether to keep them (commit them to the "
"database), or undo them (rollback the transaction)."
msgstr ""
"마지막 \"커밋 또는 롤백\" 창에서 데이터 가져오기와 관련된 로그를 읽고 로그의 보관(데이터베이스에 커밋) 또는 실행 취소(트랜잭션 "
"롤백) 여부를 결정합니다."

#: ../../imex.rst:141
msgid ""
"When the Picture Collection importer creates or updates objects, it also "
"sets a Note that you can use for selecting the objects involved in the "
"import, and for reviewing if needed."
msgstr ""
"사진 모음 임포터는 개체를 만들거나 업데이트할 때 가져오기에 관련된 개체를 선택하고 필요한 경우 검토하는 데 사용할 수 있는 참고 사항도 "
"설정합니다."

#: ../../index.rst:2
msgid "Documentation for Ghini 1.0"
msgstr "Ghini 1.0에 대한 문서"

#: ../../index.rst:8
msgid ""
"Ghini is a suite of applications for managing botanical specimen "
"collections."
msgstr "Ghini는 식물 표본 수집을 관리하기위한 응용 프로그램 모음입니다."

#: ../../index.rst:10
msgid ""
"**ghini.desktop** lets you create and query a database representing "
"objects and events in your plant collection."
msgstr ""
"**ghini.desktop를** 사용하면 플랜트 컬렉션의 개체및 이벤트를 나타내는 데이터베이스를 만들고 쿼리할 수 있습니다."

#: ../../index.rst:11
msgid "**ghini.web** publishes highlights from your database on the web."
msgstr "**ghini.web는** 웹에 데이터베이스의 하이라이트를 게시합니다."

#: ../../index.rst:12
msgid "**ghini.pocket** puts a snapshot of your database in your handheld device."
msgstr "**ghini.pocket는** 핸드헬드 장치에 데이터베이스의 스냅샷을 넣습니다."

#: ../../index.rst:13
msgid ""
"**ghini.tour** assists garden visitors with a map and spoken virtual "
"panels."
msgstr "**ghini.tour는** 정원 방문객을 지도와 음성 가상 패널로 지원합니다."

#: ../../index.rst:17
msgid ""
"The bulk of this documentation focuses on ghini.desktop.  One final "
"chapter presents the rest of the Ghini family: :any:`ghini.pocket`, "
":any:`ghini.web`, :any:`ghini.tour`, and the :any:`interaction among "
"components`."
msgstr ""
"이 설명서의 대부분은 gini.desktop에 초점을 맞추고 있습니다.  마지막 장에서는 기니의 나머지 가족인 'any:'ghini'를 "
"소개합니다.포켓, :any:ghini.web', :any:'ghini.tour' 및 :any:'구성 요소 간 상호 작용'."

#: ../../index.rst:21
msgid ""
"All Ghini software is `open <http://www.opensource.org>`_ and `free "
"<http://www.fsf.org>`_. Our standalone software is released under the "
"`GNU Public License <http://www.fsf.org/licensing/licenses/gpl.html>`_. "
"Our client-server software follows the `GNU Affero Public License "
"<http://www.fsf.org/licensing/licenses/agpl.html>`_."
msgstr ""
"모든 기니 소프트웨어는 오픈 http://www.opensource.org과 무료 http://www.fsf.org이다. 당사의 독립형 "
"소프트웨어는 'GNU 공용 라이센스 http://www.fsf.org/licensing/licenses/gpl.html'로 "
"출시되었습니다. 우리의 클라이언트-서버 소프트웨어는 'GNU Affero Public License http://www.fsf.org/"
"licensing/licenses/agpl.html'을 따른다."

#: ../../index.rst:28
msgid "Statements"
msgstr "진술들"

#: ../../index.rst:37
msgid "Installing Ghini"
msgstr "기니 설치"

#: ../../index.rst:46
msgid "User's Guide"
msgstr "사용 설명서"

#: ../../index.rst:61
msgid "Cookbook"
msgstr "요리책"

#: ../../index.rst:69
msgid "Administration"
msgstr "행정"

#: ../../index.rst:77
msgid "Ghini Family"
msgstr "지니 파밀리"

#: ../../index.rst:85
msgid "Ghini Development"
msgstr "기니 개발"

#: ../../index.rst:94
msgid "Supporting Ghini"
msgstr "지지 기니"

#: ../../index.rst:96
msgid ""
"If you're using Ghini, or if you feel like helping its development "
"anyway, please consider donating."
msgstr "만약 여러분이 기니를 사용하고 있거나, 기니의 발전을 돕고 싶다면, 기부를 고려해 보세요."

#: ../../installing.rst:2
msgid "Installation"
msgstr "설치"

#: ../../installing.rst:4
msgid ""
"ghini.desktop is a cross-platform program and it will run on unix "
"machines like GNU/Linux and MacOSX, as well as on Windows."
msgstr "ghini.desktop은 크로스 플랫폼 프로그램으로 GNU/리눅스 및 MacOSX와 같은 유닉스 머신에서 실행된다."

#: ../../installing.rst:7
msgid "one-liner for hurried users."
msgstr "급행 승객을 위한 1인승."

#: ../../installing.rst:10
msgid ""
"Linux users just download and run `the installation script "
"<https://raw.githubusercontent.com/Ghini/ghini.desktop/ghini-1.0-dev/scripts/devinstall.sh>`_."
" You may read the documentation later."
msgstr ""
"리눅스 사용자들은 설치 스크립트 https://raw.githubusercontent.com/Ghini/ghini.desktop/"
"ghini-1.0-dev/scripts/devinstall.sh'을 다운로드해서 실행하기만 하면 된다. 나중에 설명서를 읽을 수 있습니다."

#: ../../installing.rst:14
msgid ""
"Windows users in a real hurry don't the instructions and use a recent "
"`Windows installer <https://github.com/Ghini/ghini.desktop/releases/>`_."
"  You do not miss any functional feature, but you have less chances to "
"contribute to development."
msgstr ""
"윈도 사용자들은 정말 서둘러 지시를 하지 않고 최신 윈도 설치 프로그램인 https://github.com/Ghini/ghini."
"desktop/releases/을 사용한다.  어떤 기능적 특징도 놓치지 않지만, 개발에 기여할 기회는 적습니다."

#: ../../installing.rst:18
msgid "Mac users are never in a hurry, are they?"
msgstr "맥 사용자들은 결코 서두르지 않죠, 그렇죠?"

#: ../../installing.rst:20
msgid ""
"Ghini is maintained by very few people, who focus on enhancing its "
"functional parts, more than on writing fancy installers. Instead of "
"several native installers we offer a single cross-platform installation "
"procedure. This has a few big advantages which you will learn to "
"appreciate as we go."
msgstr ""
"기니는 화려한 설치기를 쓰는 것보다 그것의 기능적인 부분을 향상시키는 데 집중하는 극소수의 사람들에 의해 유지된다. 여러 기본 설치 "
"프로그램 대신 단일 교차 플랫폼 설치 절차를 제공합니다. 이것은 우리가 가는 동안 여러분이 감사하는 것을 배울 몇 가지 큰 장점들을 "
"가지고 있습니다."

#: ../../installing.rst:25
msgid "The installation is based on running a script."
msgstr "설치는 스크립트 실행을 기반으로 합니다."

#: ../../installing.rst:27
msgid ""
"The GNU/Linux script takes care of everything, from dependecies to "
"installation for users in the ``ghini`` group."
msgstr "GNU/리눅스 스크립트는 종속성부터 ``기니\" 그룹의 사용자를 위한 설치에 이르기까지 모든 것을 처리한다."

#: ../../installing.rst:29
msgid "The Windows script needs you to first install a couple things."
msgstr "Windows 스크립트는 먼저 몇 가지를 설치해야 합니다."

#: ../../installing.rst:30
msgid ""
"On MacOSX we use the same script as on GNU/Linux. Since OSX has no "
"default package manager, we install one and we use it before we start the"
" script."
msgstr ""
"MacOSX에서는 GNU/Linux와 동일한 스크립트를 사용합니다. OSX에는 기본 패키지 관리자가 없으므로 스크립트를 시작하기 전에 "
"하나를 설치하고 사용합니다."

#: ../../installing.rst:33
msgid ""
"Following our installation procedure, you will end with Ghini running "
"within a Python virtual environment, all Python dependencies installed "
"locally, non conflicting with any other Python program you may have on "
"your system."
msgstr ""
"설치 절차에 따라 Python 가상 환경에서 실행되는 Ghini와 함께 종료됩니다. 모든 Python 종속성은 로컬에서 설치되며 시스템에 "
"있을 수 있는 다른 Python 프로그램과 충돌하지 않습니다."

#: ../../installing.rst:37
msgid ""
"Dependencies that don't fit in a Python virtual environment are: Python, "
"virtualenv, GTK+, and PyGTK. Their installation varies per platform."
msgstr ""
"Python 가상 환경에 맞지 않는 종속성은 Python, virtualenv, GTK+ 및 PyGTK입니다. 설치는 플랫폼마다 다릅니다."

#: ../../installing.rst:40
msgid ""
"If you later choose to remove Ghini, you simply remove the virtual "
"environment, which is a directory, with all of its content."
msgstr "나중에 Ghini를 제거하도록 선택하면 디렉터리인 가상 환경이 모든 컨텐츠로 제거됩니다."

#: ../../installing.rst:44
msgid "Installing on GNU/Linux"
msgstr "GNU/리눅스에 설치"

#: ../../installing.rst:46
msgid "Open a shell terminal window, and follow the following instructions."
msgstr "셸 터미널 창을 열고 다음 지침을 따르십시오."

#: ../../installing.rst:48
msgid "Download the `devinstall.sh` script:"
msgstr "devinstall을 다운로드합니다.sh' 스크립트:"

#: ../../installing.rst:50
msgid ""
"`devinstall.sh "
"<https://raw.githubusercontent.com/Ghini/ghini.desktop/ghini-1.0-dev/scripts/devinstall.sh>`_"
msgstr ""
"'devinstallsh https://raw.githubusercontent.com/Ghini/ghini.desktop/ghini-1."
"0-dev/scripts/devinstall.sh'_"

#: ../../installing.rst:52
msgid ""
"Invoke the script from a terminal window, starting at the directory where"
" you downloaded it, like this::"
msgstr "터미널 창에서 스크립트를 다운로드한 디렉토리에서 다음과 같이 호출합니다.::"

#: ../../installing.rst:57
msgid "The script will produce quite some output, which you can safely ignore."
msgstr "이 스크립트는 상당히 많은 출력을 생성하므로 사용자가 안전하게 무시할 수 있습니다."

#: ../../installing.rst:59
msgid "global installation"
msgstr "글로벌 설치"

#: ../../installing.rst:62
msgid ""
"When almost ready, the installation script will ask you for your "
"password.  This lets it create a ``ghini`` user group, initialise it to "
"just yourself, make the just created ``ghini`` script available to the "
"whole ``ghini`` user group."
msgstr ""
"거의 준비되면 설치 스크립트에서 암호를 묻는 메시지가 나타납니다.  이를 통해 ``기니\" 사용자 그룹을 만들어 자기 자신만으로 "
"초기화시키고 방금 만든 \"기니\" 사용자 그룹 전체가 사용할 수 있게 된다."

#: ../../installing.rst:67
msgid ""
"If feeling paranoid, you can safely not give your password and interrupt "
"the script there."
msgstr "편집증이 있는 경우 암호를 제공하지 않고 스크립트를 방해할 수 있습니다."

#: ../../installing.rst:70
msgid ""
"Possibly the main advantage of a global installation is being able to "
"find Ghini in the application menus of your graphic environment."
msgstr "글로벌 설치의 주요 이점은 그래픽 환경의 애플리케이션 메뉴에서 Ghini를 찾을 수 있다는 것입니다."

#: ../../installing.rst:74
msgid "You can now start ghini by invoking the ``ghini`` script::"
msgstr "이제 \"ghini\" 스크립트를 호출하여 ghini를 시작할 수 있습니다.::"

#: ../../installing.rst:78
msgid ""
"You use the same ``ghini`` script to update ghini to the latest released "
"production patch::"
msgstr "동일한 ''기니'' 스크립트를 사용하여 기니를 최신 릴리스 프로덕션 패치로 업데이트합니다.::"

#: ../../installing.rst:83
msgid "This is what you would do when ghini shows you something like this:"
msgstr "기니가 당신에게 이런 것을 보여줄 때 당신은 이렇게 할 것이다.:"

#: ../../installing.rst:87
msgid ""
"Users of the global installation will also type ``ghini`` to invoke the "
"program, but they will get to a different script, located in "
"``/usr/local/bin``. This globally available ``ghini`` script cannot be "
"used to update a ghini installation."
msgstr ""
"글로벌 설치 사용자들도 이 프로그램을 호출하기 위해 \"기니\"를 입력하지만 ``/usr/local/bin\"에 위치한 다른 스크립트로 "
"이동하게 된다. 전세계적으로 사용 가능한 이 \"기니\" 스크립트는 기니 설치를 업데이트하는 데 사용할 수 없습니다."

#: ../../installing.rst:92
msgid ""
"Again the same ``ghini`` script lets you install the optional database "
"connectors: option ``-p`` is for PostgreSQL, option ``-m`` is for "
"MySQL/MariaDB, but you can also install both at the same time::"
msgstr ""
"다시 동일한 \"ghini\" 스크립트를 사용하여 선택적 데이터베이스 커넥터를 설치할 수 있습니다. \"-p\" 옵션은 "
"Postgre용입니다.SQL, 옵션 ''-m''은 MySQL/MariaDB용이지만 두 옵션을 동시에 설치할 수도 있습니다.::"

#: ../../installing.rst:98
msgid ""
"Please beware: you might need solve dependencies. How to do so, depends "
"on which GNU/Linux flavour you are using. Check with your distribution "
"documentation."
msgstr ""
"주의해 주세요: 의존성을 해결해야 할 수도 있습니다. 이렇게 하는 방법은 사용하는 GNU/리눅스 향에 따라 다릅니다. 배포 문서를 "
"참조하십시오."

#: ../../installing.rst:102
msgid ""
"You can also use the ``ghini`` script to switch to a different production"
" line.  At the moment ``1.0`` is the stable one, but you can select "
"``1.1`` if you want to help us with its development::"
msgstr ""
"\"기니\" 스크립트를 사용하여 다른 생산 라인으로 전환할 수도 있습니다.  현재는 ''1.0''이 안정적이지만 '1'을 선택할 수 "
"있다.1당사의 개발을 돕고 싶은 경우 다음을 수행합니다.::"

#: ../../installing.rst:108
msgid "beginner's note"
msgstr "초급 노트"

#: ../../installing.rst:111
msgid ""
"To run a script, first make sure you note down the name of the directory "
"to which you have downloaded the script, then you open a terminal window "
"and in that window you type `bash` followed by a space and the complete "
"name of the script including directory name, and hit on the enter key."
msgstr ""
"스크립트를 실행하려면 먼저 스크립트를 다운로드한 디렉토리의 이름을 적어 놓은 다음 터미널 창을 열고 그 창에서 '배시'를 입력한 다음 "
"디렉터리 이름을 포함한 스크립트의 전체 이름과 공백을 입력하고 Enter 키를 누릅니다."

#: ../../installing.rst:117
msgid "technical note"
msgstr "기술 노트"

#: ../../installing.rst:120
msgid "You can study the script to see what steps if runs for you."
msgstr "스크립트를 검색하여 실행할 경우 어떤 단계를 실행할지 확인할 수 있습니다."

#: ../../installing.rst:122
msgid ""
"In short it will install dependencies which can't be satisfied in a "
"virtual environment, then it will create a virtual environment named "
"``ghide``, use git to download the sources to a directory named "
"``~/Local/github/Ghini/ghini.desktop``, and connect this git checkout to "
"the ``ghini-1.0`` branch (this you can consider a production line), it "
"then builds ghini, downloading all remaining dependencies in the virtual "
"environment, and finally it creates the ``ghini`` startup script."
msgstr ""
"간단히 말해서 가상 환경에서 만족할 수 없는 종속성을 설치한 다음 가상 환경을 만들고, git를 사용하여 소스를 ''~~/local/"
"github/Ghini/ghini.desktop'' 디렉토리에 다운로드하고, 이 git 체크 아웃을 ``ghini-1.0\" 지점에 "
"연결한다. 가상 환경에 남아 있는 모든 종속성을 다운로드하면서 ghini를 빌드하고 마지막으로 ''ghini' 시작 스크립트를 생성합니다."

#: ../../installing.rst:130
msgid ""
"If you have ``sudo`` permissions, it will be placed in "
"``/usr/local/bin``, otherwise in your ``~/bin`` folder."
msgstr "\"sudo\" 권한이 있으면 \"/usr/local/bin\"에, 그렇지 않으면 \"~bin\" 폴더에 배치됩니다."

#: ../../installing.rst:134 ../../installing.rst:212 ../../installing.rst:359
msgid "Next..."
msgstr "다음..."

#: ../../installing.rst:138
msgid "Installing on MacOSX"
msgstr "MacOSX에 설치"

#: ../../installing.rst:140
msgid ""
"Being macOS a unix environment, most things will work the same as on "
"GNU/Linux (sort of)."
msgstr "macOS는 유닉스 환경이기 때문에 대부분의 작업은 GNU/리눅스(일부)에서와 동일하게 동작한다."

#: ../../installing.rst:143
msgid ""
"First of all, you need things which are an integral part of a unix "
"environment, but which are missing in a off-the-shelf mac:"
msgstr "먼저, 유닉스 환경의 필수적인 부분이지만 기성품인 Mac에는 없는 것들이 필요합니다.:"

#: ../../installing.rst:146
msgid ""
"developers tools: xcode. check the wikipedia page for the version "
"supported on your mac."
msgstr "개발자 도구: xcode. Mac에서 지원되는 버전의 위키백과 페이지를 확인하십시오."

#: ../../installing.rst:148
msgid "package manager: homebrew (tigerbrew for older OSX versions)."
msgstr "패키지 관리자: 홈브루(이전 OSX 버전의 경우 타이거브루)."

#: ../../installing.rst:150
msgid "Installation on older macOS."
msgstr "이전 MacOS에 설치."

#: ../../installing.rst:153
msgid ""
"Every time we tested, we could only solve all dependencies on the two or "
"three most recent macOS versions.  In April 2015 this excluded macOS 10.6"
" and older.  In September 2017 this excluded macOS 10.8 and older.  We "
"never had a problem with the lastest macOS."
msgstr ""
"테스트를 할 때마다 가장 최신의 두 세 개의 MacOS 버전에 대한 모든 종속성만 해결할 수 있었습니다.  2015년 4월, 이것은 "
"macOS 10.6 이상을 제외했다.  2017년 9월에는 맥 OS 10.8 이상을 제외하였다.  최신 MacOS에는 문제가 없었습니다."

#: ../../installing.rst:158
msgid ""
"The problem lies with homebrew and some of the packages we rely on. The "
"message you have to fear looks like this::"
msgstr "문제는 홈브루와 우리가 의지하는 일부 소포에 있다. 두려워해야 할 메시지는 다음과 같습니다.::"

#: ../../installing.rst:163
msgid "The only solution I can offer is: please update your system."
msgstr "제가 제시할 수 있는 유일한 해결책은: 시스템을 업데이트하십시오."

#: ../../installing.rst:165
msgid ""
"On the bright side, if at any time in the past you did install "
"ghini.desktop on your older and now unsupported macOS, you will always be"
" able to update ghini.desktop to the latest version."
msgstr ""
"긍정적인 측면에서는 과거에 이전 MacOS에서 지원되지 않는 ghini.desktop을 설치했다면 항상 ghini.desktop을 최신 "
"버전으로 업데이트할 수 있습니다."

#: ../../installing.rst:169
msgid "With the above installed, open a terminal window and run::"
msgstr "위 내용이 설치된 상태에서 터미널 창을 열고 다음을 실행합니다.::"

#: ../../installing.rst:173
msgid ""
"make sure you understand the problems it reports, and correct them. pygtk"
" will need xquartz and brew will not solve the dependency automatically. "
"either install xquartz using brew or the way you prefer::"
msgstr ""
"보고되는 문제를 이해하고 수정해야 합니다. pygtk는 xquartz가 필요하며 brew는 의존성을 자동으로 해결하지 않습니다. "
"brew를 사용하거나 원하는 방식으로 xquartz를 설치합니다.::"

#: ../../installing.rst:179
msgid "then install the remaining dependencies::"
msgstr "그런 다음 나머지 종속성을 설치합니다.::"

#: ../../installing.rst:184
msgid "follow all instructions on how to activate what you have installed."
msgstr "설치된 항목을 활성화하는 방법에 대한 모든 지침을 따르십시오."

#: ../../installing.rst:186
msgid ""
"In particular, make sure you read and understand all reports starting "
"with ``If you need to have this software``."
msgstr "특히 \"이 소프트웨어가 필요한 경우\"로 시작하는 모든 보고서를 읽고 이해해야 합니다."

#: ../../installing.rst:189
msgid ""
"You will need at least the following four lines in your "
"``~/.bash_profile``::"
msgstr "\"~/.bash_profile\"에는 다음 네 줄 이상이 필요합니다::"

#: ../../installing.rst:196
msgid "Activate the profile by sourcing it::"
msgstr "프로파일을 소싱하여 활성화합니다::"

#: ../../installing.rst:200
msgid ""
"Before we can run ``devinstall.sh`` as on GNU/Linux, we still need "
"installing a couple of python packages, globally. Do this::"
msgstr ""
"\"devinstall\"을 실행하기 전에.GNU/리눅스에서와 마찬가지로 세계적으로도 파이썬 패키지를 몇 개 설치해야 합니다. 다음 "
"작업을 수행합니다::"

#: ../../installing.rst:205
msgid ""
"The rest is just as on a normal unix machine. Read the above GNU/Linux "
"instructions, follow them, enjoy."
msgstr "나머지는 일반 유닉스 시스템과 동일합니다. 위의 GNU/리눅스 지침을 읽고, 따르고, 즐기세요."

#: ../../installing.rst:207
msgid ""
"As an optional aesthetical step, consider packaging your ``~/bin/ghini`` "
"script in a `platypus <https://github.com/sveinbjornt/Platypus>`_ "
"application bundle.  The ``images`` directory contains a 128×128 icon."
msgstr ""
"선택적인 미학적 단계로 ''~/bin/ghini 스크립트'를 'platypus https://github.com/sveinbjornt/"
"Platypus'_ 애플리케이션 번들로 패키징하는 것을 고려하십시오.  ''images'' 디렉터리에는 128x128 아이콘이 포함되어 "
"있습니다."

#: ../../installing.rst:216
msgid "Installing on Windows"
msgstr "Windows에 설치"

#: ../../installing.rst:218
msgid ""
"The steps described here instruct you on how to install Git, Gtk, Python,"
" and the python database connectors. With this environment correctly set "
"up, the Ghini installation procedure runs as on GNU/Linux. The concluding"
" steps are again Windows specific."
msgstr ""
"여기서 설명하는 단계에서는 Git, Gtk, Python 및 Python 데이터베이스 커넥터를 설치하는 방법에 대해 설명합니다. 이 "
"환경을 올바르게 설정하면 GNU/Linux에서와 같이 Ghini 설치 절차가 실행됩니다. 결론 단계는 Windows에 따라 다릅니다."

#: ../../installing.rst:223
msgid ""
"Ghini has been tested with and is known to work on W-XP, W-7 up to W-10. "
"Although it should work fine on other versions Windows it has not been "
"thoroughly tested."
msgstr ""
"Ghini는 W-XP, W-7에서 W-10까지 테스트를 거친 것으로 알려져 있다. 다른 버전의 Windows(윈도우)에서는 잘 작동해야 "
"하지만 완전히 테스트되지는 않았습니다."

#: ../../installing.rst:233
msgid "The installation steps on Windows:"
msgstr "Windows의 설치 단계:"

#: ../../installing.rst:235
msgid ""
"download and install ``git`` (comes with a unix-like ``sh`` and includes "
"``vi``). Grab it from `the Git download area <https://git-"
"scm.com/download/win>`_."
msgstr ""
"다운로드 및 설치 \"git (\" (유닉스와 같은 \"sh and\"와 함께 제공되고 \"vi``\"를 포함한다.) Git "
"download area https://git-scm.com/download/win에서 가져옵니다."

#: ../../installing.rst:238
msgid ""
"all default options are fine, except we need git to be executable from "
"the command prompt:"
msgstr "명령 프롬프트에서 실행할 수 있는 git가 필요한 경우를 제외하고 모든 기본 옵션은 괜찮습니다:"

#: ../../installing.rst:243
msgid ""
"download and install Python 2.x (32bit). Grab it from the `Python "
"official site <http://www.python.org>`_."
msgstr ""
"Python 2.x(32비트)를 다운로드하여 설치합니다. 파이썬 공식 사이트 http://www.python.org에서 받아보세요."

#: ../../installing.rst:246
msgid "When installing Python, do put Python in the PATH:"
msgstr "Python을 설치할 때 PATH에 PYthon을 넣으십시오:"

#: ../../installing.rst:250
msgid ""
"download ``pygtk`` from `the official source "
"<http://ftp.gnome.org/pub/GNOME/binaries/win32/pygtk/>`_. (this requires "
"32bit python). be sure you download the \"all in one\" version."
msgstr ""
"'공식 소스 http://ftp.gnome.org/pub/GNOME/binaries/win32/pygtk/'에서 ''pygtkips''를 "
"다운로드한다. (이를 위해서는 32비트 파이썬이 필요하다.) \"all in one\" 버전을 다운로드해야 합니다."

#: ../../installing.rst:254
msgid "Make a complete install, selecting everything:"
msgstr "모든 항목을 선택하고 설치를 완료합니다:"

#: ../../installing.rst:258
msgid ""
"(Possibly necessary, maybe superfluous) install lxml, you can grab this "
"from `the pypi archives <https://pypi.python.org/pypi/lxml/3.4.4>`_"
msgstr ""
"(필요할 수도 있고, 불필요할 수도 있음) install lxml, 당신은 \"https://pypi.python.org/pypi/"
"lxml/3.4.4\"에서 이것을 잡을 수 있다."

#: ../../installing.rst:261
msgid "Remember you need the 32 bit version, for Python 2.7."
msgstr "파이썬 2.7의 경우 32비트 버전이 필요합니다."

#: ../../installing.rst:272
msgid ""
"(definitely optional) download and install a database connector other "
"than ``sqlite3``."
msgstr "(확실히 선택 사항임) \"sqlite3\" 이외의 데이터베이스 커넥터를 다운로드하여 설치합니다."

#: ../../installing.rst:275
msgid ""
"If you plan using PostgreSQL, the best Windows binary library for Python "
"is `psycopg and is Made in Italy "
"<http://initd.org/psycopg/docs/install.html>`_."
msgstr ""
"Postgre를 사용할 계획인 경우파이썬을 위한 최고의 윈도 바이너리 라이브러리인 SQL은 사이콥스(sycopg)이며 이탈리아에서 "
"만들어졌다(http://initd.org/psycopg/docs/install.html)."

#: ../../installing.rst:279
msgid "**REBOOT**"
msgstr "**재부팅**"

#: ../../installing.rst:281
msgid "hey, this is Windows, you need to reboot for changes to take effect!"
msgstr "Windows입니다. 변경 내용을 적용하려면 재부팅해야 합니다!"

#: ../../installing.rst:283
msgid ""
"We're done with the dependecies, now we can download and run the batch "
"file:"
msgstr "이제 종속성 작업을 마쳤으므로 배치 파일을 다운로드하고 실행할 수 있습니다:"

#: ../../installing.rst:287
msgid ""
"Please don't just follow the above link.  Instead: right click, save link"
" as..."
msgstr "위의 링크만 따르지 말아 주세요.  대신: 마우스 오른쪽 단추를 클릭하고 링크를 ...로 저장합니다."

#: ../../installing.rst:291
msgid ""
"Also make sure you don't let Windows convert the script to a text "
"document."
msgstr "또한 Windows에서 스크립트를 텍스트 문서로 변환하지 않도록 하십시오."

#: ../../installing.rst:295
msgid ""
"Now **Open** the script to run it.  Please note: in the below image, we "
"have saved the file twice, once letting Windows convert it to a text "
"document, and again as a Windows Batch File.  Opening the batch file will"
" run the script.  Opening the text document will show you the code of the"
" batch file, which isn't going to lead us anywhere."
msgstr ""
"이제 **열기** 스크립트를 실행하여 실행합니다.  참고: 아래 이미지에서는 파일을 두 번 저장하여 Windows에서 텍스트 문서로 "
"변환한 후 다시 Windows 배치 파일로 변환합니다.  배치 파일을 열면 스크립트가 실행됩니다.  텍스트 문서를 열면 배치 파일의 "
"코드가 표시되며, 이 코드는 우리를 어디로도 이끌지 못합니다."

#: ../../installing.rst:303
msgid ""
"If you installed everything as described here, the first thing you should"
" see when you start the installation script is a window like this, and "
"your computer will be busy during a couple of minutes, showing you what "
"it is doing."
msgstr ""
"여기에 설명된 대로 모든 것을 설치한 경우 설치 스크립트를 시작할 때 가장 먼저 표시되는 창은 다음과 같습니다. 그러면 몇 분 동안 "
"컴퓨터가 사용 중이어서 작업이 어떻게 진행되는지 알 수 있습니다."

#: ../../installing.rst:310
msgid ""
"Running ``devinstall.bat`` will pull the ``ghini.desktop`` repository "
"from github to your home directory, under ``Local\\github\\Ghini``, "
"checkout the ``ghini-1.0`` production line, create a virtual environment "
"and install ghini into it."
msgstr ""
"\"devinstall.bat\"을 실행하면 ``ghini.desktop\" 저장소가 \"Local\\github\\\" 아래에 있는 홈 "
"디렉토리로 이동하게 된다.'기니-1.0' 생산라인을 점검한 기니는 가상 환경을 조성하고 기니를 설치한다."

#: ../../installing.rst:315
msgid ""
"You can also run ``devinstall.bat`` passing it as argument the numerical "
"part of the production line you want to follow."
msgstr "또한 이를 인수로 전달하는 ''devinstall.bat''을 실행할 수 있습니다."

#: ../../installing.rst:318
msgid ""
"This is the last installation step that depends, heavily, on a working "
"internet connection."
msgstr "이 단계는 작동하는 인터넷 연결에 크게 좌우되는 마지막 설치 단계입니다."

#: ../../installing.rst:321
msgid ""
"The operation can take several minutes to complete, depending on the "
"speed of your internet connection."
msgstr "인터넷 연결 속도에 따라 작업을 완료하는 데 몇 분이 걸릴 수 있습니다."

#: ../../installing.rst:324
msgid ""
"the last installation step creates the Ghini group and shortcuts in the "
"Windows Start Menu, for all users. To do so, you need run a script with "
"administrative rights. The script is called ``devinstall-finalize.bat``, "
"it is right in your HOME folder, and has been created at the previous "
"step."
msgstr ""
"마지막 설치 단계는 모든 사용자에 대한 Windows 시작 메뉴에 Ghini 그룹 및 바로 가기를 만듭니다. 이렇게 하려면 관리 권한이 "
"있는 스크립트를 실행해야 합니다. 이 스크립트는 ''devinstall-finalize''라고 불린다.\"bat\"은(는) 홈 폴더에 "
"있으며 이전 단계에서 작성되었습니다."

#: ../../installing.rst:332
msgid ""
"Right-click on it, select run as administrator, confirm you want it to "
"make changes to your computer.  These changes are in the Start Menu only:"
" create the Ghini group, place the Ghini shortcut."
msgstr ""
"마우스 오른쪽 단추를 클릭하고 관리자로 실행을 선택한 후 컴퓨터를 변경할지 확인합니다.  이러한 변경 사항은 시작 메뉴에만 있습니다. "
"Ghini 그룹을 생성하고 Ghini 바로 가기를 배치합니다."

#: ../../installing.rst:336
msgid "download the batch file, it will help you staying up-to-date:"
msgstr "배치 파일을 다운로드하면 최신 상태를 유지할 수 있습니다."

#: ../../installing.rst:338
msgid ""
"`ghini-update.bat "
"<https://raw.githubusercontent.com/Ghini/ghini.desktop/ghini-1.0-dev/scripts"
"/ghini-update.bat>`_"
msgstr ""
"- 업데이트 해주세요. Stanfin: https://raw.githubusercontent.com/Ghini/ghini.desktop/"
"ghini-1.0-dev/scripts/ghini-update.bat (https://raw.githubusercontent.com/"
"Ghini/ghini.desktop/ghini-1.0-dev/scripts/ghini-update.bat)"

#: ../../installing.rst:340
msgid ""
"If you are on a recent Ghini installation, each time you start the "
"program, Ghini will check on the development site and alert you of any "
"newer ghini release within your chosen production line."
msgstr ""
"최근 Ghini 설치를 진행 중인 경우 프로그램을 시작할 때마다 Ghini가 개발 사이트를 확인하고 선택한 생산 라인 내에서 최신 "
"Ghini 릴리스에 대해 알려줍니다."

#: ../../installing.rst:344
msgid ""
"Any time you want to update your installation, just run the ``ghini-"
"update.bat`` script, it will hardly take one minute."
msgstr ""
"최근 Ghini 설치를 진행 중인 경우 프로그램을 시작할 때마다 Ghini가 개발 사이트를 확인하고 선택한 생산 라인 내에서 최신 "
"Ghini 릴리스에 대해 알려줍니다."

#: ../../installing.rst:347
msgid ""
"How to save a batch file, and how to run it: check the the quite detailed"
" instructions given for ``devinstall.bat``."
msgstr "배치 파일을 저장하는 방법 및 실행하는 방법: ''devinstall.bat''에 대해 주어진 매우 상세한 지시사항을 확인한다."

#: ../../installing.rst:350
msgid ""
"If you need to generate PDF reports, you can use the XLS based report "
"generator and you will need to download and install `Apache FOP "
"<http://xmlgraphics.apache.org/fop/>`_.  After extracting the FOP archive"
" you will need to include the directory you extracted to in your PATH."
msgstr ""
"PDF 보고서를 생성해야 하는 경우 XLS 기반 보고서 생성기를 사용할 수 있으며 Apache FOP http://xmlgraphics."
"apache.org/fop/'을 다운로드하여 설치해야 합니다.  FOP 아카이브를 추출한 후에는 추출한 디렉터리를 PATH에 포함해야 "
"합니다."

#: ../../installing.rst:355
msgid ""
"If you choose for PostScript reports, you can use the Mako based report "
"generator and there are no further dependencies."
msgstr "PostScript 리포트를 선택하는 경우 Mako 기반 리포트 생성기를 사용할 수 있으며 추가 종속성은 없습니다."

#: ../../installing.rst:363
msgid "Installing on Android"
msgstr "Android에서 설치"

#: ../../installing.rst:365
msgid ""
"``ghini.desktop`` is a desktop program, obviously you don't install it on"
" a handheld device, but we do offer the option, for your Android phone or"
" tablet, to install ``ghini.pocket``."
msgstr ""
"\"ghini.desktop\"은 데스크탑 프로그램으로, 휴대용 장치에 설치하지 않는 것은 분명하지만, 우리는 여러분의 안드로이드 폰이나 "
"태블릿에 \"ghini\"를 설치할 수 있는 옵션을 제공합니다.호주머니에 넣다."

#: ../../installing.rst:368
msgid ""
"``ghini.pocket`` is a small data viewer, it comes handy if you want to "
"have a quick idea of a plant species, its source, and date it entered the"
" garden, just by scanning a plant label."
msgstr ""
"''기니''포켓몬스터란 작은 데이터 뷰어로서 식물 종과 그 근원, 그리고 식물 라벨 스캔만으로 정원에 들어온 날짜를 간단히 알 수 있으면 "
"편리합니다."

#: ../../installing.rst:371
msgid ""
"Installation is as easy as it can be: just `look for it in Google Play "
"<https://play.google.com/store/apps/details?id=me.ghini.pocket>`_, and "
"install it."
msgstr ""
"구글플레이(https://play.google.com/store/apps/details?id=me.ghini.pocket)에서 찾아 "
"설치하면 된다."

#: ../../installing.rst:374
msgid ""
"Export the data from ``ghini.desktop`` to pocket format, copy it to your "
"device, enjoy."
msgstr "데이터를 \"ghini.desktop\"에서 포켓 포맷으로 내보내고 장치에 복사하여 즐기십시오."

#: ../../propagations.rst:4
msgid "Dealing with Propagations"
msgstr "전파 처리"

#: ../../propagations.rst:6
msgid ""
"Ghini offers the possibility to associate Propagations trials to Plants "
"and to document their treatments and results. Treatments are integral "
"parts of the description of a Propagation trial. If a Propagation trial "
"is successful, Ghini lets you associate it to a new Accession. You can "
"only associate one Accession to a Propagation Trial."
msgstr ""
"Ghini는 전파 실험을 식물과 연관시키고 그 치료와 결과를 문서화할 수 있는 가능성을 제공한다. 치료는 전파 평가판에 대한 설명에서 "
"필수적인 부분입니다. 전파 평가판이 성공하면 Ghini를 통해 새 등록에 연결할 수 있습니다. 하나의 등록만 전파 평가판에 연결할 수 "
"있습니다."

#: ../../propagations.rst:12
msgid "Here we describe how you use this part of the interface."
msgstr "여기서는 인터페이스의 이 부분을 사용하는 방법에 대해 설명합니다."

#: ../../propagations.rst:15
msgid "Creating a Propagation"
msgstr "전파 생성"

#: ../../propagations.rst:17
msgid ""
"A Propagation (trial) is obtained from a Plant. Ghini reflects this in "
"its interface: you select a plant, open the Plant Editor on it, activate "
"the Propagation Tab, click on Add."
msgstr ""
"식물로부터 전파(시험)를 얻는다. Ghini는 이 인터페이스를 반영합니다. 식물을 선택하고, 식물 편집기를 열고, 전파 탭을 활성화하고, "
"추가를 클릭합니다."

#: ../../propagations.rst:21
msgid ""
"When you do the above, you get a Propagation Editor window. Ghini does "
"not consider Propagation trials as independent entities. As a result, "
"Ghini treats the Propagation Editor as a special editor window, which you"
" can only reach from the Plant Editor."
msgstr ""
"위의 작업을 수행할 때 전파 편집기 창이 나타납니다. Ghini는 전파 시행을 독립적인 개체로 간주하지 않습니다. 따라서 Ghini는 "
"전파 편집기를 특수 편집기 창으로 간주하며, 이 창은 식물 편집기에서만 연결할 수 있습니다."

#: ../../propagations.rst:26
msgid ""
"For a new Propagation, you select the type of propagation (this becomes "
"an immutable property of the propagation) then insert the data describing"
" it."
msgstr "새 전파의 경우 전파 유형(이것은 전파의 불변 속성이 됨)을 선택한 다음 이를 설명하는 데이터를 삽입합니다."

#: ../../propagations.rst:29
msgid ""
"You will be able to edit the propagation data via the same path: select a"
" plant, open the Plant Editor, identify the propagation you want to edit,"
" click on the corresponding Edit button. You will be able to edit all "
"properties of an existing Propagation trial, except its type."
msgstr ""
"동일한 경로를 통해 전파 데이터를 편집할 수 있습니다. 공장을 선택하고, 공장 편집기를 열고, 편집할 전파를 식별하고, 해당 편집 버튼을 "
"클릭합니다. 유형을 제외한 기존 전파 평가판의 모든 속성을 편집할 수 있습니다."

#: ../../propagations.rst:34
msgid ""
"In the case of a seed propagation trial, you have a pollen parent, and a "
"seed parent. You should always associate the Propagation trial to the "
"seed parent."
msgstr "씨앗 전파 실험의 경우, 꽃가루 부모, 그리고 씨앗 부모가 있습니다. 전파 평가판을 항상 시드 부모에 연결해야 합니다."

#: ../../propagations.rst:38
msgid ""
"In Ghini-1.0 you specify the pollen parent plant in the \"Notes\" field, "
"while Ghini-1.1 has a (relation) field for it. According to ITF2, there "
"might be cases in seed propagation trials where it is not known which "
"Plant plays which role. Again, in Ghini-1.0 you should use a note to "
"indicate whether this is the case, Ghini-1.1 has a (boolean) field "
"indicating whether this is the case."
msgstr ""
"Ghini-1.0에서는 \"Notes\" 필드에 꽃가루 부모 식물을 지정하는 반면, Ghini-1.1에서는 꽃가루 부모 식물을 위한 "
"(관계) 필드가 있습니다. ITF2에 따르면, 어떤 식물이 어떤 역할을 하는지 알 수 없는 종자 전파 시험 사례가 있을 수 있다. 다시, "
"Ghini-1.0에서는 메모를 사용하여 이 경우인지 여부를 나타내야 합니다. Ghini-1.1에는 이 경우인지 여부를 나타내는 (부울) "
"필드가 있습니다."

#: ../../propagations.rst:47
msgid "Using a Propagation"
msgstr "전파 사용"

#: ../../propagations.rst:49
msgid "A Propagation trial may be successful and result in a new Accession."
msgstr "전파 평가판이 성공하여 새 등록으로 이어질 수 있습니다."

#: ../../propagations.rst:51
msgid ""
"Ghini helps you reflect this in the database: create a new Accession, "
"immediately switch to the Source tab and select \"Garden Propagation\" in"
" the (admittedly somewhat misleading) Contact field."
msgstr ""
"Ghini는 새 등록 문서를 작성하고 즉시 원본 탭으로 전환한 후 (일부 오해의 소지가 있는) 연락처 필드에서 \"정원 전파\"를 "
"선택합니다."

#: ../../propagations.rst:55
msgid ""
"Start typing the plant number and a list of matching plants with "
"propagation trials will appear for you to select from."
msgstr "공장 번호 입력을 시작하면 선택할 수 있는 전파 시행과 일치하는 공장 목록이 나타납니다."

#: ../../propagations.rst:58
msgid ""
"Select the plant, and the list of accessed and unaccessed propagation "
"trials will appear in the lower half of the window."
msgstr "공장을 선택하면 액세스 및 액세스되지 않은 전파 시행 목록이 창 아래쪽에 나타납니다."

#: ../../propagations.rst:61
msgid ""
"Select a still unaccessed propagation trial from the list and click on Ok"
" to complete the operation."
msgstr "목록에서 액세스되지 않은 전파 평가판을 선택하고 확인을 클릭하여 작업을 완료합니다."

#: ../../propagations.rst:64
msgid ""
"Using the data from the Propagation trial, Ghini completes some of the "
"fields in the General tab: Taxon name, Type of material, and possibly "
"Provenance. You will be able to edit these fields, but please note that "
"the software will not prevent introducing conceptual inconsistencies in "
"your database."
msgstr ""
"Ghini는 전파 평가판의 데이터를 사용하여 일반 탭의 일부 필드를 완료합니다. 세금 명, 재료 유형 및 입증 가능성. 이러한 필드를 "
"편집할 수 있지만, 소프트웨어에서 데이터베이스에 개념적 불일치를 초래하는 것을 방지하지는 않습니다."

#: ../../propagations.rst:70
msgid "You can associate a Propagation trial to only one Accession."
msgstr "전파 평가판을 하나의 등록에만 연결할 수 있습니다."

#: ../../report.rst:2
msgid "Generating reports"
msgstr "보고서 생성"

#: ../../report.rst:4
msgid ""
"A database without exporting facilities is of little use.  Ghini lets you"
" export your data in table format (open them in your spreadsheet editor "
"of choice), as labels (to be printed or engraved), as html pages or pdf "
"or postscript documents."
msgstr ""
"설비를 수출하지 않는 데이터베이스는 거의 쓸모가 없다.  Ghini를 사용하면 데이터를 테이블 형식(선택한 스프레드시트 편집기에서 열림)"
", 레이블(인쇄 또는 새겨짐), HTML 페이지 또는 pdf 또는 postscript 문서로 내보낼 수 있습니다."

#: ../../report.rst:10
msgid "The Report Tool"
msgstr "보고서 도구"

#: ../../report.rst:12
msgid ""
"You activate the Report Tool from the main menu: "
":menuselection:`Tools-->Report`.  The Report Tools acts on a selection, "
"so first select something, then start the Report Tool."
msgstr ""
"메인 메뉴: 메뉴 선택:에서 Report Tool을 활성화합니다.'도구-->보고서'입니다.  보고서 도구는 선택 항목에 따라 작동하므로 "
"먼저 항목을 선택한 다음 보고서 도구를 시작합니다."

#: ../../report.rst:15
msgid "Report on the whole collection."
msgstr "전체 컬렉션에 대해 보고합니다."

#: ../../report.rst:18
msgid ""
"To produce a report on your whole plant collection, a shortcut would be "
"from the home screen, to click on the ``Families: in use`` cell."
msgstr ""
"당신의 전체 식물 수집에 대한 보고서를 작성하기 위해서는 홈 스크린에서 ``가족: 사용 중\" 셀을 클릭하는 지름길이 될 것이다."

#: ../../report.rst:21
msgid ""
"If your focus is more on the garden location than on taxonomy and "
"accessions, you would click on the ``Locations: total`` cell."
msgstr "분류법이나 접근법보다는 정원 위치에 초점을 맞추면 ''위치: 총계'' 셀을 클릭하게 된다."

#: ../../report.rst:24
msgid ""
"Reports are produced by a report engine, making use of a report template."
"  Ghini relies upon two different report engines (Mako & XSL), and offers"
" several report templates, meant as usable examples."
msgstr ""
"보고서는 보고서 템플릿을 사용하여 보고서 엔진에 의해 생성됩니다.  Ghini는 두 개의 다른 보고서 엔진(Mako & XSL)에 "
"의존하며 사용 가능한 예로서 여러 보고서 템플릿을 제공한다."

#: ../../report.rst:27
msgid ""
"Choose the report you need, specify parameters if required, and produce "
"the report.  Ghini will open the report in the associated application."
msgstr ""
"필요한 리포트를 선택하고 필요한 경우 매개 변수를 지정한 다음 리포트를 생성합니다.  Ghini가 관련 응용 프로그램에서 보고서를 엽니다."

#: ../../report.rst:30
msgid ""
"Configuring report templates, that's a task for who installs and "
"configures ghini at your institution. Basically, you create a template "
"name, indicating the report engine and specifying the template.  "
"Configured templates are static, once configured you are not expected to "
"alter them.  Only the special ``**scratch**`` template can be modified on"
" the fly."
msgstr ""
"보고서 템플릿을 구성하는 작업은 기관에 기니를 설치하고 구성하는 사용자를 위한 작업입니다. 기본적으로 보고서 엔진을 나타내고 템플릿을 "
"지정하는 템플릿 이름을 생성합니다.  구성된 템플릿은 정적 템플릿이므로 일단 구성한 후에는 변경할 필요가 없습니다.  특수 "
"``**스크래치**\" 템플릿만 즉시 수정할 수 있다."

#: ../../report.rst:35
msgid ""
"The remainder of this page provides technical information and links "
"regarding the formatter engines, and gives hints on writing report "
"templates.  Writing templates comes very close to writing a computer "
"program, and that's beyond the scope of this manual, but we have hints "
"that will definitely be useful to the interested reader."
msgstr ""
"이 페이지의 나머지 부분에서는 포맷터 엔진에 대한 기술 정보와 링크를 제공하고 보고서 템플릿 작성에 대한 힌트를 제공합니다.  쓰기 "
"템플릿은 컴퓨터 프로그램 작성에 매우 가까우며, 이 매뉴얼의 범위를 벗어납니다. 하지만 관심 있는 독자들에게는 분명히 유용할 힌트를 "
"가지고 있습니다."

#: ../../report.rst:42
msgid "Using the Mako Report Formatter"
msgstr "Mako Report Formatter 사용"

#: ../../report.rst:44
msgid ""
"The Mako report formatter uses the Mako template language for generating "
"reports. More information about Mako and its language can be found at "
"`makotemplates.org <http://www.makotemplates.org>`_."
msgstr ""
"Mako 보고서 포맷터는 보고서를 생성하기 위해 Mako 템플릿 언어를 사용합니다. 마코와 그 언어에 대한 자세한 내용은 http://"
"www.makotemplates.org에서 확인할 수 있다."

#: ../../report.rst:48
msgid ""
"The Mako templating system should already be installed on your computer "
"if Ghini is installed."
msgstr "Ghini가 설치된 경우 컴퓨터에 Mako 템플릿 시스템이 이미 설치되어 있어야 합니다."

#: ../../report.rst:51
msgid ""
"Creating reports with Mako is similar in the way that you would create a "
"web page from a template.  It is much simpler than the XSL Formatter(see "
"below) and should be relatively easy to create template for anyone with a"
" little but of programming experience."
msgstr ""
"Mako를 사용하여 리포트를 생성하는 방법은 템플릿에서 웹 페이지를 생성하는 방법과 유사합니다.  XSL Formatter(아래 참조)"
"보다 훨씬 간단하며, 프로그래밍 경험이 적은 사람을 위한 템플릿을 만드는 것이 비교적 쉬워야 한다."

#: ../../report.rst:56
msgid ""
"The template generator will use the same file extension as the template "
"which should indicate the type of output the template with create.  For "
"example, to generate an HTML page from your template you should name the "
"template something like `report.html`.  If the template will generate a "
"comma separated value file you should name the template `report.csv`."
msgstr ""
"템플릿 생성기는 템플릿과 동일한 파일 확장명을 사용하며 템플릿 생성 시 출력 유형을 나타냅니다.  예를 들어 템플릿에서 HTML 페이지를 "
"생성하려면 템플릿의 이름을 'report.html'과 같이 지정해야 합니다.  템플릿에서 쉼표로 구분된 값 파일을 생성하는 경우 템플릿의 "
"이름을 'report.csv'로 지정해야 합니다."

#: ../../report.rst:63
msgid ""
"The template will receive a variable called `values` which will contain "
"the list of values in the current search."
msgstr "템플릿은 현재 검색의 값 목록을 포함하는 'values'라는 변수를 수신합니다."

#: ../../report.rst:66
msgid ""
"The type of each value in `values` will be the same as the search domain "
"used in the search query.  For more information on search domains see "
":ref:`search-domains`."
msgstr "값에서 각 값의 유형은 검색 질의에 사용되는 검색 도메인과 동일합니다.  검색 도메인에 대한 자세한 내용은 다음을 참조하십시오."

#: ../../report.rst:70
msgid ""
"If the query does not have a search domain then the values could all be "
"of a different type and the Mako template should prepared to handle them."
msgstr "쿼리에 검색 도메인이 없는 경우 값은 모두 다른 유형일 수 있으며 Mako 템플릿이 이를 처리할 준비를 해야 합니다."

#: ../../report.rst:76
msgid "Using the XSL Report Formatter"
msgstr "XSL 보고서 포맷터 사용"

#: ../../report.rst:78
msgid ""
"The XSL report formatter requires an XSL to PDF renderer to convert the "
"data to a PDF file. Apache FOP is is a free and open-source XSL->PDF "
"renderer and is recommended."
msgstr ""
"XSL 보고서 포맷터에는 데이터를 PDF 파일로 변환하려면 XSL에서 PDF 렌더러가 필요합니다. Apache FOPis는 자유-오픈 "
"소스 XSL->PDF 렌더러이며 권장된다."

#: ../../report.rst:82
msgid ""
"If using Linux, Apache FOP should be installable using your package "
"manager.  On Debian/Ubuntu it is installable as ``fop`` in Synaptic or "
"using the following command::"
msgstr ""
"Linux를 사용하는 경우 Apache FOP는 패키지 관리자를 사용하여 설치할 수 있어야 합니다.  Debian/Ubuntu에서는 다음 "
"명령을 사용하여 \"opp\"로 설치할 수 있습니다::"

#: ../../report.rst:90
msgid "Installing Apache FOP on Windows"
msgstr "윈도우즈에 Apache FOP 설치"

#: ../../report.rst:92
msgid ""
"You have two options for installing FOP on Windows. The easiest way is to"
" download the prebuilt `ApacheFOP-0.95-1-setup.exe "
"<http://code.google.com/p/apache-fop-"
"installer/downloads/detail?name=ApacheFOP-0.95-1-setup.exe&can=2&q=#makechanges>`_"
" installer."
msgstr ""
"Windows에 FOP를 설치하는 두 가지 옵션이 있습니다. 가장 쉬운 방법은 미리 제작된 ApacheFOP-0.95-1- 설정을 "
"다운로드하는 것이다.exe http://code.google.com/p/apache-fop-installer/downloads/"
"detail?name=ApacheFOP-0.95-1-setup.exe&can=2&q= #make changes''_ 설치 관리자."

#: ../../report.rst:95
msgid ""
"Alternatively you can download the `archive "
"<http://www.apache.org/dist/xmlgraphics/fop/binaries/>`_.  After "
"extracting the archive you must add the directory you extracted the "
"archive to to your PATH environment variable."
msgstr ""
"또는 http://www.apache.org/dist/xmlgraphics/fop/binaries/'을 다운로드할 수 있습니다.  보관 "
"파일을 추출한 후 보관 파일을 추출한 디렉토리를 PATH 환경 변수에 추가해야 합니다."

#: ../../searching.rst:4
msgid "Searching in Ghini"
msgstr "기니에서 검색"

#: ../../searching.rst:6
msgid ""
"Searching allows you to view, browse and create reports from your data. "
"You can perform searches by either entering the queries in the main "
"search entry or by using the Query Builder to create the queries for you."
" The results of Ghini searches are listed in the main window."
msgstr ""
"검색을 통해 데이터에서 보고서를 보고, 찾아보고, 만들 수 있습니다. 기본 검색 항목에 쿼리를 입력하거나 쿼리 작성기를 사용하여 쿼리를 "
"만들어 검색을 수행할 수 있습니다. Ghini 검색 결과는 기본 창에 나열됩니다."

#: ../../searching.rst:13
msgid "Search Strategies"
msgstr "검색 전략"

#: ../../searching.rst:15
msgid "Ghini offers four distinct search strategies:"
msgstr "Ghini는 다음과 같은 네 가지 검색 전략을 제공합니다:"

#: ../../searching.rst:17
msgid "by value — in all domains;"
msgstr "값 기준 — 모든 도메인에서;"

#: ../../searching.rst:18
msgid "by expression — in a few implicit fields in one explicit domain;"
msgstr "표현에 의해 — 하나의 명시적 도메인에 있는 몇 개의 암시적 필드에;"

#: ../../searching.rst:19
msgid "by query — in one domain;"
msgstr "쿼리 기준 - 하나의 도메인에서;"

#: ../../searching.rst:20
msgid "by binomial name — only searches the Species domain."
msgstr "이항 이름 기준 - 종 도메인만 검색합니다."

#: ../../searching.rst:22
msgid ""
"All search strategies —with the notable exception of the binomial name "
"search— are case insensitive."
msgstr "이항 이름 검색을 제외하고 모든 검색 전략은 대소문자를 구분하지 않습니다."

#: ../../searching.rst:27
msgid "Search by Value"
msgstr "값별 검색"

#: ../../searching.rst:29
msgid ""
"Search by value is the simplest way to search. You enter one or more "
"strings and see what matches. The result includes objects of any type "
"(domain) where one or more of its fields contain one or more of the "
"search strings."
msgstr ""
"값으로 검색하는 것이 가장 간단한 방법입니다. 하나 이상의 문자열을 입력하고 일치하는 항목을 확인합니다. 결과에는 하나 이상의 필드에 "
"하나 이상의 검색 문자열이 포함된 모든 유형의 개체(도메인)가 포함됩니다."

#: ../../searching.rst:33
msgid ""
"You don't specify the search domain, all are included, nor do you "
"indicate which fields you want to match, this is implicit in the search "
"domain."
msgstr "검색 도메인을 지정하지 않고 모두 포함되며 일치시킬 필드를 표시하지 않습니다. 이 필드는 검색 도메인에 암시적입니다."

#: ../../searching.rst:36
msgid ""
"The following table helps you understand the results and guides you in "
"formulating your searches."
msgstr "다음 표는 결과를 이해하는 데 도움이 되며 검색을 공식화하는 데 도움이 됩니다."

#: ../../searching.rst:42
msgid "search domain overview"
msgstr "검색 도메인 개요"

#: ../../searching.rst:44
msgid "name and shorthands"
msgstr "이름과 속기"

#: ../../searching.rst:44
msgid "field"
msgstr "밭을 갈다"

#: ../../searching.rst:44
msgid "result type"
msgstr "결과형"

#: ../../searching.rst:49 ../../searching.rst:50 ../../searching.rst:54
#: ../../searching.rst:56
msgid "name"
msgstr "이름을 짓다"

#: ../../searching.rst:59
msgid ""
"Examples of searching by value would be: Maxillaria, Acanth, 2008.1234, "
"2003.2.1, indica."
msgstr "값으로 검색하는 예로는 Maxillaria, Acanth, 2008.1234, 2003.2.1, indicata가 있습니다."

#: ../../searching.rst:62
msgid ""
"Unless explicitly quoted, spaces separate search strings. For example if "
"you search for ``Block 10`` then Ghini will search for the strings Block "
"and 10 and return all the results that match either of these strings. If "
"you want to search for Block 10 as one whole string then you should quote"
" the string like ``\"Block 10\"``."
msgstr ""
"명시적으로 따옴표가 지정되지 않은 경우 공백은 검색 문자열을 구분합니다. 예를 들어 \"Block 10\"을 검색하면 Ghini는 "
"Block 및 10 문자열을 검색하여 이 문자열 중 하나에 일치하는 결과를 모두 반환합니다. 블록 10을 하나의 전체 문자열로 검색하려면 "
"\"블록 10\"과 같은 문자열을 따옴표로 묶어야 합니다."

#: ../../searching.rst:68
msgid "× Composite Primary Keys"
msgstr "× 복합 기본 키"

#: ../../searching.rst:71
msgid ""
"A **species** epithet means little without the corresponding genus, "
"likewise a **planting** code is unique only within the accession to which"
" it belongs.  In database theory terminology, epithet and code are not "
"sufficient to form a **primary key** for respectively species and "
"planting. These domains need a **composite** primary key."
msgstr ""
"**종*** 부호는 해당 속 없이 별 의미가 없으며, 마찬가지로 **식물* 코드는 해당 부호가 속한 등록 내에서만 고유하다.  "
"데이터베이스 이론 용어에서, 각 종과 식물에 대해 **기본 키***를 구성하기에는 상피와 코드가 충분하지 않다. 이러한 도메인에는 "
"**복합** 기본 키가 필요합니다."

#: ../../searching.rst:78
msgid ""
"Search by value lets you look for **plantings** by their complete "
"planting code, which includes the accession code. Taken together, "
"Accession code and Planting code do provide a **composite primary key** "
"for plantings.  For **species**, we have introduced the binomial search, "
"described below."
msgstr ""
"값으로 검색하면 등록 코드가 포함된 전체 심기 코드로 **심기**를 찾을 수 있습니다. 등록 코드와 식재 코드는 식물에 **복합 기본 "
"키**를 제공합니다.  **종**의 경우 아래에 설명된 이항 검색을 도입했습니다."

#: ../../searching.rst:86
msgid "Search by Expression"
msgstr "식을 기준으로 검색"

#: ../../searching.rst:88
msgid ""
"Searching with expression gives you a little more control over what you "
"are searching for. You narrow the search down to a specific domain, the "
"software defines which fields to search within the domain you specified."
msgstr ""
"식을 사용하여 검색하면 검색 중인 항목을 조금 더 제어할 수 있습니다. 검색 범위를 특정 도메인으로 좁히면 소프트웨어는 지정한 도메인 "
"내에서 검색할 필드를 정의합니다."

#: ../../searching.rst:92
msgid ""
"An expression is built as ``<domain> <operator> <value>``. For example "
"the search: ``gen=Maxillaria`` would return all the genera that match the"
" name Maxillaria. In this case the domain is ``gen``, the operator is "
"``=`` and the value is ``Maxillaria``."
msgstr ""
"식은 \"<domain> <operator> <value>\"로 작성됩니다. 예를 들어 \"gen=Maxillaria\"를 검색하면 "
"Maxillaria라는 이름에 일치하는 모든 gen이 반환됩니다. 이 경우 도메인은 ''gen², 연산자는 ''=maxilaria', "
"값은 ''Maxillaria'\"이다."

#: ../../searching.rst:97
msgid ""
"The above search domain overview table tells you the names of the search "
"domains, and, per search domain, which fields are searched."
msgstr "위의 검색 도메인 개요 표는 검색 도메인의 이름 및 검색 도메인별로 검색되는 필드를 알려줍니다."

#: ../../searching.rst:100
#, python-format
msgid ""
"The search string ``loc like block%`` would return all the Locations for "
"which name or code start with \"block\".  In this case the domain is "
"``loc`` (a shorthand for ``location``), the operator is ``like`` (this "
"comes from SQL and allows for \"fuzzy\" searching), the value is "
"``block%``, the implicitly matched fields are ``name`` and ``code``.  The"
" percent sign is used as a wild card so if you search for ``block%`` then"
" it searches for all values that start with ``block``.  If you search for"
" ``%10`` it searches for all values that end in ``10``.  The string "
"``%ck%10`` would search for all value that contain ``ck`` and end in "
"``10``."
msgstr ""
"검색 문자열 \"loc like block%\"는 이름 또는 코드가 \"block\"으로 시작하는 모든 위치를 반환합니다.  이 경우 "
"도메인이 ''loc''('위치'의 약자)이고, 연산자는 ''like''(이것은 SQL에서 왔으며 'fuzzy' 검색을 허용한다)이며, "
"값은 암시적으로 일치하는 필드가 \"name\"과 \"code\"인 경우 \"block%\"이다.  백분율 기호는 와일드카드로 사용되므로 "
"''블록%''를 검색하면 ''블록''으로 시작하는 모든 값을 검색합니다.  \"%10\"을 검색하면 \"10\"으로 끝나는 모든 값을 "
"검색합니다.  \"%ck%10\"이라는 문자열은 \"ck\"가 포함된 모든 값을 검색하여 \"10\"으로 끝난다."

#: ../../searching.rst:110
msgid "When a query takes ages to complete"
msgstr "쿼리를 완료하는 데 시간이 오래 걸리는 경우"

#: ../../searching.rst:113
msgid ""
"You give a query, it takes time to compute, the result contains "
"unreasonably many entries.  This happens when you intend to use a "
"strategy, but your strings do not form a valid expression.  In this case "
"Ghini falls back to *search by value*. For example the search string "
"``gen lik maxillaria`` will search for the strings ``gen``, ``lik``, and "
"``maxillaria``, returning all that match at least one of the three "
"criteria."
msgstr ""
"쿼리를 제공하고 계산하는 데 시간이 걸리며 결과에 너무 많은 항목이 포함되어 있습니다.  이 문제는 전략을 사용하려고 하지만 문자열이 "
"올바른 식을 형성하지 않을 때 발생합니다.  이 경우 Ghini는 *값별 검색*으로 돌아갑니다. 예를 들어 검색 문자열인 \"gen "
"like maxillaria\"는 \"gen\", \"lik\", \"maxillaria\" 중 적어도 세 가지 기준 중 하나와 일치하는 "
"모든 문자열을 검색하게 된다."

#: ../../searching.rst:122
msgid "Binomial search"
msgstr "이항 검색"

#: ../../searching.rst:124
msgid ""
"You can also perform a search in the database if you know the species, "
"just by placing a few initial letters of genus and species epithets in "
"the search engine, correctly capitalized, i.e.: **Genus epithet** with "
"one leading capital letter, **Species epithet** all lowercase."
msgstr ""
"또한 해당 종을 알고 있는 경우 검색 엔진에 몇 개의 초기 문자(예: 대문자 표시)를 올바르게 배치하면 데이터베이스에서 검색을 수행할 수 "
"있습니다. **Genus spitm**의 대문자 **종류 spitm* 모두 소문자입니다."

#: ../../searching.rst:129
msgid "This way you can perform the search ``So ha``."
msgstr "이렇게 하면 \"소하\" 검색을 수행할 수 있습니다."

#: ../../searching.rst:131
msgid "These would be the initials for Solanum hayesii, or Solanum havanense."
msgstr "이것은 Solanum hayesii 또는 Solanum havanense의 이니셜이 될 것이다."

#: ../../searching.rst:133
msgid ""
"Binomial search comes to compensate the limited usefulness of the above "
"search by expression when trying to look for a species."
msgstr "이항 검색은 종을 검색하려고 할 때 표현으로 위의 검색의 제한된 유용성을 보상하기 위해 제공됩니다."

#: ../../searching.rst:136
msgid ""
"It is the correct capitalization **Xxxx xxxx** that informs the software "
"of your intention to perform a binomial search.  The software's second "
"guess will be a search by value, which will possibly result in far more "
"matches than you had expected."
msgstr ""
"이항 검색을 수행할 의도를 소프트웨어에 알려주는 올바른 대문자로 **Xxxxxx**입니다.  소프트웨어의 두 번째 추측은 값별 검색으로, "
"예상한 것보다 훨씬 더 많은 일치 항목이 발생할 수 있습니다."

#: ../../searching.rst:141
msgid ""
"The similar request ``so ha`` will return, in a fresh install, over 3000 "
"objects, starting at Family \"Acalyp(**ha**)ceae\", ending at Geography "
"\"Western (**So**)uth America\"."
msgstr ""
"비슷한 요청인 \"소하\"는 \"Acalyp (**ha***)ceae\"에서 시작하여 지리 \"서양 (*****)남미\"에서 끝나는 "
"3000개 이상의 객체로 새로 설치될 것이다."

#: ../../searching.rst:147
msgid "Search by Query"
msgstr "조회별 검색"

#: ../../searching.rst:149
msgid ""
"Queries allow the most control over searching. With queries you can "
"search across relations, specific columns, combine search criteria using "
"boolean operators like ``and``, ``or``, ``not`` (and their shorthands "
"``&&``, ``||``, ``!``), enclose them in parentheses, and more."
msgstr ""
"쿼리를 사용하면 검색을 최대한 제어할 수 있습니다. 여러 관계에 걸쳐 검색할 수 있는 질의와 함께 특정 열을 검색하고 ``and\", "
"\"or\", \"not\", \"not\" 등의 부울 연산자를 사용하여 검색 기준을 결합할 수 있으며, 이들의 속어인 \"&&&n't\""
"(\"|\", \"!\")는 괄호 안에 묶을 수 있다."

#: ../../searching.rst:154
msgid ""
"Please contact the authors if you want more information, or if you "
"volunteer to document this more thoroughly.  In the meanwhile you may "
"start familiarizing yourself with the core structure of Ghini's database."
msgstr ""
"더 많은 정보를 원하거나 이 내용을 더 철저히 문서화할 경우 작성자에게 문의하십시오.  그 동안 여러분은 기니의 데이터베이스의 핵심 "
"구조를 익히기 시작할 수 있습니다."

#: ../../searching.rst:162
msgid "A few examples:"
msgstr "몇 가지 예:"

#: ../../searching.rst:164
msgid "plantings of family Fabaceae in location Block 10::"
msgstr "위치 블록 10에 있는 파바과(Fabaceae) 패밀리의 심기:"

#: ../../searching.rst:168
msgid "locations that contain no plants::"
msgstr "발전소가 없는 위치:"

#: ../../searching.rst:172
msgid ""
"accessions associated to a species of known binomial name (e.g.: "
"Mangifera indica)::"
msgstr "알려진 이항 이름의 종과 관련된 접근법(예: 망기페라 표시기::"

#: ../../searching.rst:176
msgid "accessions we propagated in the year 2016::"
msgstr "2016년에 전파된 액세스:"

#: ../../searching.rst:180
msgid "accessions we modified in the last three days::"
msgstr "지난 3일 동안 수정한 액세스 권한:"

#: ../../searching.rst:184
msgid ""
"Searching with queries requires some knowledge of a little syntax and an "
"idea of the extensive Ghini database table structure. Both you acquire "
"with practice, and with the help of the Query Builder."
msgstr ""
"쿼리를 사용하여 검색하려면 약간의 구문과 광범위한 Ghini 데이터베이스 테이블 구조에 대한 아이디어가 필요합니다. 두 가지 모두 연습과 "
"쿼리 작성기의 도움을 통해 습득합니다."

#: ../../searching.rst:190
msgid "The Query Builder"
msgstr "쿼리 작성기"

#: ../../searching.rst:192
msgid ""
"Ghini offers a Query Builder, that helps you build complex search queries"
" through a point and click interface.  To open the Query Builder click "
"the |querybuilder| icon to the left of the search entry or select "
":menuselection:`Tools-->Query Builder` from the menu."
msgstr ""
"Ghini는 포인트와 클릭 인터페이스를 통해 복잡한 검색 쿼리를 만들 수 있는 쿼리 작성기를 제공합니다.  쿼리 작성기를 열려면 검색 "
"항목 왼쪽에 있는 |querybuilder| 아이콘을 클릭하거나 : 메뉴 선택:메뉴에서 'Tools-->Query Builder'를 "
"선택합니다."

#: ../../searching.rst:201
msgid ""
"A window will show up, which will lead you through all steps necessary to"
" construct a correct query that is understood by Ghini's Query Search "
"Strategy."
msgstr "Ghini의 쿼리 검색 전략에 의해 이해되는 올바른 쿼리를 구성하는 데 필요한 모든 단계를 안내하는 창이 나타납니다."

#: ../../searching.rst:210
msgid ""
"First of all you indicate the search domain, this will allow the Query "
"Builder complete its graphical user interface, then you add as many "
"logical clauses as you need, connecting them with a ``and`` or ``or`` "
"binary operator."
msgstr ""
"먼저 검색 도메인을 나타내면 쿼리 작성기가 그래픽 사용자 인터페이스를 완료할 수 있으며, 필요한 만큼 논리 절을 추가하여 \"and\" "
"또는 \"or\" 이진 연산자와 연결합니다."

#: ../../searching.rst:215
msgid ""
"Each clause is formed of three parts: a property that can be reached from"
" the starting search domain, a comparison operator that you select from "
"the drop-down list, a value that you can either type or select from the "
"list of valid values for the field."
msgstr ""
"먼저 검색 도메인을 나타내면 쿼리 작성기가 그래픽 사용자 인터페이스를 완료할 수 있으며, 필요한 만큼 논리 절을 추가하여 \"and\" "
"또는 \"or\" 이진 연산자와 연결합니다."

#: ../../searching.rst:220
msgid ""
"Add as many search properties as you need, by clicking on the plus sign. "
"Select and/or next to the property name to choose how the clauses will be"
" combined in the search query."
msgstr ""
"더하기 기호를 클릭하여 필요한 만큼의 검색 속성을 추가합니다. 속성 이름 옆에 및/또는 항목을 선택하여 검색 질의에서 절의 결합 방법을 "
"선택합니다."

#: ../../searching.rst:224
msgid "When you are done building your query click OK to perform the search."
msgstr "쿼리를 작성했으면 확인을 클릭하여 검색을 수행합니다."

#: ../../searching.rst:226
msgid ""
"At this point the Query Builder writes the query in the search entry, and"
" executes it. You may now edit the string as if you had typed it "
"yourself. Notice how the left hand side values are interpreted by the "
"query builder and enclosed in single quotes if recognized as strings, "
"left alone if they look like numbers or the two reserved words ``None`` "
"and ``Empty``. You may edit the query and insert quotes if you need them,"
" eg if you need to literally look for the string ``Empty``."
msgstr ""
"이때 쿼리 작성기는 검색 항목에 쿼리를 작성하고 실행합니다. 이제 문자열을 직접 입력한 것처럼 편집할 수 있습니다. 왼쪽 값은 쿼리 "
"작성기에 의해 해석되고 문자열로 인식되면 작은 따옴표로 묶이고 숫자처럼 보이면 내버려 두거나 \"없음\"과 \"비어 있음\"이라는 두 "
"개의 예약된 단어이다. 문자 그대로 \"빈\" 문자열을 찾아야 하는 경우 등 필요한 경우 쿼리를 편집하고 따옴표를 삽입할 수 있습니다."

#: ../../searching.rst:234
msgid ""
"``None`` is the value of an empty field. It is not the same as the zero "
"lenght string ``''`` nor the numeric ``0`` nor the boolean ``False`` nor "
"the set ``Empty``, it indicates that the field has no value at all."
msgstr ""
"\"없음\"은 빈 필드의 값입니다. 제로라이트 문자열 ''''''도 숫자 ''0''도 부울 '거짓'도 '빈'도 아닌 이 분야는 전혀 "
"가치가 없음을 나타낸다."

#: ../../searching.rst:238
msgid ""
"``Empty`` is the empty set. Being it a set, it can be matched against "
"sets (eg: plants of an accession, or accessions of a species), not "
"against elements (eg: quantity of a plant or description of a location). "
"However, the Query Builder does not let you choose a left hand side value"
" stopping at a set, it expects you to select a field. Choose just any "
"field: at the moment of producing the query, when the Query Builder meets"
" a clause with right hand side value the literal string ``Empty``, it "
"will drop the field name and let you compare the set on the left with "
"``Empty`` on the right."
msgstr ""
"'텅 빈'은 빈 집합이다. 집합이기 때문에 요소(예: 식물의 양 또는 위치의 설명)가 아닌 집합(예: 등록의 식물 또는 종의 접근)과 "
"일치할 수 있다. 그러나 쿼리 작성기는 집합에서 중지되는 왼쪽 값을 선택할 수 있도록 하지 않으며 필드를 선택할 것으로 예상합니다. "
"임의의 필드만 선택하십시오. 쿼리를 생성하는 순간에 쿼리 작성기가 오른쪽 문자열이 \"비어 있음\"인 절을 만나면 필드 이름이 삭제되고 "
"왼쪽에 있는 집합을 오른쪽의 \"비어 있음\"과 비교할 수 있습니다."

#: ../../searching.rst:247
msgid ""
"We have no literals ``False`` and ``True``. These are typed values, and "
"the Query Builder does not know how to produce them. Instead of ``False``"
" type ``0``, and instead of ``True`` type ``1``."
msgstr ""
"우리에게는 문자 그대로의 '거짓'과 '참'이 없다. 이 값은 입력된 값이며 쿼리 작성기는 해당 값을 생성하는 방법을 알지 못합니다. "
"'거짓'이 아닌 '0', '진실'이 아닌 '1'이다."

#: ../../searching.rst:253
msgid "Query Grammar"
msgstr "Query Grammar"

#: ../../searching.rst:255
msgid ""
"For those who don't fear a bit of formal precision, the following BNF "
"code gives you a rather precise idea of the grammar implemented by the "
"Query Search Strategy.  Some grammatical categories are informally "
"defined; any missing ones are left to your fertile imagination; literals "
"are included in single quotes; the grammar is mostly case insensitive, "
"unless otherwise stated::"
msgstr ""
"공식적인 정밀도를 조금도 두려워하지 않는 사람들을 위해, 다음의 BNF 코드는 질의 검색 전략에 의해 구현된 문법에 대한 다소 정확한 "
"아이디어를 제공한다.  일부 문법 범주는 비공식적으로 정의되고, 누락된 범주는 여러분의 풍부한 상상력에 맡겨집니다. 리터럴은 작은 "
"인용문에 포함되어 있습니다. 문법은 다음과 같은 경우를 제외하고 대부분 대소문자를 구분하지 않습니다::"

#: ../../searching.rst:318
msgid ""
"Please be aware that Ghini's Query language is quite a bit more complex "
"than what the Query Builder can produce: Queries you can build with the "
"Query Builder form a proper subset of the queries recognized by the "
"software::"
msgstr ""
"Ghini의 Query 언어는 Query Builder가 생성할 수 있는 것보다 훨씬 더 복잡합니다. 쿼리 작성기로 작성할 수 있는 "
"쿼리는 소프트웨어가 인식하는 쿼리의 적절한 하위 집합을 구성합니다::"

#: ../../started.rst:2
msgid "Initial Configuration"
msgstr "초기 구성"

#: ../../started.rst:4
msgid ""
"After a successful installation, more complex organizations will need "
"configure their database, and configure Ghini according to their database"
" configuration. This page focuses on this task. If you don't know what "
"this is about, please do read the part relative to SQLite."
msgstr ""
"설치가 성공적으로 완료되면 보다 복잡한 조직에서 데이터베이스를 구성하고 데이터베이스 구성에 따라 Ghini를 구성해야 합니다. 이 "
"페이지는 이 작업에 초점을 맞춥니다. 무슨 내용인지 모르면 SQLite 관련 부분을 읽어주세요."

#: ../../started.rst:12
msgid "Should you SQLite?"
msgstr "SQLite를 해야 합니까?"

#: ../../started.rst:14
msgid ""
"Is this the first time you use Ghini, are you going to work in a stand-"
"alone setting, you have not the faintest idea how to manage a database "
"management system? If you answered yes to any of the previous, you "
"probably better stick with SQLite, the easy, fast, zero-administration "
"file-based database."
msgstr ""
"Ghini를 처음 사용하는 경우, 독립 실행형 환경에서 작업할 예정인데 데이터베이스 관리 시스템을 관리하는 방법을 전혀 모르십니까? "
"이전에 \"예\"라고 대답한 경우 쉽고 빠른 제로 관리 파일 기반 데이터베이스인 SQLite를 사용하는 것이 좋습니다."

#: ../../started.rst:20
msgid ""
"With SQLite, you do not need any preparation and you can continue with "
"`connecting`_."
msgstr "SQLite를 사용하면 아무런 준비도 필요하지 않으며 '연결'을 계속할 수 있습니다."

#: ../../started.rst:23
msgid ""
"On the other hand, if you want to connect more than one bauble "
"workstation to the same database, or if you want to make your data "
"available for other clients, as could be a web server in a LAMP setting, "
"you should consider keeping your database in a database management system"
" like `PostgreSQL <http://www.postgresql.org>`_ or `MySQL/MariaDB "
"<https://mariadb.org/>`_, both supported by Ghini."
msgstr ""
"반면, 둘 이상의 바우블 워크스테이션을 동일한 데이터베이스에 연결하거나 LAMP 설정에서 웹 서버일 수 있는 다른 클라이언트에서 데이터를 "
"사용할 수 있도록 하려면 데이터베이스를 \"Postgre\"와 같은 데이터베이스 관리 시스템에 보관하는 것을 고려해야 합니다.SQL "
"http://www.postgresql.org'_ 또는 'MySQL/MariaDB https://mariadb.org/'은 둘 다 "
"Ghini가 지원합니다."

#: ../../started.rst:30
msgid ""
"When connecting to a database server as one of the above, you have to "
"manually do the following: Create at least one user; Create your "
"database; Give at least one user full permissions on your database; If "
"you plan having more database users: Give one of your users the "
"``CREATEROLE`` privilege; Consider the user with the ``CREATEROLE`` "
"privilege as a super-user, not meant to handle data directly; Keep your "
"super-user credentials in a very safe place."
msgstr ""
"데이터베이스 서버에 위 중 하나로 연결할 때 수동으로 다음 작업을 수행해야 합니다. 하나 이상의 사용자 만들기, 데이터베이스 만들기, "
"데이터베이스에 대한 하나 이상의 사용자에게 전체 사용 권한 부여, 만약 당신이 더 많은 데이터베이스 사용자를 가질 계획이라면: 당신의 "
"사용자 중 한 명에게 \"CREATEROLE\" 권한을 부여하라; 데이터를 직접 처리하려는 것이 아니라 \"CREATEROLE\" 권한을 "
"가진 사용자를 수퍼유저로 간주하라; 당신의 수퍼유저 자격증은 매우 안전한 장소에 보관하라."

#: ../../started.rst:38
msgid ""
"When this is done, Ghini will be able to proceed, creating the tables and"
" importing the default data set.  The process is database-dependent and "
"it falls beyond the scope of this manual."
msgstr ""
"이 작업이 완료되면 Ghini가 계속 진행하여 테이블을 만들고 기본 데이터 세트를 가져올 수 있습니다.  프로세스는 데이터베이스에 따라 "
"다르며 이 매뉴얼의 범위를 벗어납니다."

#: ../../started.rst:42
msgid ""
"If you already got the chills or sick at your stomach, no need to worry, "
"just stick with SQLite, you do not miss on features nor performance."
msgstr "이미 위가 오싹하거나 아프면 걱정할 필요 없이 SQLite만 고수하면 기능이나 성능을 놓치지 않습니다."

#: ../../started.rst:45
msgid "Some more hints if you need PostgreSQL"
msgstr "Postgre가 필요한 경우 추가 힌트SQL"

#: ../../started.rst:48
msgid ""
"Start simple, don't do all at the same time. Review `the online manual "
"<https://www.postgresql.org/docs/9.4/static/index.html>`_, or download "
"and study `the offline version "
"<https://www.postgresql.org/files/documentation/pdf/9.4/postgresql-9.4-A4.pdf>`_."
msgstr ""
"단순하게 시작하세요, 동시에 모든 것을 하지 마세요. 온라인 매뉴얼 https://www.postgresql.org/docs/9.4/"
"static/index.html을 검토하거나 오프라인 버전 https://www.postgresql.org/files/"
"documentation/pdf/9.4/postgresql-9.4-A4.pdf을 다운로드하여 학습한다."

#: ../../started.rst:53
msgid ""
"As said above, create a database, a user, make this user the owner of the"
" database, decide whether you're going to need multiple users, and "
"preferably reserve a user for database and normal user creation. This "
"super-user should be your only user with ``CREATEROLE`` privilege."
msgstr ""
"위에서 설명한 대로 데이터베이스를 만들고, 사용자를 데이터베이스의 소유자로 설정하고, 여러 명의 사용자가 필요한지 여부를 결정하며, "
"데이터베이스 및 일반 사용자 작성을 위해 사용자를 예약하는 것이 좋습니다. 이 수퍼유저는 \"CREATEROLE\" 권한이 있는 유일한 "
"사용자여야 합니다."

#: ../../started.rst:59
msgid ""
"All normal users will need all privileges on all tables and sequences, "
"something you can do from the :menuselection:`Tools-->Users` menu.  If "
"you have any difficulty, please `open an issue "
"<https://github.com/Ghini/ghini.desktop/issues/new>`_ about it."
msgstr ""
"모든 일반 사용자는 다음 메뉴 선택에서 수행할 수 있는 모든 테이블 및 시퀀스에 대한 모든 권한이 필요합니다.'도구-->사용자' "
"메뉴입니다.  어려운 점이 있으면 https://github.com/Ghini/ghini.desktop/issues/new을 열어 "
"주십시오."

#: ../../started.rst:65
msgid ""
"Connect using the ``psql`` interactive terminal.  Create a ``~/.pgpass`` "
"file (read more about it in `the manual "
"<https://www.postgresql.org/docs/9.4/static/libpq-pgpass.html>`_), tweak "
"your ``pg_hba.conf`` and ``postgresql.conf`` files, until you can connect"
" using the command::"
msgstr ""
"''psql'' 대화형 단자를 사용하여 연결합니다.  다음 명령을 사용하여 연결할 수 있을 때까지 ''~/.pgpassfilename "
"파일('manual https://www.postgresql.org/docs/9.4/static/libpq-pgpass.html'_에서 "
"자세히 보기)을 생성하고 ''pg_pg_postgresql.confilename 파일'을 수정합니다::"

#: ../../started.rst:73
msgid "With the above setup, connecting from ghini will be an obvious task."
msgstr "위의 설정으로 기니에서 연결하는 것은 명백한 작업이 될 것이다."

#: ../../started.rst:79
msgid "Connecting to a database"
msgstr "데이터베이스에 연결"

#: ../../started.rst:81
msgid ""
"When you start Ghini the first thing that comes up is the connection "
"dialog."
msgstr "Ghini를 시작할 때 가장 먼저 나타나는 것은 연결 대화 상자입니다."

#: ../../started.rst:84
msgid ""
"Quite obviously, if this is the first time you start Ghini, you have no "
"connections yet and Ghini will alert you about it."
msgstr "기니를 처음 시작하면 아직 연줄이 없습니다. 기니가 경고를 해 줄 겁니다."

#: ../../started.rst:89
msgid ""
"This alert will show at first activation and also in the future if your "
"connections list becomes empty. As it says: click on **Add** to create "
"your first connection."
msgstr ""
"이 알림은 처음 활성화될 때와 나중에 연결 목록이 비어 있는 경우에도 표시됩니다. 표시된 대로 **추가**를 클릭하여 첫 번째 연결을 "
"만듭니다."

#: ../../started.rst:95
msgid ""
"Just insert a name for your connection, something meaningful you "
"associate with the collection to be represented in the database (for "
"example: “my home garden”), and click on **OK**. You will be back to the "
"previous screen, but your connection name will be selected and the "
"Connection Details will have expanded."
msgstr ""
"데이터베이스에 표시할 컬렉션과 관련된 의미 있는 연결 이름(예: \"내 집 정원\")을 클릭하고 **OK**를 클릭합니다. 이전 화면으로 "
"돌아가지만 연결 이름이 선택되고 연결 세부 정보가 확장됩니다."

#: ../../started.rst:103
msgid "**specify the connection details**"
msgstr "**접속내역 확인**"

#: ../../started.rst:105
msgid ""
"If you do not know what to do here, Ghini will help you stay safe. "
"Activate the **Use default locations** check box and create your first "
"connection by clicking on **Connect**."
msgstr ""
"여기서 무엇을 해야 할지 모른다면, 기니는 여러분이 안전하게 지낼 수 있도록 도와줄 거예요. **기본 위치 사용** 확인란을 활성화하고 "
"**연결*을 클릭하여 첫 번째 연결을 만듭니다."

#: ../../started.rst:108
msgid ""
"You may safely skip the remainder of this section for the time being and "
"continue reading to the following section."
msgstr "당분간 이 섹션의 나머지 부분을 안전하게 건너뛰고 다음 섹션을 계속 읽으실 수 있습니다."

#: ../../started.rst:111
msgid "**fine-tune the connection details**"
msgstr "**접속내역 미세조정**"

#: ../../started.rst:113
msgid ""
"By default Ghini uses the file-based SQLite database.  During the "
"installation process you had the choice (and you still have after "
"installation), to add database connectors other than the default SQLite."
msgstr ""
"기본적으로 Ghini는 파일 기반 SQLite 데이터베이스를 사용합니다.  설치 프로세스 중에 기본 SQLite 이외의 데이터베이스 "
"커넥터를 추가할 수 있는 선택(설치 후에도 계속)이 있었습니다."

#: ../../started.rst:117
msgid ""
"In this example, Ghini can connect to SQLite, PostgreSQL and MySQL, but "
"no connector is available for Oracle or MS SQL Server."
msgstr ""
"이 예에서 Ghini는 SQLite, Postgre에 연결할 수 있습니다.SQL 및 MySQL이지만 Oracle 또는 MS SQL "
"Server에 사용할 수 있는 커넥터가 없습니다."

#: ../../started.rst:122
msgid ""
"If you use SQLite, all you really need specify is the connection name. If"
" you let Ghini use the default filename then Ghini creates a database "
"file with the same name as the connection and ``.db`` extension, and a "
"pictures folder with the same name and no extension, both in "
"``~/.bauble`` on Linux/MacOSX or in ``AppData\\Roaming\\Bauble`` on "
"Windows."
msgstr ""
"SQLite를 사용하는 경우 연결 이름만 지정하면 됩니다. 만약 당신이 Ghini가 기본 파일 이름을 사용하도록 한다면 Ghini는 "
"연결과 \".db\" 확장자와 이름이 같고 확장자가 없는 그림 폴더를 Linux/MacOSX의 \"~/.bauble\" 또는 "
"Windows의 \"AppData\\Roaming\\Bauble\"에서 생성한다."

#: ../../started.rst:128
msgid ""
"Still with SQLite, you might have received or downloaded a bauble "
"database, and you want to connect to it. In this case you do not let "
"Ghini use the default filename, but you browse in your computer to the "
"location where you saved the Ghini SQLite database file."
msgstr ""
"여전히 SQLite에서는 보블 데이터베이스를 수신하거나 다운로드했을 수 있으며, 이 데이터베이스에 연결하려고 합니다. 이 경우 "
"Ghini가 기본 파일 이름을 사용하도록 허용하지 않지만 컴퓨터에서 Ghini SQLite 데이터베이스 파일을 저장한 위치로 이동합니다."

#: ../../started.rst:133
msgid ""
"If you use a different database connector, the dialog box will look "
"different and it will offer you the option to fine tune all parameters "
"needed to connect to the database of your choice."
msgstr ""
"다른 데이터베이스 커넥터를 사용하는 경우, 대화상자는 다르게 보이고 사용자가 선택한 데이터베이스에 연결하는 데 필요한 모든 매개변수를 "
"미세 조정할 수 있는 선택사항을 제공합니다."

#: ../../started.rst:137
msgid ""
"If you are connecting to an existing database you can continue to :ref"
":`editing-and-inserting-data` and subsequently :ref:`searching-in-ghini`,"
" otherwise read on to the following section on initializing a database "
"for Ghini."
msgstr ""
"기존 데이터베이스에 연결하는 심판::계속할 수 있다.`editing-and-inserting-data`과 그 이후:심판"
":`searching-in-ghini`, 그렇지 않으면은 후술 하는 부분 Ghini를 위한 데이터베이스를 초기화하기 계속 읽어 보세요."

#: ../../started.rst:142
msgid ""
"If you plan to associate pictures to plants, specify also the *pictures "
"root* folder. The meaning of this is explained in further detail at :ref"
":`plant-pictures` in :ref:`editing-and-inserting-data`."
msgstr ""
"만약 당신이 식물을 것도 *picturesroot* 폴더 지정하는 사진을 연결할 계획이다.이것의 의미를 더 자세히 심판:`plant-"
"pictures':에서 심판의:설명되어 있다.`editing-and-inserting-data`."

#: ../../started.rst:146
msgid "A sample SQLite database"
msgstr "샘플 SQLite 데이터베이스"

#: ../../started.rst:149
msgid ""
"Indeed we have a sample database, from our pilot garden \"El Cuchubo\", "
"in Mompox, Colombia.  We have a zipped `sample database for ghini-1.0 "
"<http://www.ghini.me/cuchubo-1.0.zip>`_."
msgstr ""
"실제로 콜롬비아의 Mmpox에 있는 우리의 시범 정원인 \"El Cuchubo\"에 있는 샘플 데이터베이스를 가지고 있습니다.  우리는 "
"'ghini-1.0용 샘플 데이터베이스'를 보유하고 있다. http://www.ghini.me/cuchubo-1.0.zip'."

#: ../../started.rst:153
msgid ""
"Download and unzip it to the location of your choice, then start Ghini, "
"create a connection named possibly ``cuchubo``, or ``sample``, and edit "
"the Connection Details.  Keep the connection type at the default SQLite, "
"but instead of using the default locations, make sure that Filename "
"points to your unpacked ``cuchubo.db`` file."
msgstr ""
"선택한 위치에 다운로드하여 압축을 푼 다음 기니를 시작하고 \"쿠추보\" 또는 \"샘플\"이라는 이름을 가진 연결을 만든 다음 연결 세부 "
"정보를 편집합니다.  연결 유형을 기본 SQLite에 유지하되 기본 위치를 사용하는 대신 파일 이름이 압축되지 않은 "
"''cuchubo.db'' 파일을 가리키는지 확인하십시오."

#: ../../started.rst:162
msgid "Initialize a database"
msgstr "데이터베이스 초기화"

#: ../../started.rst:164
msgid ""
"First time you open a connection to a database which had never been seen "
"by Ghini before, Ghini will first display an alert:"
msgstr "이전에 Ghini에서 볼 수 없었던 데이터베이스에 대한 연결을 처음 열면 Ghini가 먼저 경고를 표시합니다::"

#: ../../started.rst:169
msgid "immediately followed by a question:"
msgstr "즉시 다음 질문이 뒤따릅니다:"

#: ../../started.rst:173
msgid ""
"Be careful when manually specifying the connection parameters: the values"
" you have entered may refer to an existing database, not intended for use"
" with Ghini. By letting Ghini initialize a database, the database will be"
" emptied and all of its content be lost."
msgstr ""
"연결 매개 변수를 수동으로 지정할 때 주의하십시오. 입력한 값은 Ghini와 함께 사용할 수 없는 기존 데이터베이스를 참조할 수 "
"있습니다. Ghini가 데이터베이스를 초기화하면 데이터베이스가 비워지고 모든 내용이 손실됩니다."

#: ../../started.rst:178
msgid ""
"If you are sure you want to create a database at this connection then "
"select \"Yes\". Ghini will then start creating the database tables and "
"importing the default data. This can take a minute or two so while all of"
" the default data is imported into the database so be patient."
msgstr ""
"이 연결에 데이터베이스를 생성하려면 \"예\"를 선택하십시오. 그런 다음 Ghini가 데이터베이스 테이블을 만들고 기본 데이터를 가져오기 "
"시작합니다. 이 작업은 1~2분이 걸릴 수 있으므로 모든 기본 데이터를 데이터베이스로 가져오는 동안 잠시 기다려 주십시오."

#: ../../started.rst:183
msgid ""
"Once your database has been created, configured, initialized, you are "
"ready to start :ref:`editing-and-inserting-data` and subsequently :ref"
":`searching-in-bauble`."
msgstr ""
"데이터베이스가 생성, 구성, 초기화되면 다음을 시작할 수 있습니다:ref:데이터 저장 및 데이터 저장 후 :ref:&amp;in-"
"completable."

#: ../../statements.rst:2
msgid "Mission & Vision"
msgstr "미션 & 비전"

#: ../../statements.rst:4
msgid ""
"Here we state who we are, what we think of our work, what you can expect "
"of this project."
msgstr "여기 우리가 우리 자신이 누군지 말했듯이 우리가 할 일이라고 생각하는, 이 프로젝트의 뭘 기대할 수 있다."

#: ../../statements.rst:8
msgid "Who is behind Ghini"
msgstr "Ghini 뒤에 누가 있습니까"

#: ../../statements.rst:10
msgid ""
"Ghini is a small set of programs, meant to let collection managers manage"
" their collection also digitally."
msgstr "Ghini는 컬렉션 관리자가 디지털 방식으로 컬렉션을 관리할 수 있도록 하는 작은 프로그램 세트입니다."

#: ../../statements.rst:13
msgid ""
"Ghini was born back in 2004 as Bauble, at the Belize Botanical Garden. It"
" was later adapted to the needs of a few more gardens. Brett Adams, the "
"original programmer, made this software a commons, by releasing it under "
"a GPL license."
msgstr ""
"기니는 2004년 벨리즈 식물원에서 보블(Bauble)로 태어났다. 그것은 나중에 몇 개의 더 많은 정원의 필요에 적응되었다. 오리지널 "
"프로그래머인 브렛 아담스는 GPL 라이선스로 이 소프트웨어를 출시함으로써 이 소프트웨어를 공동화했다."

#: ../../statements.rst:18
msgid ""
"After years of stagnation Mario Frasca revived the project, and rebranded"
" it as Ghini in honour of Luca Ghini, founder of the first European "
"botanic garden and herbarium. Mario Frasca started advocating, "
"travelling, distributing, developing, expanding, redefining, documenting "
"it, and it is now Mario Frasca writing this, looking for users, "
"requesting feedback."
msgstr ""
"몇 년간의 침체 후에 마리오 프라스카는 이 프로젝트를 부활시켰고, 최초의 유럽 식물 정원과 허바륨의 설립자인 루카 기니를 기념하여 기니로 "
"개명했다. Mario Frasca는 이것을 지지하고, 여행하고, 배포하고, 개발하고, 확장하고, 재정의하고, 문서화하기 시작했습니다. "
"그리고 지금은 Mario Frasca가 이것을 쓰고, 사용자를 찾고, 피드백을 요청하고 있습니다."

#: ../../statements.rst:24
msgid ""
"Behind Ghini there's not only one developer, but a small but growing "
"global users community."
msgstr "기니 뒤에는 개발자가 한 명뿐 아니라, 작지만 성장하는 글로벌 사용자 커뮤니티가 있습니다."

#: ../../statements.rst:27
msgid ""
"Translations are provided by volunteers who mostly stay behind the "
"scenes, translating missing terms or sentences, and disappearing again."
msgstr "번역은 대부분 뒤에 남아 누락된 용어나 문장을 번역한 뒤 다시 사라지는 자원봉사자들에 의해 제공된다."

#: ../../statements.rst:30
msgid ""
"To make things clearer when we speak of Ghini, but should—and in this "
"document we will—indicate whether it's Ghini(the software), or Ghini(the "
"people), unless obviously we mean both things."
msgstr ""
"Ghini에 대해 말할 때 더 명확하게 할 수 있도록 하기 위해, 그리고 이 문서에서는 Ghini(소프트웨어)인지 Ghini(국민)인지, "
"두 가지 모두를 의미하지 않는 한 Ghini(국민)인지를 명시할 것입니다."

#: ../../statements.rst:35
msgid "Mission"
msgstr "미션"

#: ../../statements.rst:37
msgid ""
"Our goal as Ghini Software is to provide free software, of proven "
"quality, and to let anybody install it if they feel like it.  We also aim"
" at facilitating access to functional knowledge, in the form of "
"documentation or by laying the contact among users or between users and "
"software professionals."
msgstr ""
"Ghini Software의 목표는 입증된 품질의 소프트웨어를 무료로 제공하고 누구나 원할 경우 소프트웨어를 설치할 수 있도록 하는 "
"것입니다.  또한 문서 형태로 또는 사용자와 소프트웨어 전문가 사이에 연락을 취함으로써 기능적 지식에 대한 접근을 용이하게 하는 것을 "
"목표로 한다."

#: ../../statements.rst:43
msgid ""
"All our sources, software and documentation, are open and free, and we "
"welcome and stimulate people to use and to contribute.  To facilitate "
"community forming, all our platforms can be consulted without "
"registration. Registration is obviously required if you want to "
"contribute."
msgstr ""
"우리의 모든 소스, 소프트웨어 및 문서는 공개되고 무료이며, 우리는 사람들이 사용하고 기여하도록 환영하고 격려합니다.  커뮤니티 형성을 "
"촉진하기 위해 등록 없이 모든 플랫폼을 참조할 수 있습니다. 기부를 원하시면 분명히 등록이 필요합니다."

#: ../../statements.rst:48
msgid ""
"Ghini welcomes the formation of groups of users, bundling forces to "
"define and finance further development, and we welcome developers "
"contributing software, from any corner in the world, and we stimulate and"
" help them comply with the high quality requirements, before we accept "
"the contributed code in the software sources."
msgstr ""
"Ghini는 추가 개발을 정의하고 자금을 조달하기 위해 사용자 그룹의 구성을 환영하며, 우리는 세계 어느 곳에서든 소프트웨어를 제공하는 "
"개발자들을 환영하며, 소프트웨어 소스에서 기여 코드를 받아들이기 전에 그들이 고품질 요구 사항을 준수하도록 자극하고 도와준다."

#: ../../statements.rst:55
msgid "Vision"
msgstr "비전"

#: ../../statements.rst:57
msgid ""
"The Vision serves to indicate the way ahead and projects a future image "
"of what we want our organization to be, in a realistic and attractive "
"way.  It serves as motivation because it visualizes the challenge and "
"direction of necessary changes in order to grow and prosper."
msgstr ""
"Vision은 앞으로 나아갈 방향을 제시하는 역할을 하며, 조직이 어떻게 되기를 원하는지에 대한 미래 이미지를 사실적이고 매력적인 "
"방식으로 투영합니다.  성장과 번영을 위해 필요한 변화의 도전과 방향을 시각화하기 때문에 동기부여의 역할을 한다."

#: ../../statements.rst:62
msgid "by the year 2020"
msgstr "2020년까지"

#: ../../statements.rst:63
msgid "reference point"
msgstr "기준점"

#: ../../statements.rst:64
msgid "community"
msgstr "공동체의"

#: ../../statements.rst:65
msgid "development"
msgstr "개발"

#: ../../statements.rst:66
msgid "integration with web portal"
msgstr "웹 포털과의 통합"

#: ../../statements.rst:67
msgid "geographic information"
msgstr "지리 정보"

#: ../../tagging.rst:2
msgid "Tagging"
msgstr "태그 지정"

#: ../../tagging.rst:4
msgid ""
"Tagging is an easy way to give context to an object or create a "
"collection of object that you want to recall later."
msgstr "태그 지정은 개체에 컨텍스트를 제공하거나 나중에 호출할 개체 컬렉션을 만들 수 있는 쉬운 방법입니다."

#: ../../tagging.rst:7
msgid ""
"The power in this tagging action is that you can share this selection "
"with colleagues, who can act on it, without the need to redo all your "
"collecting work."
msgstr ""
"이 태그 지정 동작의 장점은 모든 수집 작업을 다시 실행할 필요 없이 이 선택 항목을 작업할 수 있는 동료와 공유할 수 있다는 것입니다."

#: ../../tagging.rst:11
msgid ""
"For example if you need to print accession labels of otherwise unrelated "
"plants, you can group the objects by tagging them with the string "
"\"relabel\". You or one of your colleagues can then select \"relabel\" "
"from the tags menu, the search view will show all the objects you tagged,"
" and performing a report will act on the tagged objects."
msgstr ""
"예를 들어 다른 관련 없는 식물의 등록 레이블을 인쇄해야 하는 경우 개체를 \"relabel\" 문자열로 태그하여 그룹화할 수 있습니다. "
"그런 다음 사용자 또는 동료 중 한 명이 태그 메뉴에서 \"릴레이블\"을 선택하고 검색 뷰에 태그가 지정된 모든 개체가 표시되고 보고서를 "
"수행하면 태그가 지정된 개체에 적용됩니다."

#: ../../tagging.rst:17
msgid ""
"Tagging acts on the active selection, that is the items in the search "
"results which you have selected."
msgstr "태그 지정은 선택한 검색 결과의 항목인 활성 선택 항목에 적용됩니다."

#: ../../tagging.rst:20
msgid ""
"Please remember: you can select all result rows by pressing ``Ctrl-A``, "
"you can deselect everything by pressing ``Ctrl-Shift-A``, you can toggle "
"tagging of a single row by ``Ctrl-Mouse click`` on it."
msgstr ""
"기억하십시오. \"Ctrl-A\"를 눌러 모든 결과 행을 선택할 수 있고, \"Ctrl-Shift-A\"를 눌러 모든 항목을 선택 취소할 "
"수 있으며, 단일 행에 \"Ctrl-Mouse 클릭\"을 눌러 단일 행의 태그를 전환할 수 있습니다."

#: ../../tagging.rst:24
msgid "Once you have an active selection, tagging can be done in two ways:"
msgstr "활성 선택을 한 후에는 다음 두 가지 방법으로 태그 지정을 수행할 수 있습니다:"

#: ../../tagging.rst:27
msgid "dialog box tagging"
msgstr "대화 상자 태그 지정"

#: ../../tagging.rst:29
msgid ""
"Press ``Ctrl-T`` or select :menuselection:`Tag-->Tag Selection` from the "
"menu, this activates a window where you can create new tags and apply any"
" existing tag to the selection."
msgstr ""
"''Ctrl-T''를 누르거나 다음을 선택합니다. 메뉴 선택:메뉴에서 'Tag-->Tag Selection'을 선택하면 새 태그를 "
"생성하고 기존 태그를 선택 항목에 적용할 수 있는 창이 활성화됩니다."

#: ../../tagging.rst:33
msgid "The tag window is composed of three parts:"
msgstr "태그 창은 세 부분으로 구성됩니다:"

#: ../../tagging.rst:35
msgid ""
"The upper part mentions the list of objects in your active selection. "
"This is the list of object of which you are editing the tags;"
msgstr "위쪽에는 활성 선택 항목에 있는 개체 목록이 나와 있습니다. 태그를 편집하는 개체 목록입니다;"

#: ../../tagging.rst:37
msgid ""
"The middle part has a list of all available tags, with a checkbox that "
"you can activate for applying the tag to or removing the tag from the "
"selection;"
msgstr ""
"중간 부분에는 사용 가능한 모든 태그 목록이 있으며 선택 영역에 태그를 적용하거나 선택 항목에서 태그를 제거하기 위해 활성화할 수 있는 "
"확인란이 있습니다;"

#: ../../tagging.rst:40
msgid ""
"The lower part only holds a link to new tag creation, and the Ok button "
"for closing the dialog box."
msgstr "아래쪽에는 새 태그 생성 링크와 대화 상자를 닫는 확인 단추만 있습니다."

#: ../../tagging.rst:43
msgid ""
"If, when opening the tag dialog box, the active selection holds multiple "
"items, then only the tags that are common to all the selected items will "
"have a check next to it.  Tags that only apply to a proper subset of the "
"active selection will show with an 'undecided' status.  Tags that don't "
"apply to any object in the active selection will show blank."
msgstr ""
"태그 대화 상자를 열 때 활성 선택 항목에 여러 항목이 있는 경우 선택한 모든 항목에 공통인 태그만 옆에 체크 표시가 있습니다.  활성 "
"선택 영역의 적절한 하위 집합에만 적용되는 태그는 '미결정' 상태로 표시됩니다.  활성 선택 영역의 개체에 적용되지 않는 태그는 공백으로 "
"표시됩니다."

#: ../../tagging.rst:49
msgid ""
"The most recently created tag, or the most recently selected tag becomes "
"the active tag, and it shows with a check next to it in the tags menu."
msgstr ""
"가장 최근에 생성된 태그 또는 가장 최근에 선택한 태그가 활성 태그가 되고 태그 메뉴에서 해당 태그 옆에 확인 표시가 나타납니다."

#: ../../tagging.rst:53
msgid "windowless tagging"
msgstr "창 없는 태그 지정"

#: ../../tagging.rst:55
msgid ""
"Once you have an active tag, pressing ``Ctrl-Y`` applies the active tag "
"to all objects in the active selection.  ``Ctrl-Shift-Y`` removes the "
"active tag from all objects in the active selection."
msgstr ""
"활성 태그가 있으면 ''Ctrl-Y''를 누르면 활성 태그가 활성 선택 영역의 모든 개체에 적용됩니다.  \"Ctrl-Shift-Y\"는 "
"활성 선택 영역의 모든 개체에서 활성 태그를 제거합니다."

#: ../../template-letters.rst:2
msgid "Template Letters"
msgstr "템플릿 문자"

#: ../../template-letters.rst:4
msgid ""
"The reader getting to this point in the documentation probably understood"
" that this Ghini project is above all a very open and collaborative "
"project."
msgstr "문서에서 이 점에 도달한 독자들은 이 기니 프로젝트가 무엇보다도 매우 개방적이고 협력적인 프로젝트라는 것을 이해했을 것이다."

#: ../../template-letters.rst:7
msgid ""
"Here in this page you find some template letters, used to welcome new "
"users, or that you can correct, print, and go with it to a garden, and "
"propose them to adopt Ghini, or share with a group of your local friends,"
" so you can make Ghini become a (voluntary, or paid) part-time job for "
"you."
msgstr ""
"이 페이지에는 새로운 사용자를 환영하는 데 사용되는 템플릿 문자가 있습니다. 또는 수정, 인쇄 및 정원으로 이동하여 기니를 입양하거나 "
"지역 친구들과 공유하도록 제안할 수 있습니다. 그러면 기니가 여러분에게 (자발적 또는 유료) 아르바이트가 될 수 있습니다."

#: ../../template-letters.rst:12
msgid "Dear conservator or scientist,"
msgstr "친애하는 보수주의자 또는 과학자에게,"

#: ../../template-letters.rst:14
msgid ""
"You are reading Ghini's presentation letter. Ghini is a libre software "
"project on GitHub, focusing on botany. Brought to you by a small "
"community of coders, botanists, translators, and supported by a few "
"institutions around the world, among which, gardens that have adopted it "
"for all their collection management needs."
msgstr ""
"당신은 기니의 발표 편지를 읽고 있습니다. Ghini는 식물학에 초점을 둔 GitHub의 libre 소프트웨어 프로젝트이다. 코드 "
"제작자, 식물학자, 번역가들로 구성된 소규모 커뮤니티가 여러분을 모았습니다. 그리고 전 세계 몇몇 기관들의 지원을 받았습니다. 그 중 "
"모든 수집 관리에 필요한 정원이었습니다."

#: ../../template-letters.rst:19
msgid ""
"The Ghini family is a software suite composed of standalone programs, "
"data servers and handheld clients, for data management, and publication:"
msgstr ""
"Ghini 제품군은 독립 실행형 프로그램, 데이터 서버 및 핸드헬드 클라이언트, 데이터 관리 및 퍼블리싱을 위한 소프트웨어 제품군입니다:"

#: ../../template-letters.rst:24
msgid "Ghini's core, ``ghini.desktop``, lets you"
msgstr "기니의 핵심인 ''기니.데스크톱''이 당신을 있게 한다"

#: ../../template-letters.rst:26
msgid "enter and correct your data"
msgstr "데이터 입력 및 수정"

#: ../../template-letters.rst:27
msgid "navigate its links,"
msgstr "링크를 탐색합니다,"

#: ../../template-letters.rst:28
msgid "produce reports"
msgstr "보고서를 작성하다"

#: ../../template-letters.rst:29
msgid "import and or export using several standard or ad-hoc formats"
msgstr "여러 표준 또는 임시 형식을 사용하여 가져오기 또는 내보내기"

#: ../../template-letters.rst:30
msgid "review your taxonomy using online sources"
msgstr "온라인 소스를 사용하여 분류법 검토"

#: ../../template-letters.rst:32
msgid ""
"all according best practices suggested by top gardens, formalized in "
"standard formats like ABCD, ITF2, but also as elaborated by our "
"developers, based on the feedback of Ghini users."
msgstr ""
"상위 정원에 의해 제안된 모범 사례에 따라, ABCD, ITF2와 같은 표준 형식으로 공식화되었지만, 또한 Ghini 사용자의 피드백을 "
"기반으로 개발자들에 의해 상세하게 설명되었다."

#: ../../template-letters.rst:36
msgid ""
"``ghini.desktop`` is developed and continously tested on GNU/Linux, but "
"runs equally well on Windows, or OSX. [1]"
msgstr ""
"\"ghini.desktop\"은 GNU/Linux에서 지속적으로 개발되고 테스트되지만 Windows 또는 OSX에서도 동일하게 잘 "
"실행됩니다. [1]"

#: ../../template-letters.rst:39
msgid ""
"``ghini.pocket`` is your full time garden companion, an Android app "
"installed from the Play Store,"
msgstr "''기니''포켓은 플레이스토어에서 설치한 안드로이드 앱인 풀타임 가든의 동반자입니다,"

#: ../../template-letters.rst:42
msgid "assisting you in collecting or correcting data while in the field,"
msgstr "현장에서 데이터를 수집하거나 수정하는 데 도움을 줍니다,"

#: ../../template-letters.rst:43
msgid "associate pictures to your plants, and verify taxonomic information."
msgstr "그림을 식물에 연결하고 분류학적 정보를 확인합니다."

#: ../../template-letters.rst:44
msgid ""
"Import your collected data into the desktop client when back in the "
"office,"
msgstr "그림을 식물에 연결하고 분류학적 정보를 확인합니다.사무실에 돌아와서 수집한 데이터를 데스크톱 클라이언트로 가져오십시오,"

#: ../../template-letters.rst:46
msgid ""
"``ghini.pocket`` reduces the time spent in front of your desktop PC to a "
"true minimum."
msgstr "''기니''포켓은 데스크탑 PC 앞에서 보내는 시간을 최소한으로 줄여줍니다."

#: ../../template-letters.rst:48
msgid ""
"``ghini.web`` is a web server and a courtesy data hub service, offering "
"you world wide visibility: Export a selection of your data from your "
"desktop database, and handle it for publication to the Ghini project, and"
" we will include it at http://gardens.ghini.me/, at no cost while we're "
"able to do that, or for a guaranteed minimal amount of time if you are "
"able to support our hosting costs. ``ghini.web`` serves a world map to "
"help locate participating gardens, and within each garden, its "
"contributed georeferenced plants."
msgstr ""
"''기니''웹캠은 웹 서버이자 데이터 허브 서비스로, 전 세계에 걸친 가시성을 제공합니다. 데스크톱 데이터베이스에서 선택한 데이터를 "
"내보낸 후 Ghini 프로젝트에 게시할 수 있도록 처리하면, http://gardens.ghini.me/,에 무료로 포함시킬 수 있으며, "
"호스팅 비용을 지원할 수 있다면 최소한의 시간만 보장해 드립니다. ''기니''webt는 참여하는 정원의 위치를 찾는 데 도움을 주는 세계 "
"지도를 제공하며, 각 정원 내에는 그것의 기여된 지리 참조식물이 있다."

#: ../../template-letters.rst:56
msgid ""
"``ghini.tour``, a geographic tour Android app aimed at visitors, using "
"OpenStreetMap as a base map, retrieving its data, gardens and virtual "
"panels, from the web data aggregator ``ghini.web``."
msgstr ""
"''기니'''투어'는 오픈스트리트맵을 베이스맵으로 사용하여 웹 데이터 수집기 \"기니\"에서 데이터, 정원 및 가상 패널을 검색해 "
"방문자를 겨냥한 지리 관광용 안드로이드 앱이다.거미줄 치기 시작하다"

#: ../../template-letters.rst:60
msgid ""
"All software within the Ghini family is either licensed GNU Public "
"License v2+ or v3+. It is a strong copyleft license.  In short, the GPL "
"translates the ethical scientific need to share knowledge, into legal "
"terms. If you want to read more about it, please refer to "
"https://www.gnu.org/licenses/copyleft.html"
msgstr ""
"Ghini 제품군의 모든 소프트웨어는 GNU 공용 라이센스 v2+ 또는 v3+로 라이센스가 부여된다. 그것은 강력한 카피레프트 "
"라이선스이다.  간단히 말해서, GPL은 지식을 공유하기 위한 윤리적 과학적 필요성을 법률 용어로 번역한다. 자세한 내용은 "
"https://www.gnu.org/licenses/copyleft.html를 참조하십시오"

#: ../../template-letters.rst:65
msgid ""
"Ghini's idea about knowledge and software ownership is that software is "
"procedural knowledge and as such, should be made a \"commons\": With "
"software as a commons, \"libre software\" and more specifically "
"\"Copylefted software\", you not only get the source code, you receive "
"the right to adapt it, and the invitation to study and learn from it, and"
" to share it, both share forward to colleagues, and share back to the "
"source.  With proprietary software, you are buying your own ignorance, "
"and with that, your dependency."
msgstr ""
"지식과 소프트웨어 소유에 대한 기니의 생각은 소프트웨어가 절차적 지식이며, 따라서 다음과 같은 \"공통\"이 되어야 한다는 것이다. "
"소프트웨어를 공통으로 사용하는 \"libre software\"와 보다 구체적으로 \"copyleft software\"를 사용하면 소스 "
"코드뿐만 아니라 소스 코드를 조정할 수 있으며, 소스 코드로부터 공부하고 학습할 수 있는 초대장을 받고, 이를 공유하여 동료에게 "
"전달하며, 소스로 다시 공유할 수 있습니다.  독점 소프트웨어를 사용하면 자신의 무지와 의존성을 살 수 있습니다."

#: ../../template-letters.rst:72
msgid ""
"This fancy term \"copyleft\" instead of just \"libre software\", means "
"the software you received is libre software with one extra freedom, "
"guaranteeing every right you were granted upon receiving the software is "
"never lost."
msgstr ""
"단순히 \"libre software\"가 아니라 \"copyleft\"라는 이 화려한 용어는 당신이 받은 소프트웨어는 하나의 여분의 "
"자유를 가진 libre software를 의미하며, 당신이 소프트웨어를 받았을 때 부여받은 모든 권리는 절대 상실되지 않는다는 것을 "
"보증한다."

#: ../../template-letters.rst:76
msgid ""
"With copylefted software you are free —actually welcome— to employ local "
"software developers in your neighbourhood to alter the software according"
" to your needs, please do this on GitHub, fork the code, develop just as "
"openly as the common practice within Ghini, and whenever you want, open a"
" pull request so your edits can be considered for inclusion in the main "
"branch. Ghini is mostly continuously unit tested, so before your code is "
"added to the main branch, it should follow our quality guidelines for "
"contributions. With libre software you acquire freedom and contribute to "
"it, something that earns you visibility: Your additions stays yours, you "
"share them back to the community, and will see them completed and made "
"better by others. Having your code added to the main branch simplifies "
"your upgrade procedure."
msgstr ""
"무료 카피레프트 소프트웨어를 사용하면 지역 소프트웨어 개발자를 고용하여 필요에 따라 소프트웨어를 변경하고, 코드를 포크 처리하며, "
"Ghini 내의 일반적인 관행처럼 공개 개발하며, 원할 때마다 꺼내기 요청을 열어 편집 내용을 포함시킬 수 있습니다.본점에서 n. 기니는 "
"대부분 지속적으로 유닛 테스트를 거쳤기 때문에 코드를 본점에 추가하기 전에 기여에 대한 당사의 품질 지침을 따라야 합니다. libre "
"소프트웨어를 사용하면 자유를 얻을 수 있고, 이를 통해 가시성을 얻을 수 있습니다. 추가 기능은 그대로 유지되고 커뮤니티에 공유되며, "
"다른 사용자가 추가 기능을 완료하고 더 나은 기능을 제공하는 것을 볼 수 있습니다. 기본 분기에 코드를 추가하면 업그레이드 절차가 "
"간단해집니다."

#: ../../template-letters.rst:86
msgid ""
"You can also contribute to the software by helping translate it into your"
" native language. [5]"
msgstr "또한 소프트웨어를 모국어로 변환하는 데 도움을 주어 소프트웨어에 기여할 수도 있습니다. [5]"

#: ../../template-letters.rst:88
msgid ""
"Some videos are published on YouTube, highlighting some of the software "
"capabilities. [6]"
msgstr "일부 비디오는 YouTube에 게시되어 소프트웨어 기능 중 일부를 강조합니다. [6]"

#: ../../template-letters.rst:90
msgid ""
"Share back with the community. Several developers have spent cumulatively"
" many thousand hours developing this software, and we're sharing with the"
" community. We hope by this to stimulate a community sentiment in whoever"
" starts using what we have produced."
msgstr ""
"커뮤니티와 다시 공유하십시오. 몇몇 개발자들이 이 소프트웨어를 개발하는 데 수천 시간을 소비했고, 우리는 커뮤니티와 공유하고 있습니다. "
"우리는 이것을 통해 우리가 생산한 것을 사용하기 시작하는 누구에게나 지역 사회의 감정을 자극하기를 바란다."

#: ../../template-letters.rst:94
msgid ""
"Thanks for your consideration; please let me know if you have any "
"questions,"
msgstr "고려해 주셔서 감사합니다. 질문이 있으시면 말씀해주세요,"

#: ../../template-letters.rst:96
msgid ""
"In case you're interested in publishing your tree collection on the net, "
"I would be happy to include your plants, species, coordinates to "
"http://gardens.ghini.me. Georeferenced textual information panels are "
"also very welcome, all offered as a courtesy: We're still defining the "
"offer. The idea behind this is allowing visitors to explore aggregated "
"garden collections, and the current focus is on trees."
msgstr ""
"만약 당신이 당신의 나무 컬렉션을 인터넷에 게시하고 싶다면, 저는 당신의 식물, 종, 좌표를 http://gardens.ghini.me에 "
"기꺼이 포함시키겠습니다. 지역 참조 텍스트 정보 패널도 모두 호의로 제공됩니다. 우리는 여전히 그 제안을 정의하고 있다. 이면의 "
"아이디어는 방문객들이 집적된 정원 컬렉션을 탐험할 수 있도록 하는 것이고, 현재 초점은 나무입니다."

#: ../../template-letters.rst:103
#, python-format
msgid "A small example: http://gardens.ghini.me/#garden=Jardín%20el%20Cuchubo"
msgstr "작은 예: http://gardens.ghini.me/#garden=Jardin%20el%20쿠추보"

#: ../../template-letters.rst:105
msgid "Mario Frasca MSc"
msgstr "마리오 프라스카 MS"

#: ../../template-letters.rst:107
msgid "[1] http://ghini.readthedocs.io/ - http://ghini.github.io/"
msgstr ""
"[1] http://ghini.readthedocs.io/ - http://ghini.github.io/ - http://ghini."
"github.io/"

#: ../../template-letters.rst:108
msgid "[2] https://play.google.com/store/apps/details?id=me.ghini.pocket"
msgstr "[2] https://play.google.com/store/apps/details?id=me.ghini.pocket"

#: ../../template-letters.rst:109
msgid "[3] http://gardens.ghini.me/"
msgstr "[3] http://gardens.ghini.me/"

#: ../../template-letters.rst:110
msgid "[4] https://play.google.com/store/apps/details?id=me.ghini.tour"
msgstr "[4] https://play.google.com/store/apps/details?id=me.ghini.tour"

#: ../../template-letters.rst:111
msgid "[5] https://hosted.weblate.org/projects/ghini/#languages"
msgstr "[5] https://hosted.weblate.org/projects/ghini/#contracts"

#: ../../template-letters.rst:112
msgid ""
"[6] "
"https://www.youtube.com/playlist?list=PLtYRCnAxpinU_8WEDuRlgsYnNVe4J_4kv"
msgstr ""
"[6] https://www.youtube.com/playlist?list=PLtYRCnAxpinU_8WEDuRlgsYnNVe4J_4kv"

#: ../../template-letters.rst:115
msgid "free botanic data management systems"
msgstr "무료 식물 데이터 관리 시스템"

#: ../../template-letters.rst:117
msgid ""
"Many institutions still consider software an investment, an asset that is"
" not to be shared with others, as if it was some economic good that can't"
" be duplicated, like gold."
msgstr ""
"많은 기관들은 여전히 소프트웨어를 투자, 즉 다른 기관과 공유해서는 안 되는 자산으로 생각하고 있는데, 마치 금과 같이 중복될 수 없는 "
"경제적 이익인 것처럼 생각하고 있다."

#: ../../template-letters.rst:120
msgid ""
"As of right now, very few copylefted programs exist for botanic data "
"management:"
msgstr "현재 식물성 데이터 관리를 위한 복사된 프로그램은 거의 없습니다:"

#: ../../template-letters.rst:122
msgid ""
"``ghini.desktop``, born as ``bauble.classic`` and made a commons by the "
"Belize Botanical Garden.  ``ghini.desktop`` has three more components, a "
"pocket data collecting Android app, a Node.js web server, aggregating "
"data from different gardens and presenting it geographically, again a "
"geographic tour app aimed at visitors using the web data aggregator as "
"its data source. You can find every Ghini component on GitHub: "
"http://github.com/Ghini"
msgstr ""
"벨리즈 식물원이 만든 ``ghini.desktop\"은 ``bauble.classic\"으로 탄생했다.  \"ghini.desktop\"은"
" 안드로이드 앱, Node.js 웹 서버, 포켓 데이터 수집, 서로 다른 정원의 데이터 수집, 지리적으로 이를 제공하는 세 가지 요소를 "
"더 가지고 있는데, 다시 웹 데이터 집적기를 데이터 소스로 사용하는 방문객을 겨냥한 지리 여행 앱이다. GitHub에서 모든 Ghini "
"구성 요소를 찾을 수 있습니다. http://github.com/Ghini"

#: ../../template-letters.rst:129
msgid ""
"Specify 6 and 7, made a Commons by the Kansas University. A bit complex "
"to set up, very difficult to configure and tricky to update. The "
"institutions I've met who tried it, only the bigger ones, with in-house "
"software management capabilities manage to successfully use it. They use "
"it for very large collections. Specify is extremely generic, it adapts to"
" herbaria, seed collections, but also to collections of eggs, organic "
"material, fossils, preserved dead animals, possibly even viruses, I'm not"
" sure. It is this extreme flexibility that makes its configuration such a"
" complex task. Specify is also on GitHub: https://github.com/specify and "
"is licensed as GPLv2+."
msgstr ""
"6과 7을 지정하십시오. 캔자스 대학교가 만든 커먼스입니다. 설정하기 복잡하고 구성하기도 매우 어렵고 업데이트하기도 까다롭습니다. 제가 "
"만난 기관들은 사내 소프트웨어 관리 기능을 갖춘 대형 기관들만이 성공적으로 이 시스템을 사용할 수 있습니다. 그들은 그것을 매우 많은 "
"수집품에 사용한다. 명세서는 극히 일반적이며, 난자, 유기물, 화석, 보존된 죽은 동물들, 심지어는 바이러스까지 적응합니다. 이렇게 "
"구성이 복잡한 것은 바로 이러한 극단적인 유연성 때문입니다. Specify는 GitHub: https://github.com/"
"specify에도 있으며 GPLv2+로 라이센스가 부여됩니다."

#: ../../template-letters.rst:138
msgid ""
"Botalista, a French/Swiss cooperation, is GPL as far as rumours go. Its "
"development has yet to go public."
msgstr "프랑스/스위스 협력사인 보탈리스타는 소문만큼 GPL이다. 그것의 개발은 아직 공개되지 않았다."

#: ../../template-letters.rst:141
#, python-format
msgid ""
"``bauble.web`` is an experimental web server by the author of "
"``bauble.classic``. ``bauble.classic`` has been included into Ghini, to "
"become ``ghini.desktop``. Bauble uses a very permissive license, making "
"it libre, but not copylefted. As much as 50% of bauble.web and possibly "
"30% of ghini.desktop is shared between the two projects. Bauble seems to "
"be stagnating, and has not yet reached a production-ready stage."
msgstr ""
"''아쉽다''웹닷컴은 \"bulble.bulful\"의 저자가 개발한 실험용 웹 서버이다. \"보블.클래식\"이 기니에 포함되어 \"기니."
"데스크톱\"이 되었다. 바우블은 관대한 면허증을 사용해서, 그것을 입방아로 만들지만, 복사본은 남기지 않았다. 보블의 50%나 되죠웹과 "
"30%의 ghini.dump가 두 프로젝트 간에 공유됩니다. 보블은 침체된 듯 아직 생산 준비 단계에 이르지 못했다."

#: ../../template-letters.rst:147
msgid ""
"``Taxasoft-BG``, by Eric Gouda, a Dutch botanist, specialist in "
"Bromeliaceae, collection manager at the Utrecht botanical garden.  It was"
" Mario Frasca who convinced Eric to publish what he was doing, licensing "
"it under the GPL, but the repository was not updated after 2016, April "
"13th and Eric forgot to explicitly specify the license.  You find it on "
"github: https://github.com/Ejgouda/Taxasoft-BG"
msgstr ""
"네덜란드의 식물학자, 브로멜리아과 전문의, 위트레흐트 식물원 소장 에릭 고다가 쓴 ''Taxasoft-BG''입니다.  GPL에 따라 "
"라이센스를 부여하면서 에릭에게 자신이 하고 있는 일을 출판하도록 설득한 사람은 마리오 프라스카였지만, 2016년 4월 13일 이후 "
"저장소는 업데이트되지 않았고 에릭은 라이센스를 명시적으로 지정하는 것을 잊어버렸다.  github에서 찾을 수 있습니다. "
"https://github.com/Ejgouda/Taxasoft-BG"

#: ../../template-letters.rst:153
msgid ""
"``BG-Recorder``, by the BGCI, runs on Windows, and requires Access.  "
"Developed mostly between 1997 and 2003, it has not been maintained ever "
"since and isn't actively distributed by the BGCI.  I've not managed to "
"find a download link nor its license statement.  It is still mentioned as"
" *the free option* for botanic database management."
msgstr ""
"BGCI의 \"BG-Recorder\"는 Windows에서 실행되며 액세스가 필요합니다.  대부분 1997년과 2003년 사이에 "
"개발되었으며, 그 이후로 유지되지 않고 있으며 BGCI에 의해 적극적으로 배포되지 않고 있다.  다운로드 링크나 라이센스 명세서를 찾을 "
"수 없습니다.  식물 데이터베이스 관리를 위한 *무료 옵션*으로 여전히 언급되고 있습니다."

#: ../../template-letters.rst:158
msgid ""
"Of the above, only ``ghini.desktop`` satisfies these conditions: "
"Copylefted, available, documented, maintained, easy to install and "
"configure.  Moreover: Cross platform and internationalized."
msgstr ""
"위 중 ``ghini.desktop\"만이 다음 조건을 충족시킨다. 복사, 사용 가능, 문서화, 유지 관리, 설치 및 구성이 "
"용이합니다.  게다가 플랫폼 간 교차 및 국제화."

#: ../../template-letters.rst:164
msgid "Welcome to Ghini/Bauble"
msgstr "기니/바울에 오신 것을 환영합니다"

#: ../../template-letters.rst:166
msgid "Dear new user,"
msgstr "새로운 사용자님께,"

#: ../../template-letters.rst:168
msgid "Welcome to Ghini/Bauble."
msgstr "기니/바울에 오신 것을 환영합니다."

#: ../../template-letters.rst:170
msgid ""
"As the maintainer, I have received your registration for "
"bauble.classic/ghini.desktop, many thanks for taking your time to fill in"
" the form."
msgstr ""
"관리자로서, 저는 당신의 bauble.class/ghini.desktop에 대한 등록을 받았습니다. 양식을 작성하는데 시간을 내주셔서 "
"대단히 감사합니다."

#: ../../template-letters.rst:173
msgid ""
"I see you are using bauble.classic-1.0.55, whereas 1.0.55 is the last "
"released version of bauble.classic, however, bauble.classic is now "
"unmaintained and superseded by the fully compatible, but slightly "
"aesthetically different ghini.desktop. Install it following the "
"instructions found at http://ghini.rtfd.io"
msgstr ""
"보블.classic-1.0.55를 사용하고 계신데 반해, 1.0.55는 보블.classic의 마지막 버전입니다. 하지만 "
"보블.classic은 이제 완전히 호환되지만 미학적으로는 약간 다른 기니.데스크톱으로 대체되었습니다. http://"
"ghini.rtfd.io의 지침에 따라 설치합니다"

#: ../../template-letters.rst:176
msgid ""
"The registration service says you're not yet using the newest Python2 "
"version available. As of 2018-05-01, that is 2.7.15. Using any older "
"version does not necessitate problems, but in case anything strange "
"happens, please update your Python (and PyGTK) before reporting any "
"errors."
msgstr ""
"등록 서비스에서 사용 가능한 최신 Python2 버전을 아직 사용하지 않고 있다고 합니다. 2018-05-01 현재, 그것은 "
"2.7.15이다. 이전 버전을 사용할 경우 문제가 발생하지 않지만, 이상한 일이 발생할 경우 오류를 보고하기 전에 Python(및 "
"PyGTK)을 업데이트하십시오."

#: ../../template-letters.rst:178
msgid ""
"Also thank you for enabling the \"sentry\" errors and warnings handler. "
"With that enabled, Ghini/Bauble will send any error or warning you might "
"encounter to a central server, where a developer will be able to examine "
"it. If the warning was caused by an error in the software, its solution "
"will be present in a subsequent release of the software"
msgstr ""
"또한 \"sentry\" 오류 및 경고 처리기를 활성화해 주셔서 감사합니다. 이 기능을 사용하면 Ghini/Bauble에서 발생할 수 "
"있는 오류나 경고를 중앙 서버로 전송하여 개발자가 검사할 수 있습니다. 소프트웨어의 오류로 인해 경고가 발생한 경우 해당 솔루션은 "
"소프트웨어의 후속 릴리스에 표시됩니다"

#: ../../template-letters.rst:181
msgid ""
"If you haven't already, to enable the sentry and warnings handler, open "
"the \":config\" page in Ghini and double click on the row "
"\"bauble.use_sentry_client\"."
msgstr ""
"아직 Sentry 및 경고 핸들러를 활성화하지 않은 경우 Ghini에서 \":config\" 페이지를 열고 \"bauable."
"use_sentry_client\" 행을 두 번 클릭합니다."

#: ../../template-letters.rst:183
msgid ""
"I hope Ghini already matches your expectations, if this is not the case, "
"the whole Ghini community would be very thankful if you took the time to "
"report your experience with it."
msgstr ""
"기니가 이미 여러분의 기대에 부응하길 바라며, 만약 그렇지 않다면, 시간을 내어 여러분의 경험을 보고해 주신다면 기니 커뮤니티 전체가 "
"매우 감사할 것입니다."

#: ../../template-letters.rst:187
msgid ""
"The above is one way to contribute to Ghini's development. Others are: - "
"contribute ideas, writing on the bauble google forum "
"(https://groups.google.com/forum/#!forum/bauble), - contribute "
"documentation, or translations "
"(https://hosted.weblate.org/projects/ghini/), - give private feedback, "
"writing to ghini@anche.no, - rate and discuss Ghini openly, and promote "
"its adoption by other institutions, - open an issue on GitHub "
"(https://github.com/Ghini/ghini.desktop/issues/), - contribute code on "
"GitHub (fork the project on (https://github.com/Ghini/ghini.desktop/), - "
"hire a developer and have a set of GitHub issues solved, per-haps your "
"own - let me include your garden on the still experimental worldmap "
"(http://gardens.ghini.me)"
msgstr ""
"위의 내용은 기니의 발전에 기여하는 한 가지 방법이다. 다른 것들은 다음과 같습니다. - 아이디어 기고, 구글 포럼에 글쓰기, 문서 "
"기고, 번역기 기고, ghini@anche.no에 글쓰기, ghini@anche.no에 글쓰기, 기니의 평가 및 토론, 다른 기관의 채택 "
"촉진, 개방. GitHub에 대한 발행(https://github.com/Ghini/ghini.desktop/issues/), - "
"GitHub에 대한 기여 코드(https://github.com/Ghini/ghini.desktop/), - 개발자를 고용하고 "
"GitHub 문제를 해결했음) - 아직 실험적인 세계 지도(http://gardens.ghini.me)에 여러분의 정원을 포함시킬 수 "
"있습니다"

#: ../../template-letters.rst:197
msgid "I sincerely hope you will enjoy using this copylefted, libre software"
msgstr "나는 진심으로 당신이 이 복사된 libre 소프트웨어를 즐겨 사용하길 바란다"

#: ../../template-letters.rst:199
msgid "Best regards, Mario Frasca"
msgstr "Best Greetings, 마리오 프레이스카"

#: ../../template-letters.rst:202
msgid "https://ghini.github.io https://github.com/Ghini/ghini.desktop/issues/"
msgstr "https://ghini.github.io https://github.com/Ghini/ghini.desktop/issues/"

#: ../../template-letters.rst:206
msgid "Do you want to join Ghini?"
msgstr "기니랑 같이 갈래?"

#: ../../template-letters.rst:208
msgid ""
"I generally send a note similar to the following, to GitHub members who "
"\"star\" the project, or to WebLate contributors doing more than one "
"line, and at different occasions.  If it's from GitHub, and if they "
"stated their geographic location in their profile, I alter the letter by "
"first looking on `institutos botánicos "
"<http://umap.openstreetmap.fr/en/map/institutos-"
"botanicos_47038#2/18.0/12.0>`_ if there's any relevant garden in their "
"neighbourhood."
msgstr ""
"프로젝트를 \"주연\"하는 GitHub 회원이나 WebLate 기고자들이 한 회선 이상 하는 경우, 그리고 다른 경우에, 저는 일반적으로 "
"다음과 유사한 메모를 보냅니다.  만약 GitHub에서 온 것이고, 만약 그들이 그들의 프로필에 지리적 위치를 언급했다면, 나는 먼저 "
"이웃에 관련 정원이 있다면 'botánicos http://umap.openstreetmap.fr/en/map/institutos-"
"botanicos_47038#2/18.0/12.0'을 찾아 편지를 바꾼다."

#: ../../template-letters.rst:215
msgid "Dear GitHub member, student, colleague, translator, botanist,"
msgstr "GitHub 회원님, 학생, 동료, 번역가, 식물학자님,"

#: ../../template-letters.rst:217
msgid "Thank you warmly for your interest in the Ghini project!"
msgstr "기니 프로젝트에 관심을 가져주셔서 진심으로 감사드립니다!"

#: ../../template-letters.rst:219
msgid ""
"From your on-line profile on github, I see you're located in Xxxx, is "
"that correct?"
msgstr "github의 온라인 프로필을 보니 Xxx에 있는 것 같은데 맞나요?"

#: ../../template-letters.rst:221
msgid ""
"If you are indeed in Xxxx, you live very close to gardens Yyyy and Zzzz."
"  Maybe you would consider the following proposition?  All would start by"
" contacting the botanical garden there, and get to know what software "
"they use (what it offers, and at which price) and if they're interested "
"in switching to ghini.desktop+pocket+tour+web."
msgstr ""
"만약 여러분이 Xxxx에 있다면, 여러분은 Yyyy와 Zzz 정원에 매우 가까이 삽니다.  다음 제안을 고려해 보시겠습니까?  먼저 "
"식물원에 연락하여 그들이 사용하는 소프트웨어(그것이 무엇을 제공하는지, 가격은 얼마인지)와 ghini.desktop+pocket+tour+"
"web으로 전환하고 싶은지 알아봅니다."

#: ../../template-letters.rst:226
msgid ""
"The business model within Ghini is that the software is free and you get "
"it for free, but time is precious and if a garden needs help, they should"
" be ready to contribute.  Maybe you already have a full-time job and "
"don't need more things to do, but in case you're interested, or you have "
"friends who would be, I'm sure we can work something out."
msgstr ""
"기니의 비즈니스 모델은 소프트웨어가 무료이고 무료로 제공되지만 시간은 소중하며 정원에 도움이 필요하면 언제든지 도움을 줄 수 있어야 "
"합니다.  아마 당신은 이미 정규직이 있고 더 많은 일을 할 필요가 없을지도 모르지만, 만약 당신이 관심이 있거나 친구가 있다면, 우리가 "
"뭔가 해결할 수 있을 거라고 확신해요."

#: ../../template-letters.rst:231
msgid "Let me know where you stand."
msgstr "당신이 어디에 서 있는지 알려주세요."

#: ../../template-letters.rst:233
msgid "best regards, and again thanks for all your contributed translations."
msgstr "안녕히 계십시오, 그리고 다시 한번 당신의 모든 번역에 감사드립니다."

#: ../../template-letters.rst:235
msgid "Mario Frasca"
msgstr "마리오 프라스카"

#: ../../use_cases-jbq.rst:2
msgid "Quito Botanical Garden"
msgstr "키토 식물원"

#: ../../use_cases-jbq.rst:4
msgid ""
"At the JBQ, Quito Botanical Garden, we have adopted the Ghini software in"
" April 2015. Since that time, we have accumulated experience with the "
"program, and we are ourselves in need to document it, in order to secure "
"the knowledge to the institution. We are happy to share it."
msgstr ""
"JBQ, 키토 식물원에서는 2015년 4월에 Ghini 소프트웨어를 채택했습니다. 그 이후로 우리는 그 프로그램에 대한 경험을 축적해 "
"왔고, 그 지식을 기관에 확보하기 위해 그 내용을 문서화해야 할 필요가 있다. 우리는 그것을 공유하게 되어 기쁘다."

#: ../../use_cases-jbq.rst:10
msgid "Technical"
msgstr "테크니컬"

#: ../../use_cases-jbq.rst:12
msgid ""
"We work on GNU/Linux, a platform that many users don't master, and our "
"database is inside of a remote database management system. This implies "
"steps that are not obvious to the casual end user."
msgstr ""
"우리는 많은 사용자들이 마스터하지 못하는 플랫폼인 GNU/Linux에서 일하며, 우리의 데이터베이스는 원격 데이터베이스 관리 시스템의 "
"내부에 있습니다. 이는 일반 사용자에게 명확하지 않은 단계를 의미합니다."

#: ../../use_cases-jbq.rst:16
msgid "How to start a program"
msgstr "프로그램을 시작하는 방법"

#: ../../use_cases-jbq.rst:19
msgid ""
"To start a program given its name, hit the |loose_png| key next to Alt, "
"or click on |10000000000000300000002F89E0224ADF9EC09E_png|, then start "
"typing the name of the program, in our case “Ghini” or just click on the "
"program symbol |100000000000003100000031BB54CBDFA885EBAC_png|, appearing "
"near the left margin of your display."
msgstr ""
"이름이 지정된 프로그램을 시작하려면 Alt 옆에 있는 |lose_png| 키를 누르거나 |"
"1000000000000300002F89E0224를 클릭합니다.ADF9EC09E_png|, 그런 다음 프로그램 이름을 입력하기 "
"시작하세요. 우리의 경우 \"Ghini\" 또는 프로그램 기호 |100000000310000000031BB54를 "
"클릭하세요.CBDFA885EB디스플레이 왼쪽 여백 근처에 나타나는 AC_png|."

#: ../../use_cases-jbq.rst:25
msgid "Database server"
msgstr "데이터베이스 서버"

#: ../../use_cases-jbq.rst:28
msgid ""
"We chose for a centralised PostgreSQL database server. This way we are "
"protected from concurrent conflicting changes, and all changes are "
"simultaneously available on all ghini clients.  We did need to outsource "
"database server management."
msgstr ""
"중앙 집중식 Postgre를 선택했습니다.SQL 데이터베이스 서버. 이렇게 하면 동시 충돌 변경으로부터 보호되며 모든 변경 사항이 모든 "
"기니 클라이언트에서 동시에 제공됩니다.  데이터베이스 서버 관리를 아웃소싱해야 했습니다."

#: ../../use_cases-jbq.rst:33
msgid "adding a new user"
msgstr "새 사용자 추가"

#: ../../use_cases-jbq.rst:36
msgid ""
"Ghini keeps track of the user performing all sort of edits to the "
"database, and at the garden, apart from the stable users, we have all "
"sorts of temporary users writing to the database, that we decided we "
"would let Ghini help us keep track of database events."
msgstr ""
"Ghini는 데이터베이스에 대한 모든 종류의 편집을 수행하는 사용자를 추적합니다. 그리고 정원에 있는 안정적인 사용자들을 제외하고, "
"우리는 모든 종류의 임시 사용자가 데이터베이스에 쓰도록 합니다. 우리는 Ghini가 데이터베이스 이벤트를 추적하도록 돕기로 결정했습니다."

#: ../../use_cases-jbq.rst:41
msgid ""
"Since we work using PostgreSQL, the users that Ghini stores in the "
"database history are the database users, not the system users."
msgstr ""
"Postgre를 사용하여 작업하기 때문에Ghini가 데이터베이스 기록에 저장하는 사용자는 시스템 사용자가 아니라 데이터베이스 사용자입니다."

#: ../../use_cases-jbq.rst:44
msgid ""
"Each user knows their own password, and only knows that one. Our super-"
"user, responsible for the database content, also has the ``bauble`` "
"fictional user password, which we only only use to create other users."
msgstr ""
"각 사용자는 자신의 암호를 알고 있으며 이 암호만 알고 있습니다. 데이터베이스 콘텐츠를 담당하는 우리의 수퍼유저도 다른 사용자를 만들기 "
"위해서만 사용하는 \"보글\" 가상 사용자 암호를 가지고 있다."

#: ../../use_cases-jbq.rst:49
msgid ""
"We do not use account names like ``voluntario``, because such accounts do"
" not help us associate the name to the person."
msgstr ""
"우리는 ``볼런타리오\"와 같은 계정 이름을 사용하지 않는데, 그러한 계정은 우리가 그 사람과 이름을 연관시키는 데 도움이 되지 않기 "
"때문이다."

#: ../../use_cases-jbq.rst:52
msgid "— adding a new system user (linux/osx)"
msgstr "— 새 시스템 사용자 추가(리눅스/osx)"

#: ../../use_cases-jbq.rst:55
msgid ""
"Adding a system user is not strictly necessary, as ghini does not use it "
"in the logs, however, adding a system user allows for separation of "
"preferences, configured connections, search history. On some of our "
"systems we have a single shared account with several configured "
"connections, on other systems we have one account per user."
msgstr ""
"기니가 로그에서 시스템 사용자를 사용하지 않기 때문에 시스템 사용자를 추가할 필요가 없지만 시스템 사용자를 추가하면 기본 설정, 구성된 "
"연결, 검색 기록을 분리할 수 있습니다. 일부 시스템에서는 여러 연결이 구성된 단일 공유 계정이 있고, 다른 시스템에서는 사용자당 하나의 "
"계정이 있습니다."

#: ../../use_cases-jbq.rst:62
msgid ""
"On systems with one account per user, our users have a single configured "
"connection, and we hold the database password in the "
"``/home/<account>/.pgpass`` file.  This file is only readable for the "
"``<account>`` owner."
msgstr ""
"기니가 로그에서 시스템 사용자를 사용하지 않기 때문에 시스템 사용자를 추가할 필요가 없지만 시스템 사용자를 추가하면 기본 설정, 구성된 "
"연결, 검색 기록을 분리할 수 있습니다. 일부 시스템에서는 여러 연결이 구성된 단일 공유 계정이 있고, 다른 시스템에서는 사용자당 하나의 "
"계정이 있습니다."

#: ../../use_cases-jbq.rst:67
msgid ""
"On systems with a shared account, the user must select their own "
"connection and type the corresponding password."
msgstr "공유 계정이 있는 시스템에서는 사용자가 직접 연결을 선택하고 해당 암호를 입력해야 합니다."

#: ../../use_cases-jbq.rst:70
msgid "These are the steps to add system users::"
msgstr "다음은 시스템 사용자를 추가하는 단계입니다::"

#: ../../use_cases-jbq.rst:76
msgid "— adding a new database user"
msgstr "— 새 데이터베이스 사용자 추가"

#: ../../use_cases-jbq.rst:79
msgid ""
"Ghini has a very minimal interface to user management, it only works with"
" postgresql and it very much lacks maintainance.  We have opened issues "
"that will allow us use it, for the time being we use the ``create-"
"role.sh`` script::"
msgstr ""
"Ghini는 사용자 관리에 대한 인터페이스가 매우 적으며 postgresql에서만 작동하며 유지관리가 매우 부족합니다.  우리는 당분간 "
"그것을 사용할 수 있는 문제들을 열어 왔다.shipper 스크립트::"

#: ../../use_cases-jbq.rst:96
msgid ""
"The redundant ``alter role`` following the ``create role`` lets us apply "
"the same script also for correcting existing accounts."
msgstr "``역할 만들기\"에 이어 중복된 ``역할 바꾸기\"를 통해 기존 계정 수정에도 동일한 스크립트를 적용할 수 있다."

#: ../../use_cases-jbq.rst:99
msgid ""
"Our ghini database is called ``bauble``, and ``bauble`` is also the name "
"of our database super user, the only user with ``CREATEROLE`` privilege."
msgstr ""
"우리의 기니 데이터베이스는 \"바보블\"이라고 불리며 \"바보블\"은 \"크리에테롤\" 특권을 가진 유일한 사용자인 우리의 데이터베이스 "
"수퍼유저의 이름이기도 하다."

#: ../../use_cases-jbq.rst:103
msgid ""
"For example, the following invocation would create the user ``willem`` "
"with password ``orange``, on the ``bauble`` database hosted at "
"192.168.5.6::"
msgstr ""
"예를 들어, 다음 호출은 비밀번호가 \"주황색\"인 사용자 \"윌렘\"을 192.168.5.6에 호스팅되는 \"보블\" 데이터베이스에 "
"생성한다::"

#: ../../use_cases-jbq.rst:109
msgid "Understanding when to update"
msgstr "업데이트 시기 이해"

#: ../../use_cases-jbq.rst:111
msgid "Updating the system"
msgstr "시스템 업데이트"

#: ../../use_cases-jbq.rst:114
msgid ""
"Ubuntu updates are a lot lighter and easier than with Windows. So "
"whenever the system suggests an update, we let it do that. Generally, "
"there's no need to wait during the update nor to reboot after it's done."
msgstr ""
"Ubuntu 업데이트는 Windows보다 훨씬 가볍고 쉽습니다. 그래서 시스템이 업데이트를 제안할 때마다, 우리는 그렇게 하도록 내버려 "
"둡니다. 일반적으로 업데이트 중에 기다릴 필요도 없고 업데이트 후 재부팅할 필요도 없습니다."

#: ../../use_cases-jbq.rst:119
msgid "Updating ghini"
msgstr "지니 업데이트"

#: ../../use_cases-jbq.rst:122
msgid ""
"The first window presented by Ghini looks like this. Normally, you don't "
"need do anything in this window, just press enter and get into the main "
"program screen."
msgstr ""
"기니가 처음 선물한 창문은 이렇게 생겼습니다. 일반적으로 이 창에서는 아무것도 할 필요가 없습니다. Enter 키를 누르고 메인 프로그램 "
"화면으로 들어가시면 됩니다."

#: ../../use_cases-jbq.rst:128
msgid ""
"Occasionally, at the top of the screen an information text will appear, "
"telling you that a newer version is available on-line."
msgstr "때때로 화면 맨 위에 최신 버전을 온라인으로 사용할 수 있음을 알리는 정보 텍스트가 나타납니다."

#: ../../use_cases-jbq.rst:133
msgid ""
"The update procedure is simple, and it depends on the operating system "
"you use, we're not explaining here again."
msgstr "업데이트 절차는 간단하며, 사용하는 운영 체제에 따라 다릅니다. 여기서는 다시 설명하지 않습니다."

#: ../../use_cases-jbq.rst:136
msgid ""
"It is generally a good idea updating the software.  If in doubt, contact "
"the author, or write to the group."
msgstr "일반적으로 소프트웨어를 업데이트하는 것이 좋습니다.  확실하지 않은 경우 작성자에게 문의하거나 그룹에 기록합니다."

#: ../../use_cases-jbq.rst:139
msgid "understanding ghini initial screen"
msgstr "기니 초기 화면 이해"

#: ../../use_cases-jbq.rst:141
msgid "Complete screen"
msgstr "전체 화면"

#: ../../use_cases-jbq.rst:144
msgid "At the moment of writing, our initial screen looked like this:"
msgstr "글을 쓰는 순간, 우리의 초기 화면은 다음과 같았다:"

#: ../../use_cases-jbq.rst:148
msgid ""
"Apart from the main application menu, Ghini offers three special "
"interface sections with information and tools to explore the database."
msgstr ""
"기본 응용 프로그램 메뉴 외에도 Ghini는 데이터베이스를 탐색할 수 있는 정보와 도구가 포함된 세 가지 특수 인터페이스 섹션을 "
"제공합니다."

#: ../../use_cases-jbq.rst:152
msgid "Numeric overview"
msgstr "숫자 개요"

#: ../../use_cases-jbq.rst:155
msgid ""
"The table in the right half of the screen presents a summary of all the "
"registered plants can be observed.  Each entry printed in bold is a link "
"to the query selecting the corresponding objects."
msgstr ""
"화면 오른쪽의 표에는 모든 등록된 식물을 관찰할 수 있는 요약이 나와 있습니다.  굵게 인쇄된 각 항목은 해당 개체를 선택하는 쿼리에 "
"대한 링크입니다."

#: ../../use_cases-jbq.rst:161
msgid "Stored queries"
msgstr "저장된 쿼리"

#: ../../use_cases-jbq.rst:164
msgid ""
"The lower half of the right hand side contains a set of stored queries.  "
"While you can edit them to your liking, our hints include selecting those"
" accessions that have not been identified at rank species.  And one for "
"the database history."
msgstr ""
"오른 쪽 하반신은 저장된 쿼리의 집합이 들어 있습니다.반면 당신은 당신의 좋아하는 그들 편집할 수 있는, 우리의 힌트는 계급종에 밝혀지지 "
"않고 있는 accessions 선택 포함한다.중의 하나는 데이터베이스 역사로."

#: ../../use_cases-jbq.rst:171
msgid "Query and action buttons"
msgstr "쿼리 및 작업 단추"

#: ../../use_cases-jbq.rst:174
msgid ""
"At the top of this screen you can find the field in which you would enter"
" your searches."
msgstr "이 화면 상단에서 검색을 입력할 필드를 찾을 수 있습니다."

#: ../../use_cases-jbq.rst:179
msgid ""
"With the |100000000000001C00000020F4C7873186014F2F_png| button, in the "
"form of a house, you can return from your searches to the main screen."
msgstr ""
"|1000000000001C00000020F4C7873186014F2로F_png| 버튼은 집 형태로 검색에서 기본 화면으로 돌아갈 수 "
"있습니다."

#: ../../use_cases-jbq.rst:182
msgid ""
"With the |100000000000001B000000207EC6F9075C9D3669_png| button, in the "
"form of an arrow, you can return to your last search."
msgstr ""
"|100000000001B0000207로EC6F9075C9D3669_png| 버튼 화살표 형태로 마지막 검색으로 돌아갈 수 있습니다."

#: ../../use_cases-jbq.rst:184
msgid ""
"With the |100000000000001C0000001FB8A1F75F7A5EF877_png| button, in the "
"form of a gear, you can start the \"Query Builder\", which helps you "
"compose complex searches in a simple, graphical way."
msgstr ""
"|1000000001C00001로FB8A1F75F7A5EF877_png| 버튼은 \"Query Builder\"를 시작할 수 있으며, "
"이는 복잡한 검색을 간단하고 그래픽으로 구성할 수 있도록 도와줍니다."

#: ../../use_cases-jbq.rst:189
msgid ""
"We often have volunteers who only work at the garden for a very short "
"time. It was with them in mind that we have developed a `hyper-simplified"
" view <goal.html#hypersimplified-view>`_ on the ghini database structure."
msgstr ""
"우리는 종종 아주 짧은 시간 동안만 정원에서 일하는 자원봉사자들을 가지고 있다. 우리가 기니 데이터베이스 구조에 대한 '초간단 뷰"
"(hyper-simplified view)'를 개발한 것은 그들을 염두에 둔 것이었다."

#: ../../use_cases-jbq.rst:193 ../../use_cases-jbq.rst:597
msgid "Details"
msgstr "상세"

#: ../../use_cases-jbq.rst:196
msgid ""
"The two figures here show all that our temporary collaborators need to "
"know."
msgstr "여기 이 두 수치는 임시 협력자들이 알아야 할 모든 것을 보여줍니다."

#: ../../use_cases-jbq.rst:199
msgid "Taxonomy & Collection"
msgstr "분류법 & 수집"

#: ../../use_cases-jbq.rst:199
msgid "Garden"
msgstr "정원"

#: ../../use_cases-jbq.rst:204
msgid ""
"At times, the program gives error messages. |dontpanic_png|, retry, or "
"report to the developers."
msgstr "때때로, 프로그램은 오류 메시지를 줍니다. |panspanic_the|, 다시 시도하거나 개발자에게 보고합니다."

#: ../../use_cases-jbq.rst:207
msgid "Network problems"
msgstr "네트워크 문제"

#: ../../use_cases-jbq.rst:210
msgid ""
"In order to work, the program needs a stable network connection to the "
"database server. It can happen: you start the program, and it can't "
"connect to our database server. You would then get a rather explicit but "
"very badly typeset error message."
msgstr ""
"이 프로그램이 작동하기 위해서는 데이터베이스 서버에 대한 안정적인 네트워크 연결이 필요합니다. 프로그램을 시작하면 데이터베이스 서버에 "
"연결할 수 없습니다. 그런 다음 명시적이지만 매우 잘못된 형식의 오류 메시지가 표시됩니다."

#: ../../use_cases-jbq.rst:217
msgid "Just ignore it and try again."
msgstr "그냥 무시하고 다시 해보세요."

#: ../../use_cases-jbq.rst:219
msgid "Search fails with error"
msgstr "검색 실패 오류"

#: ../../use_cases-jbq.rst:222
msgid ""
"Sometimes and without any apparent cause, a search will not run "
"successfully, and a window with an error message will be displayed. In "
"this case you only have to try to perform the same search again."
msgstr ""
"경우에 따라 뚜렷한 원인 없이 검색이 성공적으로 실행되지 않고 오류 메시지가 표시된 창이 표시됩니다. 이 경우 동일한 검색을 다시 "
"시도하기만 하면 됩니다."

#: ../../use_cases-jbq.rst:227
msgid "An example of such an error message:"
msgstr "이러한 오류 메시지의 예:"

#: ../../use_cases-jbq.rst:231
msgid "Search does not return something I just inserted"
msgstr "방금 삽입한 내용이 검색에서 반환되지 않습니다"

#: ../../use_cases-jbq.rst:234
msgid ""
"Accession codes starting with zero and composed of just numbers, as for "
"example ``016489`` are considered by the software as numbers, so if you "
"don't enclose the search string in quotes, any leading 0 will be stripped"
" and the value will not be found."
msgstr ""
"예를 들어 \"016489\"와 같이 0으로 시작하고 숫자로만 구성된 등록 코드는 소프트웨어에서 숫자로 간주되므로 검색 문자열을 따옴표로 "
"묶지 않으면 선행 0이 제거되고 값을 찾을 수 없습니다."

#: ../../use_cases-jbq.rst:239
msgid "Try again, but enclose your search string in single or double quotes."
msgstr "다시 시도하지만 검색 문자열을 작은 따옴표나 큰 따옴표로 묶습니다."

#: ../../use_cases-jbq.rst:243
msgid "Number on the label"
msgstr "레이블의 번호"

#: ../../use_cases-jbq.rst:243
msgid "corresponding search"
msgstr "상응하는 수색"

#: ../../use_cases-jbq.rst:248
msgid ""
"Please note: when you look for a Plant code, not an Accession, the "
"leading zero becomes optional, so in the above example it's maybe easier "
"to type ``16489.1``."
msgstr ""
"참고: 가입이 아닌 플랜트 코드를 찾으면 선행 0이 선택 사항이 되므로 위의 예에서 \"16489.1\"을 입력하는 것이 더 쉬울 수 "
"있습니다."

#: ../../use_cases-jbq.rst:252
msgid ""
"A serious situation happened once, and we absolutely want to prevent it "
"from happening again: a user deleted a genus, with everything that was "
"below it, species and accessions, and synonyms."
msgstr ""
"심각한 상황이 한 번 일어났고, 우리는 다시는 이런 일이 일어나지 않게 하고 싶습니다. 한 사용자가 그 아래에 있는 모든 것, 종과 "
"접속, 동의어를 포함하는 속들을 삭제했습니다."

#: ../../use_cases-jbq.rst:256
msgid "Solving it with user permissions"
msgstr "사용자 권한으로 해결"

#: ../../use_cases-jbq.rst:259
msgid ""
"We propose to have different connection profiles, associated to different"
" database users, each user with all needed permissions."
msgstr "우리는 필요한 모든 권한을 가진 각 사용자에게 서로 다른 데이터베이스 사용자와 관련된 다른 연결 프로필을 가질 것을 제안한다."

#: ../../use_cases-jbq.rst:263
msgid "Full permission (BD-JBQ)"
msgstr "전체 권한(BD-JBQ)"

#: ../../use_cases-jbq.rst:263
msgid "Only qualified personnel get this kind of access."
msgstr "자격을 갖춘 사람만 이런 종류의 접근을 할 수 있다."

#: ../../use_cases-jbq.rst:268
msgid "Insert and update (BD-JBQ-limitado)"
msgstr "삽입 및 업데이트(BD-JBQ-limitado)"

#: ../../use_cases-jbq.rst:266
msgid ""
"We use this one for those users who come help us for a limited time, and "
"who did not get a complete introduction to database concepts. It is meant"
" to prevent costly mistakes."
msgstr ""
"우리는 제한된 시간 동안 우리를 도와 주고, 이들 완전한 도입 얻지 못하는 그런 사용자들의 이러한 걸 쓰도록 해요.그것은 비용이 많이 "
"드는 실수를 막기 위해 의도된 것이다."

#: ../../use_cases-jbq.rst:271
msgid "Read only (BD-JBQ-lectura)"
msgstr "읽기 전용(BD-JBQ-electura)"

#: ../../use_cases-jbq.rst:271
msgid "it can be shared with anyone visiting the garden"
msgstr "그것은 정원을 방문하는 모든 사람과 공유할 수 있다"

#: ../../use_cases-jbq.rst:273
msgid ""
"You select the connection at start-up, and the software asks you for the "
"password corresponding to the connection you selected."
msgstr "시작 시 연결을 선택하면 소프트웨어가 선택한 연결에 해당하는 암호를 묻습니다."

#: ../../use_cases-jbq.rst:278
msgid ""
"If you want to review the details of the connection, click on the ▶ next "
"to 'Connection Details', it will change to ▼, and the connection window "
"will be displayed as one of the following:"
msgstr "연결 세부 정보를 검토하려면 '연결 세부 정보' 옆의 ▶를 클릭하면 ▼로 변경되고 연결 창이 다음 중 하나로 표시됩니다:"

#: ../../use_cases-jbq.rst:286
msgid ""
"As you can see, we are connecting to the same database server, each "
"connection uses the same database on the server, but with different user."
msgstr ""
"보시는 것처럼 동일한 데이터베이스 서버에 연결하고 있으며, 각 연결은 서버에서 동일한 데이터베이스를 사용하지만 사용자는 다릅니다."

#: ../../use_cases-jbq.rst:290
msgid "Thinking further about it"
msgstr "그것에 대해 더 깊이 생각하면서"

#: ../../use_cases-jbq.rst:293
msgid ""
"On the other hand, we are questioning if it is at all appropriate, "
"letting any user delete something at such high level as a family, or a "
"genus, or, for that matters, of anything connected to accessions in the "
"collection."
msgstr ""
"반면에, 우리는 그것이 적절한지에 대해 의문을 제기하고 있습니다. 어떤 사용자라도 컬렉션에 있는 접근과 관련된 어떤 것에 대한 가족, "
"속, 또는 그 문제에 대한 높은 수준에서 어떤 것을 삭제하도록 합니다."

#: ../../use_cases-jbq.rst:298
msgid ""
"The ghini way to question the software features, is by opening a "
"`corresponding issue "
"<https://github.com/Ghini/ghini.desktop/issues/218>`_."
msgstr ""
"소프트웨어 기능에 의문을 제기할 수 있는 가장 중요한 방법은 'https://github.com/Ghini/ghini.desktop/"
"issues/218'이라는 최신호를 여는 것이다."

#: ../../use_cases-jbq.rst:302
msgid ""
"When contacting the developers, they will definitely ask for technical "
"information, or at least to see a screen-shot.  Help them help you."
msgstr "개발자에게 문의할 때 기술 정보를 요청하거나 스크린샷이라도 볼 수 있습니다.  그들이 널 도울수 있게 도와줘."

#: ../../use_cases-jbq.rst:305
msgid "Taking a screen-shot"
msgstr "스크린샷 찍기"

#: ../../use_cases-jbq.rst:308
msgid ""
"On Linux there are three ways to create a screen-shot, all involve "
"hitting the 'PrtSc' key.  The most practical one is possibly hitting the "
"'PrtSc' key in combination with Ctrl and Shift. This will start an "
"interactive screen copy tool. You select a rectangle and the area is "
"copied in the clipboard.  Paste it in the email you're writing, or in the"
" chat line where the developers are trying to help you."
msgstr ""
"Linux에서는 스크린샷을 만드는 세 가지 방법이 있으며, 모든 방법은 'PrtSc' 키를 누르는 것입니다.  가장 실용적인 것은 "
"Ctrl 및 Shift 키와 함께 'PrtSc' 키를 치는 것입니다. 이렇게 하면 대화형 화면 복사 도구가 시작됩니다. 사각형을 선택하면 "
"영역이 클립보드에 복사됩니다.  작성 중인 전자 메일이나 개발자가 도우려는 채팅 줄에 붙여넣습니다."

#: ../../use_cases-jbq.rst:316
msgid "Where are the logs"
msgstr "로그는 어디에 있습니까"

#: ../../use_cases-jbq.rst:319
msgid ""
"Ghini continuously saves a very informative log file, in the "
"``~/.bauble/bauble.log`` file.  Don't bother opening it, just send it "
"over.  It contains loads of technical information."
msgstr ""
"Ghini는 매우 유용한 로그 파일을 \"~~/.bauable/boule\"에 지속적으로 저장합니다.로그 파일  열어볼 필요 없이 그냥 "
"보내 주세요.  여기에는 많은 기술 정보가 포함되어 있습니다."

#: ../../use_cases-jbq.rst:323
msgid "Continuous unmanned alerting"
msgstr "연속 무인 경보"

#: ../../use_cases-jbq.rst:326
msgid ""
"An other option is to activate the sentry handler. It will notify our "
"sentry server of any serious situations in the software.  If you "
"registered, the developers will know how to contact you if necessary."
msgstr ""
"다른 옵션은 보초 처리기를 활성화하는 것입니다. 그러면 소프트웨어의 심각한 상황을 당사의 Sentry 서버에 알립니다.  등록하신 경우, "
"필요한 경우 개발자가 귀하에게 연락할 방법을 알게 됩니다."

#: ../../use_cases-jbq.rst:331
msgid ""
"To the healthy paranoid: we're not monitoring what you're doing, we're "
"monitoring how our software works.  You can always opt out."
msgstr ""
"건강한 편집증 환자에게 : 우리는 당신이 무엇을 하고 있는지 감시하는 것이 아니라 우리의 소프트웨어가 어떻게 작동하는지 감시하는 "
"것입니다.  언제든지 탈퇴할 수 있습니다."

#: ../../use_cases-jbq.rst:334
msgid ""
"You activate the Sentry handler in the ``:prefs`` page: look for the row "
"with name ``bauble.use_sentry_handler``, if the value is not what you "
"wish, double click on the line and it will change to the other value."
msgstr ""
"'':prefs'' 페이지에서 Sentry 핸들러를 활성화합니다. \"bauable.use_sentry_handler\"라는 이름의 행을 "
"찾고, 이 값이 원하는 값이 아니면 줄을 두 번 클릭하면 다른 값으로 변경됩니다."

#: ../../use_cases-jbq.rst:340
msgid "Taxonomy"
msgstr "분류법"

#: ../../use_cases-jbq.rst:342
msgid "Introduction"
msgstr "Taxonomy"

#: ../../use_cases-jbq.rst:344
msgid "Orchidaceae taxonomic complexity"
msgstr "난초과 분류학적 복잡성"

#: ../../use_cases-jbq.rst:347
msgid ""
"At the JBQ, we work most of all with orchids, family Orchidaceae, one of "
"the largest plant families, with no less than 850 genera, organized "
"—according to Dressler— in approximately 70 subtribes, 22 tribes, 5 "
"subfamilies.  How we represent this information is not obvious and needs "
"be explained."
msgstr ""
"JBQ에서는 850개 이상의 속(Dressler)을 가진 가장 큰 식물군 중 하나인 난초과(Ochidaceae)와 함께 70여 개의 "
"아족, 22개 부족, 5개 아족으로 구성되어 있습니다.  우리가 이 정보를 어떻게 표현하느냐는 명확하지 않으며 설명이 필요하다."

#: ../../use_cases-jbq.rst:352
msgid ""
"The taxonomy of the Orchidaceae family is continuously being reviewed. "
"Genera get added, refused, reorganized, recognized as synonyms, some "
"taxonomists prefer grouping species or genera in a new way, others split "
"them again and differently, botanists of different nationalities may have"
" different views on the matter.  All this sounds very complex and "
"specialistic, but it's part of our daily routine, and it can all be "
"stored in our Ghini database."
msgstr ""
"난초과의 분류법은 지속적으로 검토되고 있다. 추가, 거부, 재구성, 동의어로 인식되고, 어떤 분류학자들은 종이나 속들을 새로운 방식으로 "
"분류하는 것을 선호하며, 다른 분류학자들은 그것들을 다시 나누고, 다르게, 다른 국적의 식물학자들은 이 문제에 대해 다른 견해를 가질 수 "
"있다.  이 모든 것은 매우 복잡하고 특별하게 들리지만, 이것은 우리의 일상 생활의 일부이고, 우리의 Ghini 데이터베이스에 저장될 수 "
"있습니다."

#: ../../use_cases-jbq.rst:360
msgid "Identifying at rank Genus, or Family"
msgstr "순위 속, 또는 패밀리에서"

#: ../../use_cases-jbq.rst:362
msgid "At rank genus"
msgstr "랫속"

#: ../../use_cases-jbq.rst:365
msgid ""
"Ghini-1.0 prescribes that an accession is identified at rank species, in "
"all cases. The current maintainer acknowledges that this is a mistake, "
"coming from the early Bauble days, and which Ghini-1.0 has in common with"
" other botanic software. Until this is fixed, we rely on established "
"practices."
msgstr ""
"Ghini-1.0은 모든 경우에 순위 종에서 등록 여부를 확인한다고 규정한다. 현재의 관리인은 이것이 초기 바우블 시대의 실수이며, 기니-"
"1.0이 다른 식물 소프트웨어와 공통적으로 가지고 있다는 것을 인정한다. 이 문제가 해결될 때까지 우리는 확립된 관행에 의존합니다."

#: ../../use_cases-jbq.rst:371
msgid ""
"If an accession is identified at rank genus, we add a fictive species in "
"that genus, we don't specify its species epithet (we don't know that) and"
" we add an unranked epithet in the infraspecific information section, "
"like this:"
msgstr ""
"순위 속에서의 등록이 확인되면, 우리는 그 속에 가공 종을 추가하고, 그 종의 별칭을 지정하지 않으며(우리는 그것을 알지 못한다), "
"다음과 같이 초특정 정보 섹션에 순위 없는 별칭을 추가한다:"

#: ../../use_cases-jbq.rst:378
msgid "When displayed in a search result, it shows like this:"
msgstr "검색 결과에 표시되는 내용은 다음과 같습니다:"

#: ../../use_cases-jbq.rst:382
msgid "At rank family"
msgstr "랭크 패밀리"

#: ../../use_cases-jbq.rst:385
msgid ""
"If an accession is only identified at rank family, we need a fictive "
"genus, to which we can add the fictive species. Since our garden is "
"primarily focusing on Orchidaceae, we use the very short name **Zzz** for"
" the fictive genus within the family, like this:"
msgstr ""
"만약 입주가 순위 과에서만 확인된다면, 우리는 가공의 종을 추가할 수 있는 가공의 속(,)을 필요로 한다. 우리 정원은 주로 "
"난초과(Ochidaceae)에 초점을 맞추고 있기 때문에, 우리는 다음과 같은 가공의 속명을 **Zz***로 쓴다:"

#: ../../use_cases-jbq.rst:392
msgid ""
"The current maintainer suggests to use the prefix **Zzz-** and behind the"
" prefix to write the family name, possibly removing the trailing **e**.  "
"Removal of the trailing **e** is useful in order not to get results that "
"include genus names when you as for stuff ending in **aceae**."
msgstr ""
"현재 유지 관리자는 접두사 **Zz-**와 접두사 뒤에 있는 **e*를 사용하여 패밀리 이름을 쓸 것을 제안하며, 후행 **e**를 "
"제거할 수 있습니다.  **e**로 끝나는 물건의 경우 **e**로 끝나는 물건의 경우 속명을 포함하는 결과를 얻지 않는 데 유용합니다."

#: ../../use_cases-jbq.rst:398
msgid ""
"Apart from the aforementioned **Zzz** genus in the Orchidaceae family, we"
" follow this suggested practice, so for example our collection would "
"include *Zzz-cactacea* or *Zzz-bromeliacea*."
msgstr ""
"앞에서 언급한 **Zz** 속과와 별도로, 우리는 제안된 관행을 따르므로, 예를 들어 우리의 컬렉션에는 *Zz-cactacea* 또는 "
"*Zz-bromeliacea*가 포함된다."

#: ../../use_cases-jbq.rst:402
msgid ""
"Remember: our **Zzz** genus is a fictive genus in the **Orchidaceae** "
"family, do not use it as unspecified genus in other families."
msgstr ""
"기억하라: 우리의 **Zz** 속은 **Orchidaceae* 과의 가공 속이며, 다른 과에서는 지정되지 않은 속으로서 사용하지 말라."

#: ../../use_cases-jbq.rst:406
msgid ""
"Identifying at a rank that is not allowed by the software (eg: Subtribe, "
"or Subfamily)"
msgstr "소프트웨어에서 허용되지 않는 순위 식별(예: 하위 항목 또는 하위 제품군)"

#: ../../use_cases-jbq.rst:408
msgid "At rank subtribe"
msgstr "서열로"

#: ../../use_cases-jbq.rst:411
msgid ""
"We sometimes can't identify a taxon at rank genus, but we do manage to be"
" more precise than just \"it's an orchid\". Quite often we are able to "
"indicate the subtribe, this is useful when you want to produce hybrids."
msgstr ""
"우리는 때때로 랭크 속에서는 분류법을 확인할 수 없지만, 우리는 단지 \"그것은 난초\"일 뿐 아니라 더 정확하게 할 수 있다. 우리는 "
"종종 하위 계급을 나타낼 수 있습니다. 이것은 여러분이 하이브리드를 생산하고 싶을 때 유용합니다."

#: ../../use_cases-jbq.rst:416
msgid ""
"The software does not let us store ranks which are intermediate between "
"family and genus, so we need to invent something, and this is what we do:"
msgstr ""
"소프트웨어는 우리가 가족과 속 사이의 중간 순위를 저장할 수 있도록 해주지 않습니다. 그래서 우리는 무언가를 발명해야 합니다. 그리고 "
"이것이 우리가 하는 일입니다:"

#: ../../use_cases-jbq.rst:420
msgid ""
"We insert a fictive genus, naming it as the subtribe, prefixing it with "
"'Zzx-', like in this example:"
msgstr "우리는 이 예에서와 같이 'Zzx-'로 앞에 붙이는, 그것을 하위 종족으로 명명하는 가공의 속들을 삽입한다:"

#: ../../use_cases-jbq.rst:425
msgid "This Zzx-Laeliinae is some genus in the Laeliinae subtribe."
msgstr "Zzx-Laelliinae속은 Laelliinae속(Laeliae)에 속하는 속이다."

#: ../../use_cases-jbq.rst:427
msgid ""
"In order to be able to select genera by subtribe, we also add a note to "
"the Zzx-Laeliinae fictive genus as well as for all real genera in that "
"subtribe, note category subtribus, note value the subtribe name."
msgstr ""
"하위 계통별로 범주를 선택할 수 있도록 Zzx-Laelliinae 가상 속뿐만 아니라 해당 하위 계통, 노트 범주 하위 계통, 노트 값 "
"하위 계통의 모든 실제 속에도 노트를 추가한다."

#: ../../use_cases-jbq.rst:432
msgid "This allows for queries like:"
msgstr "이렇게 하면 다음과 같은 쿼리가 허용됩니다:"

#: ../../use_cases-jbq.rst:436
msgid ""
"We are very much looking forward to seeing that `issue-9 "
"<https://github.com/Bauble/bauble.classic/issues/9>`_ solved!"
msgstr ""
"우리는 '이슈-9 https://github.com/Bauble/bauble.classic/issues/9'이 해결되기를 매우 고대하고 "
"있다!"

#: ../../use_cases-jbq.rst:439
msgid "At rank subfamily, tribe"
msgstr "계급 하위 가족, 부족"

#: ../../use_cases-jbq.rst:442
msgid ""
"Just as we reserved the prefix Zzx- for subtribe, we reserve the prefixes"
" Zzy- for tribe, Zzw- for subfamily."
msgstr "우리가 하위 계급을 위해 접두사 Zzx-를 예약한 것처럼, 부족의 경우 Zzy-, 하위 계열의 경우 Zzw-를 예약한다."

#: ../../use_cases-jbq.rst:445
msgid ""
"In particular, the subfamily information is relevant, because there are "
"subfamilies within the Orchidaceae family which are not further "
"separated."
msgstr "특히 난초과에는 더 이상 분리되지 않는 아과가 존재하기 때문에 아과 정보가 관련이 있다."

#: ../../use_cases-jbq.rst:449
msgid "Editing the Accession identification - the Species details"
msgstr "등록 ID 편집 - 종 세부 정보"

#: ../../use_cases-jbq.rst:451
msgid "Placeholder species for individual accessions"
msgstr "개별 접근을 위한 자리 표시자 종"

#: ../../use_cases-jbq.rst:454
msgid ""
"Scenario one describes the identification of a single accession, which "
"had been associated to a \"generic\", placeholder species, something like"
" “*Zzz* sp” or “*Vanda* sp”;"
msgstr ""
"시나리오 1은 \"일반\" 자리 표시자 종과 연관된 단일 등록의 식별을 설명한다. \"*Zzz*sp\" 또는 \"*Vanda*sp\"와 "
"같은 것;"

#: ../../use_cases-jbq.rst:458
msgid ""
"In this case, when the plant species becomes known, we change the "
"association in the accession, selecting a different species."
msgstr "이 경우, 식물 종이 알려지면, 우리는 다른 종을 선택하면서 등록에서 연관성을 바꿉니다."

#: ../../use_cases-jbq.rst:463
msgid ""
"We do not edit the species, because there might be totally unrelated "
"accessions connected to the same placeholder species."
msgstr ""
"우리는 그 종을 편집하지 않습니다. 왜냐하면 같은 자리 표시자 종에 전혀 관련이 없는 접근법이 연결되어 있을 수 있기 때문입니다."

#: ../../use_cases-jbq.rst:466
msgid "Unknown species for multiple accessions"
msgstr "다중 액세스에 대해 알 수 없는 종"

#: ../../use_cases-jbq.rst:469
msgid ""
"A different case is when we have a whole batch of accessions, all "
"obviously the same species, but we haven't been able to identify it. In "
"this case, we associate the accessions with an incompletely specified "
"species, something like “*Zzz* sp-59”, preferably adding the taxonomist's"
" name, who made the association."
msgstr ""
"우리가 accessions, 분명히 같은 종의 전체를 배치한 다르지만, 우리는 그것을 식별할 수 있는 안 했어요.이 경우 우리는 "
"불완전하게 지정된 종들과 함께로 사전의 분류 학자의 이름을 추가하는 협회 만든 accessions“*Zzz* sp-59”처럼 뭔가 "
"연관시킨다."

#: ../../use_cases-jbq.rst:475
msgid ""
"A species like “*Vanda* sp-018599” is not a placeholder species, it is a "
"very concrete species, which we haven't yet identified."
msgstr "\"*반다* sp-018599\"와 같은 종은 자리 표시자 종이 아니라, 우리가 아직 확인하지 못한 매우 구체적인 종입니다."

#: ../../use_cases-jbq.rst:480
msgid ""
"In this case, when the species gets identified (and it could even be a "
"species nova), we directly edit the species, so all accessions that refer"
" to it get the change."
msgstr ""
"이 경우, 종들이 식별되면(그리고 종노바일 수도 있음) 우리는 종을 직접 편집할 수 있습니다. 그래서 그것을 가리키는 모든 접근법이 "
"변화를 가져올 수 있습니다."

#: ../../use_cases-jbq.rst:484
msgid "A new plants is relative to a species not yet in our collection."
msgstr "새로운 식물은 아직 우리 수집품에서 볼 수 없는 종에 상대적이다."

#: ../../use_cases-jbq.rst:486
msgid "Last minute species"
msgstr "마지막 종"

#: ../../use_cases-jbq.rst:489
msgid ""
"We start this from the Accession window and it's very simple, just click "
"on the **+** next to the species name, we get into the Species window."
msgstr "마지막 종등록 창에서 시작하면 매우 간단합니다. 종 이름 옆에 있는 **+***를 클릭하면 종 창이 나타납니다."

#: ../../use_cases-jbq.rst:493
msgid "Adding a species and using online taxonomic services"
msgstr "종 추가 및 온라인 분류 서비스 사용"

#: ../../use_cases-jbq.rst:495
msgid "Adding a new species — the plant list."
msgstr "새로운 종(식물 목록)을 추가합니다."

#: ../../use_cases-jbq.rst:498
msgid ""
"We start the obvious way: type the genus epithet, possibly select it from"
" the completion list, then type the species epithet, or at least your "
"best guess."
msgstr ""
"우리는 명확한 방법을 시작합니다. 속명을 입력하고, 완성 목록에서 선택한 다음, 종족속명을 입력합니다. 아니면 적어도 당신의 최선의 "
"추측입니다."

#: ../../use_cases-jbq.rst:504
msgid ""
"Next to the species epithet field there's a small button, |green_ball|, "
"which connects us to the plant list.  Click on it, a message area appears"
" at the top of the window."
msgstr ""
"종들의 묘지 옆에는 작은 버튼인 |green_ball|이 있는데, 이것은 우리를 식물 목록에 연결시켜줍니다.  이 옵션을 클릭하면 창 맨 "
"위에 메시지 영역이 나타납니다."

#: ../../use_cases-jbq.rst:510
msgid ""
"Depending on the speed of your internet connection, but also on how close"
" your best guess is to a correct published name, the top area will change"
" to something like this:"
msgstr "인터넷 연결 속도와 올바른 게시 이름에 대한 추측이 얼마나 가까운지에 따라 맨 위 영역이 다음과 같은 내용으로 변경됩니다:"

#: ../../use_cases-jbq.rst:516
msgid "Accept the hint and it will be as if you had typed the data yourself."
msgstr "힌트를 수락하면 데이터를 직접 입력한 것처럼 됩니다."

#: ../../use_cases-jbq.rst:520
msgid "Reviewing a whole selection — TNRS."
msgstr "전체 선택 항목 검토 - TNRS."

#: ../../use_cases-jbq.rst:523
msgid ""
"This is described in the manual, it's extremely useful, don't forget "
"about it."
msgstr "이것은 매뉴얼에 설명되어 있습니다. 매우 유용하죠. 잊지 마세요."

#: ../../use_cases-jbq.rst:528
msgid "Let the database fit the garden"
msgstr "데이터베이스가 정원에 맞도록 두십시오"

#: ../../use_cases-jbq.rst:530
msgid ""
"A never-ending task is reviewing what we have in the garden and have it "
"match what we have in the database."
msgstr "끝없는 과제는 정원에 있는 것을 검토하고 데이터베이스에 있는 것과 일치하도록 하는 것입니다."

#: ../../use_cases-jbq.rst:533
msgid "Initial status and variable resources"
msgstr "초기 상태 및 가변 리소스"

#: ../../use_cases-jbq.rst:536
msgid ""
"When we adopted ghini, we imported into it all that was properly "
"described in a filemaker database. That database focused solely on "
"Orchids and even so it was far from complete.  In practice, we still meet"
" labeled plants in the garden which have never been inserted in the "
"database."
msgstr ""
"Ghini를 채택했을 때 파일메이커 데이터베이스에 제대로 설명되어 있는 모든 것을 가져왔습니다. 그 데이터베이스는 오직 난초에만 초점을 "
"맞추었고 심지어 그것은 완전하지 않았다.  실제로, 우리는 여전히 데이터베이스에 삽입된 적이 없는 정원에서 라벨이 붙은 식물들을 만납니다."

#: ../../use_cases-jbq.rst:542
msgid ""
"From time to time, we manage to get resources to review the garden, "
"comparing it to the collection in the database, and the main activity is "
"to insert accession codes to the database, take pictures of the plant in "
"question, and note its location, all tasks that are described in the "
"remainder of this section."
msgstr ""
"때때로, 우리는 데이터베이스의 수집과 비교하여 정원을 검토할 자원을 얻는데, 주요 활동은 데이터베이스에 등록 코드를 삽입하고, 문제의 "
"공장의 사진을 찍고, 그 위치를, 이 절의 나머지 부분에 설명된 모든 작업에 주목하는 것이다."

#: ../../use_cases-jbq.rst:548
msgid ""
"The small Android app ghini.pocket was added to the Ghini family while a "
"Ghini programmer was here in Quito.  It helps us take a snapshot of the "
"database in our pocket while walking in the garden, but it also allows "
"for a very swift inventory procedure."
msgstr ""
"작은 안드로이드 appghini.기니 프로그래머가 여기 키토에 있는 동안 주머니가 기니 가족에 추가되었어요  그것은 우리가 정원을 "
"산책하는 동안 주머니에 있는 데이터베이스의 스냅샷을 만들도록 도와주지만, 또한 매우 신속한 재고 조사를 가능하게 한다."

#: ../../use_cases-jbq.rst:553
msgid "Inventory procedure"
msgstr "재고처리절차"

#: ../../use_cases-jbq.rst:556
msgid ""
"We start ghini.pocket, we write down the name of the location where we "
"will be conducting the inventory, for example (INV 1) for greenhouse 1.  "
"We enter (type or scan if the plant has bar code or QR code) the "
"accession code and we look it up in ghini.pocket."
msgstr ""
"기니를 시작합니다.포켓, 우리는 우리가 재고를 진행할 장소의 이름을 적습니다. 예를 들면 (INV 1) 온실 1의 경우입니다.  우리는 "
"등록 코드를 입력하고(공장에 바코드 또는 QR 코드가 있는 경우 입력 또는 스캔) 기니로 조회합니다.호주머니에 넣다."

#: ../../use_cases-jbq.rst:561
msgid ""
"A side effect of performing the search is that ghini.pocket writes the "
"date with time, location and the code looked for in a text file that can "
"later be imported into the database."
msgstr ""
"검색을 수행하는 것의 부작용은 바로 그 기니이다.pocket은 나중에 데이터베이스로 가져올 수 있는 텍스트 파일에서 찾은 시간, 위치 및 "
"코드를 사용하여 날짜를 기록합니다."

#: ../../use_cases-jbq.rst:565
msgid ""
"For a greenhouse with around 1000 plants our estimates suggest you will "
"need two days, working at relaxed pace, from 8:00 am to 5:00 pm."
msgstr "약 1000개의 식물이 있는 온실의 경우, 오전 8시부터 오후 5시까지 이틀간 느긋한 속도로 작업해야 합니다."

#: ../../use_cases-jbq.rst:569
msgid ""
"After having imported the file generated by ghini.pocket, it is easy to "
"reveal which plants are missing. For example: If we did the inventory of "
"the INV3 from 4 to 5 September, this is the corresponding search::"
msgstr ""
"ghini에서 생성한 파일을 가져온 후.주머니, 어떤 식물이 없어졌는지 밝히는 것은 쉽다. 예를 들어: 만약 우리가 9월 4일부터 "
"5일까지 INV3의 재고를 했다면, 이것은 해당 검색입니다:"

#: ../../use_cases-jbq.rst:576
msgid ""
"All of these plants can be marked as dead, or lost, according to garden "
"policy."
msgstr "이 모든 식물들은 정원 정책에 따라 죽거나 잃어버린 것으로 표시될 수 있다."

#: ../../use_cases-jbq.rst:579
msgid "Visualizing the need of taxonomic attention"
msgstr "분류학적 주의의 필요성 시각화"

#: ../../use_cases-jbq.rst:582
msgid ""
"Our protocol includes one more detail intended to visually highlight "
"plants that need the attention of a taxonomist."
msgstr "우리의 프로토콜은 분류학자의 주의가 필요한 식물을 시각적으로 강조하기 위한 한 가지 세부 사항을 포함한다."

#: ../../use_cases-jbq.rst:587
msgid ""
"A plant that only appears in our data base identified at family level or "
"that wasn't yet the database receives a visual signal (e.g.: a wooden or "
"plastic stick, for ice cream or french fries), to highlight that it is "
"not identified. In this way the taxonomist in charge, when making a tour "
"of the greenhouse can quickly spot them and possibly proceed to add their"
" identification in the database."
msgstr ""
"가족 수준에서 확인되거나 아직 확인되지 않은 데이터베이스에만 나타나는 식물은 식별되지 않음을 강조하기 위해 시각적 신호(예: 아이스크림 "
"또는 감자튀김용 나무 막대기 또는 플라스틱 막대기)를 수신합니다. 이런 방식으로 담당 분류학자는 온실 여행을 할 때 그들을 신속하게 "
"발견할 수 있고 데이터베이스에 그들의 신원을 추가하는 것을 계속할 수 있다."

#: ../../use_cases-jbq.rst:595
msgid "Naming convention in garden locations"
msgstr "정원 위치에서 명명 규칙"

#: ../../use_cases-jbq.rst:601
msgid "description"
msgstr "묘사"

#: ../../use_cases-jbq.rst:603
msgid "Reserved to cactus plants next to the orchids exposition glasshouses."
msgstr "난초 전시장 옆에 선인장 식물에 보관되어 있습니다."

#: ../../use_cases-jbq.rst:606
msgid "Nepenthaceae exibition"
msgstr "네펜타과 전시"

#: ../../use_cases-jbq.rst:608
msgid ""
"orquidearios de calor en el jardín (1A a 9C son lugares especificos entre"
" del orquideario)"
msgstr "정원(AA)에서 9C까지의 열 저장고들이 아주 특별합니다"

#: ../../use_cases-jbq.rst:611
msgid ""
"orquidearios de frío en el jardín (1A a 5I son lugares específicos dentro"
" del orquideario)"
msgstr "정원에서 냉각 장치로 사용할 수 있게 되었습니다"

#: ../../use_cases-jbq.rst:614
msgid "invernadero 1 (calor)"
msgstr "온실 1층"

#: ../../use_cases-jbq.rst:616
msgid "invernadero 2 (frío)"
msgstr "온실 2"

#: ../../use_cases-jbq.rst:618
msgid "invernadero 3 (calor)"
msgstr "온실 3호실"

#: ../../use_cases-jbq.rst:621
msgid "Adding an Accession for a Plant"
msgstr "플랜트에 대한 등록 추가"

#: ../../use_cases-jbq.rst:623
msgid ""
"Obviously we keep increasing our collection, with plants coming from "
"commercial sources, or collected from the wild, more rarely coming from "
"expeditions to remote areas of our country, or we receive plants which "
"were illegally collected."
msgstr ""
"분명히 우리는 우리의 수집량을 계속 늘려가고 있습니다. 상업적인 근원으로부터 또는 야생에서 채집된 식물들은, 원정에서 우리 나라의 외딴 "
"지역으로 더 드물게, 또는 불법적으로 채집된 식물들을 더 많이 받습니다."

#: ../../use_cases-jbq.rst:628
msgid ""
"Sometimes we have to add plants to the digital collection, just because "
"we have them physically, found in the garden, with or without its label, "
"but without their digital counterpart."
msgstr ""
"때때로 우리는 식물을 디지털 컬렉션에 추가해야 합니다. 왜냐하면 식물들이 물리적으로 정원에서 발견되기 때문입니다. 라벨이 있든 없든 "
"말이죠. 하지만 그들의 디지털 컬렉션은 없습니다."

#: ../../use_cases-jbq.rst:632
msgid "Existing plant, found in the garden with its own label"
msgstr "기존 식물, 자체 라벨이 부착된 정원에서 발견됨"

#: ../../use_cases-jbq.rst:635
msgid ""
"This activity starts with a plant, which was found at a specific garden "
"location, an accession label, and the knowledge that the accession code "
"is not in the database."
msgstr "이 활동은 특정 정원 위치, 등록 레이블 및 데이터베이스에 없는 등록 코드에서 발견된 식물에서 시작됩니다."

#: ../../use_cases-jbq.rst:647
msgid ""
"For this example, let's assume we are going to insert this information in"
" the database."
msgstr "이 예에서는 이 정보를 데이터베이스에 삽입한다고 가정합니다."

#: ../../use_cases-jbq.rst:651
msgid "Accession"
msgstr "억세션"

#: ../../use_cases-jbq.rst:651
msgid "Species"
msgstr "종명"

#: ../../use_cases-jbq.rst:651
msgid "Location"
msgstr "위치명"

#: ../../use_cases-jbq.rst:653
msgid "Invernadero 1 (calor)"
msgstr "1온실"

#: ../../use_cases-jbq.rst:656
msgid ""
"We go straight into the Accession Editor, start typing the species name "
"in the corresponding field.  Luckily, the species was already in the "
"database, otherwise we would use the **Add** button next to the entry "
"field."
msgstr ""
"등록 편집기로 바로 들어가서 해당 필드에 종 이름을 입력하기 시작합니다.  다행히도, 그 종은 이미 데이터베이스에 있었고, 그렇지 않으면 "
"우리는 입력 필드 옆에 있는 **추가** 버튼을 사용할 것이다."

#: ../../use_cases-jbq.rst:663
msgid ""
"We select the correct species, and we fill in a couple more fields, "
"leaving the rest to the default values:"
msgstr "올바른 종을 선택하고 필드를 몇 개 더 채우고 나머지는 기본값으로 둡니다:"

#: ../../use_cases-jbq.rst:667 ../../use_cases-jbq.rst:702
msgid "Accession ID"
msgstr "억세션 ID"

#: ../../use_cases-jbq.rst:667 ../../use_cases-jbq.rst:702
msgid "Type of Material"
msgstr "재료 유형"

#: ../../use_cases-jbq.rst:667 ../../use_cases-jbq.rst:702
msgid "Quantity"
msgstr "수량"

#: ../../use_cases-jbq.rst:667
msgid "Provenance"
msgstr "도입처, 원산지"

#: ../../use_cases-jbq.rst:669
msgid "Unknown"
msgstr "모름"

#: ../../use_cases-jbq.rst:672 ../../use_cases-jbq.rst:707
msgid ""
"After this, we continue to the Plant editor, by clicking on **Add "
"Plants**."
msgstr "그런 다음 **식물 추가**를 클릭하여 공장 편집기로 이동합니다."

#: ../../use_cases-jbq.rst:675
msgid ""
"We do not fill in the Accession's \"**Intended Locations**\", because we "
"don't know what was the original intention when the plant was first "
"acquired."
msgstr ""
"우리는 그 식물이 처음 인수되었을 때 원래의 의도가 무엇이었는지 모르기 때문에 등록소의 \"**의 의도된 위치**\"를 작성하지 않는다."

#: ../../use_cases-jbq.rst:679
msgid ""
"In the Plant Editor, we insert the Quantity and the Location.  And we're "
"done."
msgstr "식물 편집기에서 수량 및 위치를 삽입합니다.  그리고 우리는 끝났다."

#: ../../use_cases-jbq.rst:682
msgid "The plant is now part of the database:"
msgstr "식물은 이제 데이터베이스의 일부가 되었습니다:"

#: ../../use_cases-jbq.rst:686
msgid "New accession: plant just entering the garden"
msgstr "새 등록: 정원에 막 들어오는 식물"

#: ../../use_cases-jbq.rst:689
msgid ""
"This activity starts with a new Plant, just acquired from a known Source,"
" a plant label, and an intended Location in the garden."
msgstr "이 활동은 알려진 소스, 식물 라벨 및 정원의 의도된 위치로부터 방금 획득한 새 식물에서 시작됩니다."

#: ../../use_cases-jbq.rst:692
msgid ""
"We mostly do the same as for the case that a plant is found in the "
"garden, there are two differences: (1) we know the source of the plant; "
"(2) acquiring this plant was a planned action, and we intend to place it "
"at a specific location in the garden."
msgstr ""
"우리는 대부분 정원에서 식물이 발견되었을 때와 같은 경우, 두 가지 차이가 있다. (1) 우리는 식물의 근원을 알고 있다. (2) 이 "
"식물을 획득하는 것은 계획된 행동이었고, 우리는 그것을 정원의 특정 위치에 배치하려고 한다."

#: ../../use_cases-jbq.rst:697
msgid ""
"Again, we go straight into the Accession Editor, start typing the species"
" and we either select if from the completion list or we add it on the "
"fly."
msgstr "다시 등록 편집기로 들어가 종을 입력하기 시작하고 완료 목록에서 원하는 항목을 즉시 추가할지 선택합니다."

#: ../../use_cases-jbq.rst:702
msgid "Source"
msgstr "소스"

#: ../../use_cases-jbq.rst:704
msgid "specified"
msgstr "명시된"

#: ../../use_cases-jbq.rst:710
msgid "In the Plant Editor, we insert the Quantity and the Location."
msgstr "식물 편집기에서 수량 및 위치를 삽입합니다."

#: ../../use_cases-jbq.rst:712
msgid ""
"Please note that the plant may be initially placed in a greenhouse, "
"before it reaches its intended location in the garden."
msgstr "화초가 정원에서 의도된 위치에 도달하기 전에 먼저 온실에 배치될 수 있다는 점에 유의하십시오."

#: ../../use_cases-jbq.rst:715
msgid "Existing plant, found in the garden without its label"
msgstr "기존 식물, 라벨 없이 정원에서 발견"

#: ../../use_cases-jbq.rst:718
msgid ""
"When this happens, we can't be sure the plant had never been in the "
"collection, so we act as if we were re-labeling the plant.  This is "
"discussed in the next section, but we fall back to the case of a new "
"accession."
msgstr ""
"이렇게 되면 우리는 발전소가 컬렉션에 있은 적이 없었다 우리가 식물 re-labeling 때문에 행동하고 확신할 수 없어요이것은 다음 "
"부분에 있지만 우리는 다시 신규 가입의 경우에 떨어져 논의된다."

#: ../../use_cases-jbq.rst:723
msgid ""
"When we physically associate a label to a plant, there's always the "
"chance that something happens either to the plant (it may die) or to the "
"label (it may become unreadable), or to the association (they may be "
"separated). We have software-aided protocols for these events."
msgstr ""
"우리가 물리적으로 라벨을 식물과 연관시킬 때, 항상 어떤 일이 식물이나 라벨에 일어날 가능성이 있다(읽을 수 없게 될 수도 있다). 또는 "
"연관성에 일어날 가능성이 있다(그들은 분리될 수도 있다. 이러한 이벤트에 대한 소프트웨어 지원 프로토콜이 있습니다."

#: ../../use_cases-jbq.rst:728
msgid "We find a dead plant"
msgstr "우리는 죽은 식물을 발견한다"

#: ../../use_cases-jbq.rst:731
msgid ""
"Whenever a plant is found dead, we collect its label and put it in a box "
"next to the main data insertion terminal, the box is marked “dead "
"plants”."
msgstr "우리는 식물이 죽은 것으로 발견될 때마다 라벨을 수집하여 주 데이터 삽입 단자 옆의 상자에 넣으면 \"죽은 식물\"로 표시된다."

#: ../../use_cases-jbq.rst:734
msgid ""
"Definitely at least once a week, the box is emptied and the database is "
"updated with this information."
msgstr "확실히 일주일에 한 번 이상 상자는 비워지고 데이터베이스는 이 정보로 업데이트됩니다."

#: ../../use_cases-jbq.rst:737
msgid ""
"Dead plants aren't *removed* from the database, they stay there but get a"
" **quantity** zero. If the cause of death is known, this is also written "
"in the database."
msgstr ""
"죽은 식물은 데이터베이스에서 *제거*하지 않고 **수량*0을 얻습니다. 사망 원인이 알려진 경우 이 내용도 데이터베이스에 기록됩니다."

#: ../../use_cases-jbq.rst:741
msgid ""
"Please once again remember that a **Plant** is not an **Accession** and "
"please remember we do not remove objects from the database, we just add "
"to their history."
msgstr ""
"**Plant**는 **Accession**이 아니며, 데이터베이스에서 개체를 제거하지 않고 개체 기록에 추가한다는 점을 다시 한 번 "
"기억하십시오."

#: ../../use_cases-jbq.rst:745
msgid ""
"Insert the complete plant code (something like ``012345.1``, or "
"``2017.0001.3``, and you don't need leading zeros nor quotes), right "
"click on the corresponding row, and click on **edit**. change the "
"quantity to 0, fill in the reason and preferably also the date of change."
msgstr ""
"전체 식물 코드(예: ''012345.1'' 또는 ''2017.0001')를 삽입한다.3자리, 선행 0이나 따옴표는 필요 없습니다.) "
"해당 행을 마우스 오른쪽 버튼으로 클릭하고 **edit**.를 클릭합니다. 수량을 0으로 변경하고 이유를 채우고 변경 날짜도 입력합니다."

#: ../../use_cases-jbq.rst:750
msgid ""
"If you need add any details about the plant death, please use a **note**,"
" and re-use the note category \"death_cause\"."
msgstr ""
"식물 사망에 대한 세부 정보를 추가해야 하는 경우 **note**를 사용하고 \"death_cause\" 노트 범주를 다시 사용하십시오."

#: ../../use_cases-jbq.rst:753
msgid ""
"Plants with **quantity** zero are shown with a different colour in the "
"results view.  This helps distinguish them from live plants."
msgstr "**수량** 영(0)인 식물은 결과 보기에 다른 색으로 표시됩니다.  이것은 살아있는 식물과 그들을 구별하는데 도움을 줍니다."

#: ../../use_cases-jbq.rst:756
msgid "We find a plant without a label"
msgstr "우리는 라벨이 없는 식물을 발견한다"

#: ../../use_cases-jbq.rst:759
msgid ""
"We can't be sure the plant had ever been in the collection or not. We "
"assume it had, and that its label was lost."
msgstr ""
"우리는 그 식물이 수집품에 있었는지 아닌지 확신할 수 없다. 우리는 그것이 그랬다고 추정합니다. 그리고 그것의 라벨은 사라졌다고 "
"생각합니다."

#: ../../use_cases-jbq.rst:762
msgid ""
"Losing a plant label is unfortunate, but it just sometimes happens. What "
"we do is to put a new label to the plant, and to clearly state that the "
"label is a replacement of an original one."
msgstr ""
"식물 라벨을 잃는 것은 불행한 일이지만, 가끔 그런 일이 일어납니다. 우리가 하는 일은 공장에 새로운 라벨을 붙이고, 라벨이 원래의 "
"라벨의 대체품이라는 것을 분명하게 밝히는 것입니다."

#: ../../use_cases-jbq.rst:766
msgid ""
"We then handle the case as if it was a new accession, plus we add a note "
"to the accession, category “label”, text “relabeled”."
msgstr ""
"그런 다음 사례를 새 등록인 것처럼 처리하고 등록에 메모를 추가합니다. 카테고리 \"label\", 텍스트 \"relabeled\"."

#: ../../use_cases-jbq.rst:770
msgid "Keeping track of different sources of plant material"
msgstr "다양한 식물 자재 공급원 추적"

#: ../../use_cases-jbq.rst:772
msgid "What different sources we can have"
msgstr "우리가 가질 수 있는 다른 소스"

#: ../../use_cases-jbq.rst:775
msgid ""
"In this botanical garden, we receive plants from different types of "
"origin. It could be from expeditions (plants coming from nature, "
"collected with legal permission from MAE - Ecuadorian Environment "
"Ministry), donated plants mostly coming as gifts from collectors or "
"orchid commercialization enterprises, purchased, or confiscated plants "
"(usually coming from MAE raids around the country)."
msgstr ""
"이 식물원에서는 다양한 종류의 식물들을 공급받는다. 그것은 자연에서 온 식물들(MAE - 에콰도르 환경부의 법적 허가를 받아 수집한 "
"식물들), 주로 수집가나 난초 상업화 기업들로부터 선물 받은 기부 식물들, 구입 또는 몰수된 식물들(일반적으로 전국의 MAE 급습에서 "
"나온 것)에서 비롯될 수 있다."

#: ../../use_cases-jbq.rst:783
msgid "If the plant comes from a wild source"
msgstr "만약 식물이 야생에서 온다면"

#: ../../use_cases-jbq.rst:786
msgid ""
"The accession editor offers the option \"origin\" option. When a plant is"
" traceable to a wild source, we can specified its specific origin. We "
"want to comply with ITF2, and ghini-1.0 only partly respects that "
"standard. The ITF2 complying options are:"
msgstr ""
"등록 편집기는 \"원본\" 선택사항을 제공합니다. 식물이 야생의 근원으로 추적가능할 때, 우리는 그 특정한 기원을 지정할 수 있다. "
"우리는 ITF2를 준수하기를 원하며, ghini-1.0은 그 표준을 부분적으로만 존중한다. ITF2 준수 옵션은 다음과 같습니다:"

#: ../../use_cases-jbq.rst:791
msgid "Wild: Accession of wild source."
msgstr "와일드: 와일드 소스 등록."

#: ../../use_cases-jbq.rst:792
msgid "Cultivated: Propagule(s) from a wild source plant."
msgstr "재배: 야생 소스 식물의 전파입니다."

#: ../../use_cases-jbq.rst:793
msgid "Not Wild: Accession not traceable to a wild source."
msgstr "와일드 아님: 등록은 와일드 소스로 추적할 수 없습니다."

#: ../../use_cases-jbq.rst:794
msgid "Insufficient data"
msgstr "데이터 부족"

#: ../../use_cases-jbq.rst:796
msgid ""
"In the case of a donated plant, it is better to put detail information "
"just as a note in the plant accession; in the case of a plant with an "
"unknown origin, we select the Insufficient data option."
msgstr ""
"기부된 발전소의 경우, 상세 정보를 발전소 등록에 메모로 넣는 것이 더 낫고, 출처를 알 수 없는 발전소의 경우 데이터 부족 옵션을 "
"선택한다."

#: ../../use_cases-jbq.rst:800
msgid "Using the source tab in the accession editor"
msgstr "등록 편집기의 원본 탭 사용"

#: ../../use_cases-jbq.rst:803
msgid ""
"In this section we can create or use a contact, our source of plant "
"material. It could be from an expedition to a collecting place, and in "
"this case we would specify the region and the expedition name, or could "
"be the name of the person or enterprise donating a specific batch of "
"plants."
msgstr ""
"이 섹션에서는 공장 재료의 공급원인 연락처를 만들거나 사용할 수 있습니다. 그것은 탐험에서 수집 장소로 가는 것일 수도 있고, 이 경우 "
"우리는 지역과 탐험 이름을 명시할 수도 있고, 특정한 한 묶음의 식물을 기증하는 사람이나 기업의 이름이 될 수도 있습니다."

#: ../../use_cases-jbq.rst:811
msgid ""
"Once you choose or create the contact information, this section deploys "
"more options, here you can specify the region, where you can choose the "
"country of origin, and a specific location within the region, "
"georeferencing information (including the GPS data), habitat description "
"collector name. For the last one, I recommend also to write the specific "
"date next to the collector name (eg. Luis Baquero 11/10/2016)."
msgstr ""
"연락처 정보를 선택하거나 만들면 이 섹션에서는 더 많은 옵션을 배포합니다. 여기서 출신 국가를 선택할 수 있는 지역, 지역 내 특정 "
"위치, 지역 참조 정보(GPS 데이터 포함), 서식지 설명 수집기 이름을 지정할 수 있습니다. 마지막 날짜의 경우 수집기 이름 옆에 특정 "
"날짜(예:)를 쓰는 것이 좋습니다. 루이스 바케로 11/10/2016)."

#: ../../use_cases-jbq.rst:819
msgid "Donated, bought or confiscated plants"
msgstr "식물 기증, 구입 또는 압수"

#: ../../use_cases-jbq.rst:822
msgid ""
"However useful for expeditions or for donors where the main information "
"is geographic, this source tab is not very practical in our remaining "
"cases: we handle three more categories: confiscated, purchased and "
"donated, for these categories the options available in the source tab do "
"not apply: too much information and not to the point."
msgstr ""
"그러나 주요 정보가 지리적 위치인 원정대나 기부자들에게는 유용하지만, 이 소스 탭은 나머지 세 가지 범주 즉, 압수, 구매 및 기부된 "
"범주에서 다루지 않습니다. 소스 탭에서 사용할 수 있는 옵션은 적용되지 않습니다. 너무 많은 정보이며 요점은 아닙니다."

#: ../../use_cases-jbq.rst:828
msgid "In these cases, we add a set of notes, according to the case."
msgstr "이러한 경우, 우리는 사례에 따라 노트 세트를 추가합니다."

#: ../../use_cases-jbq.rst:830
msgid "— Donated plants"
msgstr "— 기부 식물"

#: ../../use_cases-jbq.rst:833
msgid ""
"If the plant was donated by individual, we add the individual among our "
"contacts and specify it as source, then we add the notes:"
msgstr "식물이 개인에 의해 기증된 경우, 우리는 연락처에 개인을 추가하고 출처로 지정한 다음, 메모를 추가합니다."

#: ../../use_cases-jbq.rst:837 ../../use_cases-jbq.rst:850
#: ../../use_cases-jbq.rst:864
msgid "category"
msgstr ":범주로 분류하다"

#: ../../use_cases-jbq.rst:837 ../../use_cases-jbq.rst:850
#: ../../use_cases-jbq.rst:864
msgid "text"
msgstr "문자를 보내다"

#: ../../use_cases-jbq.rst:839
msgid "gift"
msgstr "선물"

#: ../../use_cases-jbq.rst:840
msgid "Contribución científica al JBQ"
msgstr "JBQ에 대한 과학 공헌"

#: ../../use_cases-jbq.rst:843
msgid "— Bought plants"
msgstr "— 구입한 식물"

#: ../../use_cases-jbq.rst:846
msgid ""
"If the plant was bought, we add the previous owner among our contacts and"
" specify it as source, then we add the notes:"
msgstr "식물을 구입한 경우 연락처에 이전 소유자를 추가하고 출처로 지정한 다음 메모를 추가합니다:"

#: ../../use_cases-jbq.rst:852
msgid "purchase"
msgstr "구입하다"

#: ../../use_cases-jbq.rst:853
msgid "optional, free text"
msgstr "옵션, 자유 텍스트"

#: ../../use_cases-jbq.rst:854
msgid "the invoice number"
msgstr "송장 번호"

#: ../../use_cases-jbq.rst:857
msgid "— Confiscated plants"
msgstr "— 몰수된 식물"

#: ../../use_cases-jbq.rst:860
msgid ""
"If the plant was confiscated, we add the previous owner among our "
"contacts and specify it as source, then we add the notes:"
msgstr "식물이 압수된 경우 연락처에 이전 소유자를 추가하고 출처로 지정한 다음 메모를 추가합니다:"

#: ../../use_cases-jbq.rst:866
msgid "confiscated"
msgstr "몰수의"

#: ../../use_cases-jbq.rst:867
msgid "possibly, legal details, law number ..."
msgstr "법적인 세부 사항, 법적인 번호..."

#: ../../use_cases-jbq.rst:871
msgid "Producing or reproducing labels"
msgstr "레이블 생성 또는 복제"

#: ../../use_cases-jbq.rst:873
msgid "Refreshing plant labels"
msgstr "플랜트 라벨 새로 고침"

#: ../../use_cases-jbq.rst:876
msgid ""
"Sometimes we refresh the labels, for example all that is in a greenhouse,"
" or maybe just a set of plants because their labels risk becoming "
"unreadable."
msgstr ""
"때때로 우리는 라벨을 새로 고칩니다. 예를 들어 온실에 있는 모든 것, 또는 단지 식물들의 집합일 수도 있습니다. 왜냐하면 그들의 라벨은 "
"읽을 수 없게 될 위험이 있기 때문입니다."

#: ../../use_cases-jbq.rst:880
msgid ""
"In the first case it's easy selecting all plants in the Location, we just"
" type the location name, or give the search ``location like <location "
"name>``."
msgstr ""
"첫 번째 경우 위치 내의 모든 식물을 쉽게 선택할 수 있으며, 위치 이름만 입력하거나 검색을 \"위치 이름\"과 같은 \"위치 이름\"으로"
" 지정합니다."

#: ../../use_cases-jbq.rst:884
msgid ""
"The second case it's a bit trickier.  What we do is to create a temporary"
" **Tag**, and use it to tag all plants that were found in need for a new "
"label."
msgstr "두 번째 경우는 좀 더 까다롭습니다.  임시 **태그**를 만들어 새 라벨이 필요한 모든 식물에 태그를 지정하는 데 사용합니다."

#: ../../use_cases-jbq.rst:888
msgid ""
"Given the selection, we start the report tool, using the mako "
"``accession-label.svg`` template.  We reset its options to default "
"values, and since we're using a simple printer, we set the colour to "
"``black`` instead of ``blue``, which is meant for engraving."
msgstr ""
"선택을 고려할 때, 우리는 mako ``accession-label\"을 사용하여 보고서 도구를 시작한다.svg² 템플릿  우리는 그것의 "
"옵션을 기본값으로 재설정했고, 우리는 단순한 프린터를 사용하기 때문에 새기기 위한 \"파란색\"이 아닌 \"검은색\"으로 색을 설정했다."

#: ../../use_cases-jbq.rst:893
msgid "Preparing labels for non-database plants"
msgstr "데이터베이스가 아닌 공장의 레이블 준비"

#: ../../use_cases-jbq.rst:896
msgid ""
"To prepare the batch of 72 labels, we use a mako report template, named "
"``accession-label.svg``.  This template accepts parameters, this is an "
"example that would produce labels from 025801 all the way to 025872."
msgstr ""
"72개의 레이블 배치를 준비하기 위해 \"액세스-라벨\"이라는 이름의 mako 보고서 템플릿을 사용한다.svg'. 이 템플릿은 매개 "
"변수를 받아들이며 025801부터 025872까지 레이블을 생성합니다."

#: ../../use_cases-jbq.rst:903
msgid ""
"Labels come for us in two flavours: (1) either new plants just being "
"acquired by the garden; (2) or plants in the garden, found without a "
"label. We distinguish the two cases by adding a 'ret' extra text for "
"relabeled plants."
msgstr ""
"라벨은 두 가지 맛으로 제공됩니다. (1) 정원에 의해 막 획득된 새로운 식물, (2) 또는 라벨 없이 발견되는 정원의 식물. 우리는 "
"다시 레이블링된 식물에 대한 '레트' 추가 텍스트를 추가하여 두 경우를 구별한다."

#: ../../use_cases-jbq.rst:908
msgid "We keep two boxes with labels of the two types, ready to be used."
msgstr "우리는 두 종류의 라벨이 붙어 있는 상자 두 개를 사용할 준비가 되어 있습니다."

#: ../../use_cases-jbq.rst:910
msgid ""
"Our garden has two exposition greenhouses, and several warm and cold "
"greenhouses where we keep the largest part of our collection.  Plants are"
" moved to the exposition when flowering and back to the \"warehouse\" "
"when less interesting for the exposition. For each plant in our "
"collection we need to know its current locations and history of "
"movements."
msgstr ""
"우리 정원에는 2개의 전시 온실이 있고, 따뜻한 온실과 차가운 온실이 몇 채 있는데, 그 온실은 우리가 소장하고 있는 것의 가장 큰 "
"부분을 차지한다.  식물은 꽃을 피울 때는 엑스포로 옮겨지고, 전시할 때는 \"창고\"로 되돌아간다. 컬렉션에 있는 각 공장에 대해 현재 "
"위치와 이동 내역을 알아야 합니다."

#: ../../use_cases-jbq.rst:916
msgid "Planned action"
msgstr "계획조치"

#: ../../use_cases-jbq.rst:919
msgid ""
"The action starts by moving the plants around, and collecting the plant "
"code either on paper, or in our mobile app, if we had one."
msgstr "이 작업은 식물들을 이리저리 옮겨놓고 종이로 혹은 모바일 앱으로 식물 코드를 수집하는 것으로 시작됩니다."

#: ../../use_cases-jbq.rst:922
msgid ""
"We then go to the desktop terminal and revise all plants one by one "
"changing their location in the database.  It is important that the date "
"of the location change is correctly memorized, because this tells us how "
"long a plant stays in the exposition."
msgstr ""
"그런 다음 데스크톱 터미널로 이동하여 데이터베이스에서 위치를 변경하는 모든 공장을 하나씩 수정합니다.  위치 변경 날짜를 정확하게 "
"기억하는 것이 중요합니다. 이는 식물이 박람회에 머무는 기간을 알려주기 때문입니다."

#: ../../use_cases-jbq.rst:927
msgid ""
"If we had a mobile app, we would just upload the info to the server and "
"we would be done."
msgstr "모바일 앱이 있다면 서버에 정보를 업로드하면 끝납니다."

#: ../../use_cases-jbq.rst:930
msgid "Ex-post correction"
msgstr "전후수정"

#: ../../use_cases-jbq.rst:933
msgid ""
"While revising the garden, we find a plant at a location that is not what"
" the database says.  We update the database information."
msgstr "정원을 수정하는 동안, 우리는 데이터베이스에 기록되지 않은 위치에 식물을 발견합니다.  데이터베이스 정보를 업데이트합니다."

#: ../../use_cases-jbq.rst:936
msgid ""
"For example, the plant belonging to accession “012142”, species "
"“*Acineta* sp”, was found in “Invernadero 1”, while the database says it "
"is in “ICAlm3”."
msgstr ""
"예를 들어, \"012142\"에 속하는 식물인 \"*아시네타*sp\"는 \"인버나데로 1\"에서 발견되었고, 데이터베이스는 \"ICLM3"
"\"에 있다고 말한다."

#: ../../use_cases-jbq.rst:939
msgid ""
"All we do is find the Plant in the database and update its information.  "
"We do not change anything in the initial Accession information, just the "
"current Plant information."
msgstr ""
"우리가 하는 일은 데이터베이스에서 플랜트를 찾고 정보를 업데이트하는 것뿐입니다.  우리는 초기 등록 정보에는 아무것도 변경하지 않고 단지 "
"현재 플랜트 정보만 변경한다."

#: ../../use_cases-jbq.rst:943
msgid ""
"We type the accession code in the search entry field, with quotes, hit "
"enter. The search results now shows the accession, and it tells us how "
"many plants belong to it.  Click on the squared **+** in the results row,"
" so we now also see a row for the plant belonging to the accession."
msgstr ""
"검색 항목 필드에 등록 코드를 입력합니다. 따옴표와 함께 입력됩니다. 이제 검색 결과는 등록 내용을 보여주며, 얼마나 많은 식물이 등록에 "
"속하는지 알려줍니다.  결과 행에서 제곱 **+**를 클릭하면 이제 등록에 속하는 공장의 행도 표시됩니다."

#: ../../use_cases-jbq.rst:948
msgid ""
"Right click on the Plant row, the three options will show: “Edit, Split, "
"Delete”, select Edit, you land in the Plant Editor."
msgstr "그 식물을 맞아 클릭, 세 옵션:“편집, 갈라진, Delete”,, 당신은 발전소 편집기에 도착해서 편집을 보여 줄 것이다."

#: ../../use_cases-jbq.rst:951
msgid "Just correct the Location field, and click on OK."
msgstr "위치 필드를 수정한 후 [확인]을 클릭합니다."

#: ../../use_cases-jbq.rst:953
msgid "The InfoBox contains information about the last change to the object:"
msgstr "InfoBox에는 개체의 마지막 변경 사항에 대한 정보가 포함되어 있습니다:"

#: ../../use_cases-jbq.rst:958
msgid ""
"For plants, even more interesting, it builds a history of changes, list "
"that includes Location changes, or Quantity changes."
msgstr "식물의 경우, 더욱 흥미로운 점은 위치 변경 또는 수량 변경이 포함된 변경 내역, 목록을 작성합니다."

#: ../../use_cases-jbq.rst:963
msgid ""
"As plants enter the flowering stage, we can review their identification "
"directly, or we take pictures of details of the flower, hoping that a "
"visiting specialist could help completing the identification."
msgstr ""
"식물이 개화기에 접어들면서 직접 신원 확인을 검토할 수도 있고, 방문 전문가가 신원 확인 완료에 도움이 될 수 있기를 바라며 자세한 꽃 "
"사진을 찍을 수도 있다."

#: ../../use_cases-jbq.rst:967
msgid "Adding pictures"
msgstr "사진 추가"

#: ../../use_cases-jbq.rst:970
msgid ""
"We are practicing with ODK Collect, a small program running on hand-held "
"android devices.  Ghini's use of ODK Collect hasn't yet frozen to a best "
"practice.  Do have a look at the `corresponding issue "
"<https://github.com/Ghini/ghini.desktop/issues/243>`_ on github."
msgstr ""
"우리는 휴대용 안드로이드 기기에서 실행되는 작은 프로그램인 ODK Collect로 연습하고 있다.  기니의 ODK 콜렉트 사용은 아직 "
"모범 사례로는 얼지 않았다.  github의 해당 이슈 https://github.com/Ghini/ghini.desktop/issues/"
"243를 살펴보십시오."

#: ../../use_cases-jbq.rst:976
msgid ""
"Regularly, we need producing reports about our collection that the "
"Ecuadorian Environment Ministry (MAE) requires and that justify the very "
"existence of the garden."
msgstr "정기적으로, 우리는 에콰도르 환경부(MAE)가 요구하고 정원의 존재를 정당화하는 우리의 수집품에 대한 보고서를 작성해야 한다."

#: ../../use_cases-jbq.rst:980
msgid "Producing reports"
msgstr "보고서 작성"

#: ../../use_cases-jbq.rst:983
msgid ""
"Each year the botanic garden has to submit a report (annual report of "
"management and maintenance of orchids collection) complying to the "
"requirements of the Ecuadorian Ministry of the Environment."
msgstr "매년 식물원은 에콰도르 환경부의 요구 사항을 준수하는 보고서(난초 수집 관리 및 유지에 대한 연례 보고서)를 제출해야 한다."

#: ../../use_cases-jbq.rst:987
msgid ""
"To this end, we start selecting the plants we have to include in the "
"report. It might be all acquisition in the past year::"
msgstr "이를 위해 보고서에 포함시켜야 할 식물을 선정하기 시작합니다. 이는 모두 지난 1년 동안의 취득일 수 있습니다:"

#: ../../use_cases-jbq.rst:992
msgid ""
"or all plants within a location, or all plants belonging to a species, or"
" just everything (but this will take time)::"
msgstr "한 장소에 있는 모든 식물, 한 종에 속하는 모든 식물, 또는 모든 것(그러나 이 작업은 시간이 걸린다::"

#: ../../use_cases-jbq.rst:999
msgid ""
"Having selected the database objects which we want in the report, we "
"start the report tool, which acts on the selection."
msgstr "보고서에서 원하는 데이터베이스 개체를 선택한 후 선택 항목에 대해 작동하는 보고서 도구를 시작합니다."

#: ../../use_cases-jbq.rst:1003
msgid "Searching the database"
msgstr "데이터베이스 검색"

#: ../../use_cases-jbq.rst:1005
msgid ""
"You search the database in order to edit the data further, or because you"
" want to produce a report. Anyway you start with typing something in the "
"search field"
msgstr ""
"데이터를 추가로 편집하기 위해 또는 보고서를 작성하기 위해 데이터베이스를 검색합니다. 어쨌든 검색 필드에 무언가를 입력하는 것부터 "
"시작합니다"

#: ../../use_cases-jbq.rst:1011
msgid "and you hope to see your result in the search result view."
msgstr "검색 결과 보기에서 결과를 볼 수 있습니다."

#: ../../use_cases-jbq.rst:1013
msgid "Search in order to edit (plant or accession)"
msgstr "편집할 검색(플랜트 또는 등록)"

#: ../../use_cases-jbq.rst:1016
msgid ""
"When searching in order to edit, you want to be very specific, and select"
" as few objects as possible. The most fine-tuned search is the one based "
"on plant number: you know the code, you get one object."
msgstr ""
"편집하기 위해 검색할 때 매우 구체적이고 가능한 한 적은 수의 개체를 선택합니다. 가장 세밀하게 조정된 검색은 공장 번호를 기반으로 한 "
"검색입니다. 코드를 알고 한 개체를 얻습니다."

#: ../../use_cases-jbq.rst:1020
msgid "If your plant is not there, the screen would look like this:"
msgstr "식물이 없는 경우 화면은 다음과 같습니다:"

#: ../../use_cases-jbq.rst:1024
msgid "Other example, plant ``007701.1`` is in the database:"
msgstr "다른 예로는 \"007701 식물\"가 있다.1개의 데이터가 데이터베이스에 있습니다:"

#: ../../use_cases-jbq.rst:1028
msgid ""
"All fields with a darker background in the infobox on the right hand side"
" are hyperlinks to other objects in the database. Clicking on them will "
"either replace the text in the search field and execute the query, or "
"will simply add the object to the results."
msgstr ""
"오른쪽에 있는 정보 상자의 배경이 어두운 모든 필드는 데이터베이스의 다른 개체에 대한 하이퍼링크입니다. 이 옵션을 클릭하면 검색 필드의 "
"텍스트가 대체되고 조회가 실행되거나 객체가 결과에 추가됩니다."

#: ../../use_cases-jbq.rst:1033
msgid "Clicking on the accession does the latter."
msgstr "등록 정보를 클릭하면 후자가 됩니다."

#: ../../use_cases-jbq.rst:1037
msgid ""
"We now have both Plant or Accession in the search result view and we can "
"now edit either or both."
msgstr "이제 검색 결과 보기에 플랜트 또는 등록 둘 다 있고 둘 중 하나 또는 둘 다를 편집할 수 있습니다."

#: ../../use_cases-jbq.rst:1040
msgid "Search in order to report"
msgstr "보고할 검색"

#: ../../use_cases-jbq.rst:1043
msgid ""
"When searching in order to create a report, you want to be both specific "
"(you don't want to report about irrelevant objects) and broad (you don't "
"want to report about a single object)."
msgstr ""
"보고서를 만들기 위해 검색할 때 특정 개체(관련 없는 개체에 대해 보고하지 않으려는 경우)와 광범위한 개체(단일 개체에 대해 보고하지 "
"않으려는 경우)를 모두 검색해야 합니다."

#: ../../use_cases-jbq.rst:1047
msgid ""
"Sometimes the report itself suggests the query, as for example: all "
"plants in greenhouse 3; or: all plants belonging to endangered species "
"(we store this information in a note associated to the species); or: all "
"plants added to the collection this year; ::"
msgstr ""
"때때로 보고서 자체에서 예를 들어 온실 속의 모든 식물 3 또는 멸종 위기에 처한 종에 속하는 모든 식물(이 정보는 해당 종과 관련된 "
"노트에 저장) 또는 다음과 같은 질문이 제시되기도 합니다::"

#: ../../use_cases-jbq.rst:1056
msgid "Otherwise a flexible way to achieve this is to work with **Tags**."
msgstr "그렇지 않은 경우 **Tag**로 작업하는 것이 유연한 방법입니다."

#: ../../use_cases-jbq.rst:1058
msgid "Using **Tags** as enhanced searching"
msgstr "**태그**를 향상된 검색으로 사용"

#: ../../use_cases-jbq.rst:1061
msgid ""
"Sometimes we have to take the same action on objects of the same type, "
"but we don't manage to quickly think of a search query that would group "
"all that we need and exclude all we do not need."
msgstr ""
"동일한 유형의 개체에 대해 동일한 작업을 수행해야 하는 경우도 있지만 필요한 모든 항목을 그룹화하고 필요하지 않은 모든 항목을 제외하는 "
"검색 쿼리가 빠르게 생각나지 않습니다."

#: ../../use_cases-jbq.rst:1065
msgid ""
"This is one possible use of **Tags**.  We start with a selection, we tag "
"all objects in the selection under a new temporary tag. Let's say we call"
" it \"temporary\"."
msgstr ""
"**태그**를 사용할 수 있습니다.  선택부터 시작하여 선택 영역의 모든 개체를 새 임시 태그 아래에 태그합니다. 우리가 그것을 \"임시"
"\"라고 부릅시다."

#: ../../use_cases-jbq.rst:1069
msgid ""
"We continue searching and adding objects to the temporary tag until the "
"tag identifies all that we need."
msgstr "태그가 필요한 모든 항목을 식별할 때까지 임시 태그에 개체를 계속 검색하고 추가합니다."

#: ../../use_cases-jbq.rst:1072
msgid ""
"Finally from the Tags menu we select the one we just created (in our "
"example this corresponds to the search ``tag=\"temporary\"``) and we can "
"invoke the report."
msgstr "마지막으로 Tags 메뉴에서 방금 생성한 검색(\"tag=\"임시\" 검색에 해당)을 선택하면 보고서를 호출할 수 있습니다."

#: ../../use_cases-jbq.rst:1076
msgid ""
"When we're done with a temporary tag, there's no point in leaving it "
"around, so we just delete it."
msgstr "임시 태그 작업이 끝나면 그냥 놔둬도 소용없으니까 삭제만 하면 됩니다."

#: ../../use_cases-jbq.rst:1081
msgid "Be aware of the available search strategies"
msgstr "사용 가능한 검색 전략을 숙지합니다"

#: ../../use_cases-jbq.rst:1084
msgid ""
"This is nicely documented, \"più non dimandare\" and `read the docs "
"<searching.html>`_."
msgstr "이것은 \"pi non non dimandare\"와 \"searching.html\"이라는 훌륭한 문서이다"

#: ../../use_cases.rst:2
msgid "Contributed recipes collection"
msgstr "기여 요리법 모음기여 요리법 모음"

#: ../../use_cases.rst:4
msgid ""
"This page presents lists of use cases. If you're looking for straight, "
"practical information, you are at the right place. If you prefer a "
"thorough presentation of the software and database structure, check the "
"section `software for botanical gardens <goal.html#botanic-garden-"
"software>`_"
msgstr ""
"이 페이지에는 사용 사례 목록이 표시됩니다. 만약 당신이 솔직하고 실용적인 정보를 찾고 있다면, 당신은 올바른 장소에 있는 것입니다. "
"소프트웨어와 데이터베이스 구조의 철저한 프레젠테이션을 원하는 경우 식물원용 소프트웨어 <goal.html#botanic-garden-"
"software> 섹션을 확인하십시오"

#: ../../use_cases.rst:9
msgid ""
"All material here has been contributed by gardens using the software and "
"sharing their experiences back to the user community."
msgstr "이곳의 모든 자료는 소프트웨어를 사용하고 사용자 커뮤니티에 그들의 경험을 공유하는 정원에 의해 기여되었다."

#: ../../use_cases.rst:12
msgid "The authors of the software wish to thank all dearly."
msgstr "그 소프트웨어의 저자들은 모두에게 진심으로 감사를 표하고 싶어한다."

#: ../../use_cases-zadenbank.rst:2
msgid "using ghini for a seed database"
msgstr "시드 데이터베이스에 기니 사용"

#: ../../use_cases-zadenbank.rst:4
msgid ""
"We keep getting involved in groups focusing on endagered plant seeds.  "
"They want to note down when seeds come in, but also when they go out to "
"people that order the seed."
msgstr ""
"우리는 멸종위기에 처한 식물 씨앗에 초점을 맞춘 그룹에 계속 참여하고 있습니다.  그들은 씨앗이 들어올 때, 그리고 씨앗을 주문하는 "
"사람들에게 갈 때도 메모하기를 원합니다."

#: ../../use_cases-zadenbank.rst:8
msgid ""
"In ghini, we keep speaking of ›Plants‹, ›Locations‹, while such user "
"groups focus on ›Seeds‹ and ›Jars‹ and ›Drawers‹ and ›Boxes‹ and "
"›Envelopes‹.  So people wonder whether ghini could be adapted to their "
"use case, or for directions on how to develop their own database."
msgstr ""
"인히니에서는, 우리는 계속해서 \"식물\", \"위치\"에 대해 말하는 반면, 그러한 사용자 그룹은 \"씨앗\", \"자르스\", "
"\"드로어\", \"상자\", \"엔볼프\"에 초점을 맞추고 있다.  그래서 사람들은 기니가 그들의 사용 사례에 적응할 수 있을지 아니면 "
"그들 자신의 데이터베이스를 개발하는 방법에 대한 방향을 정할 수 있을지 궁금해 한다."

#: ../../use_cases-zadenbank.rst:13
msgid "Does ghini need being adapted for such a seed database?"
msgstr "이러한 시드 데이터베이스를 위해 기니를 개조해야 합니까?"

#: ../../use_cases-zadenbank.rst:16
msgid ""
"no it doesn't need any adaptation, it's just that you need to read some "
"of its terms differently."
msgstr "적응할 필요가 없습니다. 단지 일부 용어를 다르게 읽을 필요가 있을 뿐입니다."

#: ../../use_cases-zadenbank.rst:19
msgid ""
"the taxonomy part is just taxonomy, plant species information, no need to"
" explain that, no way to interpret it otherwise."
msgstr "분류학 부분은 단지 분류학, 식물 종 정보입니다. 설명할 필요가 없습니다. 달리 해석할 방법이 없습니다."

#: ../../use_cases-zadenbank.rst:22
msgid ""
"›Accessions‹ and ›Plants‹, you know what an ›Accession‹ is, but since "
"you're consistently handling ›Plants‹ still only in seed form, the "
"Wikipedia explanation of an accession sounds like this: it is a seed or "
"group of seeds that are of the same taxon, are of the same propagule type"
" (or treatment), were received from the same source, were received at the"
" same time."
msgstr ""
"access액세스먼트 and와 pl플랜트,, 당신은 ion액세스션 is이 무엇인지 알고 있지만, 당신은 pl식물 still을 여전히 씨앗 "
"형태로만 취급하고 있기 때문에, 위키백과의 설명은 다음과 같이 들린다: 그것은 같은 종자 또는 종자이며, 같은 종류의 종자이며, 동일한 "
"전파 형태(또는 치료)로부터 받은 것이다.동시에"

#: ../../use_cases-zadenbank.rst:29
msgid ""
"If you hold seeds in jars, or in other sort of containers that is able to"
" hold hundreds of seeds, please make sure that a jar contains seeds of "
"just one accession, as above described: same taxon, same treatment, same "
"source, same time."
msgstr ""
"만약 여러분이 항아리나 수백 개의 씨앗을 담을 수 있는 다른 종류의 용기에 씨앗을 담는다면, 항아리에 단지 하나의 씨앗이 들어 있는지 "
"확인해주세요. 위에서 설명한 것처럼, 같은 분류법, 동일한 처리법, 동일한 출처, 같은 시간."

#: ../../use_cases-zadenbank.rst:34
msgid ""
"Each one of your ›Jars‹ of seeds is in ghini speak a ›Plant‹, and the "
"amount of seeds in the ›Jar‹ is the ›Plant‹ ›quantity‹.  An ›Envelope‹ is"
" just the same as a ›Jar‹: a container of seeds from the same "
"›Accession‹, just presumably smaller."
msgstr ""
"씨앗의 각 j자르스(Jars)는 기니어로 \"식물\"이며, jar자르스(Jars)의 씨앗의 양은 \"식물\"(\"양\")입니다.  "
"엔벨롭(Envelope)은 jar자르(Jar)와 동일하며, 같은 access액세스션(Accession)의 씨앗을 담은 용기이며, 크기가 "
"작을 것으로 추측된다."

#: ../../use_cases-zadenbank.rst:39
msgid ""
"A ›Box‹ (where you keep several ›Envelopes‹) or a ›Drawer‹ (where you "
"keep several ›Jars‹) are in ghini speak a ›Location‹."
msgstr ""
"〈Box〉(여러 개의 〈Envopes〉를 보관하는 곳) 또는 〈Drawer〉(여러 개의 〈Jars〉를 보관하는 곳)는 기니어로 "
"〈Location〉을 말한다."

#: ../../use_cases-zadenbank.rst:42
msgid ""
"Since a ›Jar‹ or an ›Envelope‹ contains seeds from an ›Accession‹, you "
"will clearly label it with its ›Accession‹ code (and trailing ›Plant‹ "
"number).  You might write the amount of seeds, too, but this would be "
"repeating information from the database, and repeating information "
"introduces an inconsistency risk factor."
msgstr ""
"jarJar or 또는 enEncope는 accessAccession,의 씨앗을 포함하므로, accessAccession code 코드("
"및 plantPlant number 번호 후행)로 명확하게 레이블을 붙입니다.  시드 양도 작성할 수 있지만, 데이터베이스의 정보를 "
"반복할 수 있으며, 반복할 경우 일관성 없는 위험 요소가 발생합니다."

#: ../../use_cases-zadenbank.rst:48
msgid "How do I handle receiving a batch of seeds?"
msgstr "씨앗 한 묶음 받는 건 어떻게 처리하죠?"

#: ../../use_cases-zadenbank.rst:51
msgid ""
"When we receive seeds, we either collect them ourselves, or we receive it"
" from an other seed collector.  We handle receiving them possibly on the "
"spot, or with a small delay. Even when handled together with several "
"other batches of seeds we received, each batch keeps its individuality."
msgstr ""
"우리가 씨앗을 받을 때, 우리는 직접 씨앗을 모으거나, 아니면 다른 씨앗 수집가로부터 씨앗을 받습니다.  우리는 그들을 현장에서 또는 "
"약간의 지연으로 받을 수 있습니다. 우리가 받은 몇 개의 다른 씨앗 묶음과 함께 처리할 때에도, 각각의 묶음은 그 개성을 유지한다."

#: ../../use_cases-zadenbank.rst:57
msgid ""
"We want to be later able to find back, for example, how many seeds we "
"still have from a specific batch, or when we last received seeds from a "
"specific source."
msgstr ""
"우리는 나중에 다시 찾을 수 있기를 원합니다. 예를 들어, 우리가 얼마나 많은 씨앗을 가지고 있는지, 또는 우리가 마지막으로 특정 "
"소스로부터 씨앗을 받았을 때 말입니다."

#: ../../use_cases-zadenbank.rst:61
msgid ""
"As long as you put this information in the database, as long as you "
"follow the same convention when doing so, you will be able to write and "
"execute such queries using ghini."
msgstr "이 정보를 데이터베이스에 넣는 한, 동일한 규칙을 따르는 한, 지니를 사용하여 이러한 쿼리를 작성하고 실행할 수 있습니다."

#: ../../use_cases-zadenbank.rst:65
msgid ""
"One possibility, the one described here, is based on ›Notes‹.  (Ghini "
"does not, as yet, implement the concept \"Acquisition\". There is an "
"issue related to the Acquisition and Donation objects, but we haven't "
"quite formalized things yet.)"
msgstr ""
"여기서 설명하는 한 가지 가능성은 \"주석\"에 기초합니다.  (Ghini는 아직 \"Acquisition\" 개념을 구현하지 "
"않았습니다. 인수 및 기부 대상과 관련된 문제가 있지만 아직 공식화된 것은 아닙니다.)"

#: ../../use_cases-zadenbank.rst:70
msgid ""
"You surely already use codes to identify a batch of seeds entering the "
"seed bank.  Just copy this code in a ›Note‹, category 'received', to each"
" ›Accession‹ in the received batch.  This will let you select the "
"›Accessions‹ by the query::"
msgstr ""
"여러분은 이미 시드 뱅크로 들어가는 시드 묶음을 식별하기 위해 코드를 사용하고 있습니다.  이 코드를 받은 일괄 처리의 각 "
"\"Accession\"(액세스)에 '수신됨' 범주인 \"참고\"에 복사하기만 하면 됩니다.  이렇게 하면 다음과 같이 쿼리로 "
"\"Accessions\"(액세스)를 선택할  있읍니다. 니::"

#: ../../use_cases-zadenbank.rst:77
msgid ""
"Use the 'Source' tab if you think so, it offers space for indicating an "
"external source, or an expedition.  When receiving from an external "
"source, you can specify the code internal to their organization.  This "
"will be useful when requesting an extra batch."
msgstr ""
"'소스' 탭을 사용하면 외부 소스 또는 원정을 나타낼 수 있는 공간이 제공됩니다.  외부 소스에서 수신하는 경우 해당 조직 내부의 코드를 "
"지정할 수 있습니다.  이것은 추가 배치를 요청할 때 유용합니다."

#: ../../use_cases-zadenbank.rst:82
msgid "How do I handle sending seeds?"
msgstr "씨앗을 어떻게 보내야 하죠?"

#: ../../use_cases-zadenbank.rst:85
msgid ""
"what you physically do is to grab the desired amount of seeds of the "
"indicated species from a jar, put it in an envelope and send it.  what "
"you do from a point of view of the database is exactly the same, but "
"precisely described in a protocol:"
msgstr ""
"여러분이 물리적으로 하는 일은 항아리에서 원하는 양의 종자를 가져와 봉투에 넣고 보내는 것입니다. 데이터베이스의 관점에서 여러분이 하는 "
"일은 정확히 같지만 프로토콜에 정확히 설명되어 있습니다:"

#: ../../use_cases-zadenbank.rst:90
msgid ""
"Use the database to identify the ›Jar‹ containing the desired amount of "
"the right seeds."
msgstr "데이터베이스를 사용하여 원하는 양의 올바른 시드가 들어 있는 ‹Jar the를 식별합니다."

#: ../../use_cases-zadenbank.rst:92
msgid "remove that amount of seeds from the ›Jar‹ (decrement the quantity),"
msgstr "jarJar (에서 그 정도의 씨앗을 제거한다. (수량을 줄인다.)"

#: ../../use_cases-zadenbank.rst:93
msgid "put the seeds in an ›Envelope‹ (yes, that's a database object)."
msgstr "시드를 \"Envelope\"(예, 데이터베이스 개체입니다)에 넣습니다."

#: ../../use_cases-zadenbank.rst:94
msgid "send the envelope (but keep it in the database)."
msgstr "봉투를 보내다"

#: ../../use_cases-zadenbank.rst:96
msgid "this in short."
msgstr "요컨대 이것"

#: ../../use_cases-zadenbank.rst:98
msgid ""
"When I send seeds, it's not just one bag, how does ghini              "
"help me keeping things together?"
msgstr "제가 씨앗을 보낼 때, 가방 하나가 아니라, 기니가 어떻게 제 물건들을 함께 보관하는데 도움을 줄까요?"

#: ../../use_cases-zadenbank.rst:102
msgid ""
"There's two levels of keeping things together: one is while you're "
"preparing the sending, and then for later reference."
msgstr "두 가지 수준의 정보를 함께 보관할 수 있습니다. 하나는 발송을 준비하는 동안이고, 나중에 참조할 수 있습니다."

#: ../../use_cases-zadenbank.rst:105
msgid ""
"While preparing the sending, we advise you use a temporary ›Tag‹ on the "
"objects being edited."
msgstr "전송을 준비하는 동안 편집 중인 개체에 임시 \"Tag\"를 사용하는 것이 좋습니다."

#: ../../use_cases-zadenbank.rst:108
msgid ""
"For later reference, you will have common ›Note‹ texts, to identify "
"received and sent batches."
msgstr "나중에 참조할 수 있도록, 수신 및 발송된 배치를 식별하는 공통 \"참고\" 텍스트가 제공됩니다."

#: ../../use_cases-zadenbank.rst:111
msgid "Can you give a complete example?"
msgstr "당신은 완전한 예를 들어줄 수 있나요?"

#: ../../use_cases-zadenbank.rst:114
msgid "Right.  Quite fair.  Let's see…"
msgstr "맞아. 꽤 공정해요.자 see…"

#: ../../use_cases-zadenbank.rst:116
msgid ""
"Say you were requested to deliver 50 seeds of Parnassia palustris, 30 of "
"Gentiana pneumonanthe, 80 of Fritillaria meleagris, and 30 of Hypericum "
"pulchrum."
msgstr ""
"파르나시아 팔루스트리스 씨 50마리, 젠티아나 폐렴구균 씨 30마리, 프리틸라리아멜레그리스 씨 80마리, 그리고 하이릭럼 펄크럼 씨 "
"30마리를 배달해 달라고 요청받았다고 가정해 보세요."

#: ../../use_cases-zadenbank.rst:120
msgid "**step 1**"
msgstr "**1단계**"

#: ../../use_cases-zadenbank.rst:122
msgid ""
"The first step is to check the quantities you have in house, and if you "
"do have enough, where you have them.  You do this per requested species::"
msgstr ""
"첫 번째 단계는 여러분이 가지고 있는 수량과, 만약 여러분이 충분히 가지고 있다면, 그것들을 어디에 가지고 있는지 확인하는 것입니다.  "
"요청된 종에 따라 다음을 수행합니다::"

#: ../../use_cases-zadenbank.rst:128
msgid ""
"Expand in the results pane the ›Accession‹ from which you want to grab "
"the seeds, so you see the corresponding ›Jars‹, highlight one, and tag it"
" with a new ›Tag‹.  To do this the first time, go through the steps, just"
" once, of creating a new ›Tag‹.  The new tag becomes the active tag, and "
"subsequent tagging will be speedier.  I would call the tag ›sending‹, but"
" that's only for ease of exposition and further completely irrelevant."
msgstr ""
"결과 창에서 시드를 가져올 \"Accession\"을 확장하면 해당하는 \"Jars\"가 표시되고, 하나를 강조 표시한 후 새 \"Tag"
"\"로 태그가 지정됩니다.  처음 이 작업을 수행하려면 새 tag태그 a를 만드는 단계를 한 번만 진행하십시오.  새 태그가 활성 태그가 "
"되고 이후 태그가 더 빨라집니다.  나는 그 태그를 \"보내기\"라고 부르고 싶지만, 그것은 단지 설명을 쉽게 하기 위해서일 뿐이고 더 "
"이상 전혀 관련이 없다."

#: ../../use_cases-zadenbank.rst:136
msgid ""
"Repeat the task for Gentiana pneumonanthe, Fritillaria meleagris, "
"Hypericum pulchrum::"
msgstr "Gentiana 폐렴구균, Fritillaria melegris, Hypericum pulchrum에 대해 작업을 반복합니다::"

#: ../../use_cases-zadenbank.rst:143
msgid ""
"Again highilight the accession from which you can grab seeds, and hit "
"Ctrl-Y (this tags the highighted row with the active tag).  Don't worry "
"if nothing seems to happen when you hit Ctrl-Y, this is a silent "
"operation."
msgstr ""
"시드를 가져올 수 있는 등록 정보를 다시 강조 표시하고 Ctrl-Y를 누릅니다(이것은 활성 태그로 고경도 행을 태그).  Ctrl-Y를 "
"눌렀을 때 아무 일도 일어나지 않는 것 같아도 걱정하지 마십시오. 이것은 조용한 작업입니다."

#: ../../use_cases-zadenbank.rst:148
msgid "**step 2**"
msgstr "2단계"

#: ../../use_cases-zadenbank.rst:150
msgid ""
"Now we prepare to go to the seeds bank, with the envelopes we want to "
"fill."
msgstr "이제 우리는 우리가 채워넣고 싶은 봉투를 가지고 씨앗 은행으로 갈 준비를 합니다."

#: ../../use_cases-zadenbank.rst:153
msgid ""
"Select the ›sending‹ ›Tag‹ from the tags menu, this will bring back in "
"the results pane all the tagged ›Plants‹ (›Jars‹ or ›Envelopes‹), and "
"will tell you in which ›Location‹ (›Drawer‹ or ›Box‹) they are to be "
"found.  Write this information on each of your physical envelopes. Write "
"also the ›Species‹ name, and the quantity you can provide."
msgstr ""
"태그 메뉴에서 s보내기‹태그 from를 선택하면 태그가 지정된 모든 pl식물›(jJars or 또는 enEnvopes),)이 결과 창에 "
"다시 표시되고, 어떤 location위치‹(drawDrawer‹ 또는 ‹Box))가 검색되는지 알려줍니다.  각각의 실제 봉투에 이 "
"정보를 쓰세요. 또한 \"종\" 이름과 제공할 수 있는 수량을 기록합니다."

#: ../../use_cases-zadenbank.rst:159
msgid ""
"Walk now to your seeds bank and, for each of the envelopes you just "
"prepared, open the ›Location‹, grab the ›Plant‹, extract the correct "
"amount of seeds, put them in your physical envelope."
msgstr ""
"지금 여러분의 씨앗 은행으로 걸어가서, 여러분이 방금 준비한 각각의 봉투에 대해, \"위치\"를 열고, \"식물\"을 잡고, 알맞은 양의 "
"씨앗을 추출하여 여러분의 실제 봉투에 넣습니다."

#: ../../use_cases-zadenbank.rst:163
msgid "And back to the database!"
msgstr "그리고 데이터베이스로 돌아가!"

#: ../../use_cases-zadenbank.rst:165
msgid "**step 3**"
msgstr "**3단계**"

#: ../../use_cases-zadenbank.rst:167
msgid ""
"If nobody used your workstation, you still have the Tag in the results "
"pane, and it's expanded so you see all the individual plants you tagged."
msgstr ""
"워크스테이션을 사용한 사람이 없는 경우에도 결과 창에 태그가 있고 태그가 확장되어 태그가 지정된 모든 개별 식물을 볼 수 있습니다."

#: ../../use_cases-zadenbank.rst:171
msgid ""
"One by one, you have to ›split‹ the plant.  This is a standard operation "
"that you activate by right-clicking on the plant."
msgstr ""
"Even if no one is using a workstation, you can see all individual plants "
"tagged and tagged in the results pane."

#: ../../use_cases-zadenbank.rst:174
msgid "A plant editor window comes in view, in 'split mode'."
msgstr "플랜트 편집기 창이 '분할 모드'로 표시됩니다."

#: ../../use_cases-zadenbank.rst:176
msgid ""
"Splitting a plant lets you create a database image of the plant group you"
" just physically created, eg: it lets you subtract 30 items from the "
"Gentiana pneumonanthe plant (group number one, that is the one in the "
"jar), and create a new plant group for the same accession.  A good "
"practice would be to specify as ›Location‹ for this new plant the 'out "
"box', that is, the envelope is on its way to leave the garden."
msgstr ""
"식물을 분할하면 물리적으로 방금 생성한 식물 그룹의 데이터베이스 이미지를 생성할 수 있습니다. 예를 들어, 식물에서 Gentiana "
"폐렴구균에서 30개 항목(그룹 1번, 병 안의 항목)을 감산하고 동일한 등록에 사용할 새 식물 그룹을 생성할 수 있습니다.  이 새 "
"식물에 대해 \"위치\"로 지정하는 것이 좋습니다. 즉, 봉투가 정원을 떠나는 중입니다."

#: ../../use_cases-zadenbank.rst:183
msgid "Don't forget to delete the temporary 'sending' ›Tag‹."
msgstr "임시 '보내는' tag태그‹를 삭제하는 것을 잊지 마십시오."

#: ../../use_cases-zadenbank.rst:185
msgid "**step 4**"
msgstr "**4단계**"

#: ../../use_cases-zadenbank.rst:187
msgid ""
"Final step, it represents the physical step of sending the envelope, "
"possibly together with several other envelopes, in a single sending, "
"which should have a code."
msgstr "마지막 단계에서, 그것은 코드를 가지고 있어야 하는, 여러 개의 다른 봉투와 함께, 봉투를 보내는 물리적인 단계를 나타낸다."

#: ../../use_cases-zadenbank.rst:191
msgid ""
"Just as you did when you received a batch of plants, you work with notes,"
" this time the category is 'sent', and the note text is whatever you "
"normally do to identify a sending.  So suppose you're doing a second "
"sending to Pino in 2018, you add the note to each of the newly created "
"envelopes: category 'sent', text: '2018-pino-002'."
msgstr ""
"식물 배치를 받았을 때처럼 노트를 작업하면 이번에는 범주가 '전송'되고 노트 텍스트는 보통 발송을 식별하기 위해 수행하는 작업입니다.  "
"따라서 2018년에 Pino로 두 번째 발송을 한다고 가정하면 새로 작성된 봉투 각각에 메모를 추가합니다. '보낸 문서' 범주, 텍스트: "
"'2018-pino-002'."

#: ../../use_cases-zadenbank.rst:197
msgid ""
"When you finally do send the envelopes, these stop being part of your "
"collection.  You still want to know that they have existed, but you do "
"not want to count them among the seeds that are available to you."
msgstr ""
"마침내 당신이 봉투를 보냈을 때, 이 봉투들은 당신의 수집품의 일부가 되는 것을 멈춥니다.  여러분은 여전히 그것들이 존재했다는 것을 "
"알고 싶어하지만, 여러분은 그것들을 여러분이 이용할 수 있는 씨앗들 사이에서 세고 싶어하지 않습니다."

#: ../../use_cases-zadenbank.rst:201
msgid "Bring back all the plants in the sending '2018-pino-002'::"
msgstr "보내는 '2018-pino-002'에 있는 모든 식물을 다시 가져오세요:"

#: ../../use_cases-zadenbank.rst:205
msgid ""
"You now need to edit them one by one, mark the ›quantity‹ to zero, and "
"optionally specify the reason of the change, which would be ›given away‹,"
" and the recipient is already specified in the 'sent' ›Note‹."
msgstr ""
"이제 그것들을 하나씩 편집하고, \"수량\"을 0으로 표시하고, 선택적으로 \"주어진\" 변경 이유를 지정해야 하며, 수신자는 이미 "
"\"보낸\" \"참고\"에 명시되어 있습니다."

#: ../../use_cases-zadenbank.rst:209
msgid ""
"This last operation could be automated, we're thinking of it, it would "
"become a script, acting on a selection.  Stay tuned."
msgstr ""
"이 마지막 작업은 자동화될 수 있습니다. 우리는 이 작업을 생각하고 있습니다. 스크립트가 되어 선택 작업을 수행합니다.  채널을 고정해 "
"주십시오"

#: ../../users.rst:2
msgid "Managing Users"
msgstr "사용자 관리"

#: ../../users.rst:4
msgid "The Ghini users plugin is only available on PostgreSQL based databases."
msgstr "Ghini 사용자 플러그인은 Postgre에서만 사용할 수 있습니다.SQL 기반 데이터베이스."

#: ../../users.rst:7
msgid ""
"The Ghini Users Plugin will allow you to create and manage the "
"permissions of users for your Ghini database."
msgstr "Ghini Users Plugin을 사용하면 Ghini 데이터베이스에 대한 사용자 권한을 생성하고 관리할 수 있습니다."

#: ../../users.rst:10
msgid ""
"You must log in to your database as a user with ``CREATEROLE`` privilege "
"in order to manage other users."
msgstr "다른 사용자를 관리하려면 \"CREATEROLE\" 권한이 있는 사용자로 데이터베이스에 로그인해야 합니다."

#: ../../users.rst:14
msgid "Creating Users"
msgstr "사용자 만들기"

#: ../../users.rst:15
msgid "To create a new user..."
msgstr "새 사용자를 생성하려면..."

#: ../../users.rst:19
msgid "Permissions"
msgstr "권한"

#: ../../users.rst:20
msgid "Ghini allows read, write and execute permissions."
msgstr "Ghini는 읽기, 쓰기 및 실행 권한을 허용합니다."
